---
title: "Starting Out - さぁ、はじめよう"
layout: chapter
---



## Ready, set, go! - 位置について、よーい、ドン!

![挿絵 egg](http://s3.amazonaws.com/lyah/startingout.png)

準備はいいかな? では、はじめよう! あなたが、Introductionを読み飛ばすような人ではないと思いたいが、このチュートリアルに必要なものと、関数の読み込み方が説明されているから、一応、Introductionの最後の節は読んだほうが良いかもしれない。まずは、GHCのインタラクティブモードを起動し、基本的な関数を呼び出して、Haskellの雰囲気を掴むところからはじめよう。では、ターミナルを開いてghciと入力しよう。以下のように、ghciがあなたを出迎えてくれるだろう。

    $ ghci
    GHCi, version 7.10.2: http://www.haskell.org/ghc/  :? for help
    Prelude>

ghciが起動した、おめでとう! ところで、プロンプトが`Prelude>`となっている。こんな長い名前では気が散ってしまうから、以下のように入力して`ghci>`というプロンプトを表示するように変更しよう。

    Prelude> :set prompt "ghci> "
    ghci>

では、簡単な算術演算子を見てみよう。

    ghci> 2 + 15
    17
    ghci> 49 * 100
    4900
    ghci> 1892 - 1472
    420
    ghci> 5 / 2
    2.5

かなり直感的だ。```もちろん、いくつかの演算子を組み合わせて使うこともできる。その場合、演算子は、通常の優先度に従う。また、かっこを使うことで演算子の優先度を明確にしたり、変更することもできる。

    ghci> (50 * 100) - 4999
    1
    ghci> 50 * 100 - 4999
    1
    ghci> 50 * (100 - 4999)
    -244950

えぇ、どうだい? なかなかクールだとは思わない? おっと、ここで注意しないといけないハマりどころがある。、府の数だ。もし、負の数を扱いたいのであれば、それを常にかっこで包むほうがいい。たとえば、`5 * -3`とするとghciは怪訝な顔をするが、`5 * (-3)`とすれば、問題なく動く。

ブール代数も直感的だ。御存知の通り、`&&`は論理積を意味し、`||`は論理和を意味する。そして、`not`は`True`と`False`を反転させる。

    ghci> True && False
    False
    ghci> True && True
    True
    ghci> False || True
    True
    ghci> not False
    True
    ghci> not (True && True)
    False

等しさの判定は、以下のように行う。

    ghci> 5 == 5
    True
    ghci> 1 == 0
    False
    ghci> 5 /= 5
    False
    ghci> 5 /= 4
    True
    ghci> "hello" == "hello"
    True

では、`5 + "llama"`や、`5 == True`はどうなるだろう? そうだね、これらを試そうとすると、すごい剣幕でエラーメッセージが表示される。

    ghci> 5 + "llama"
    <interactive>:3:3:
        No instance for (Num [Char]) arising from a use of ‘+’
        In the expression: 5 + "llama"
        In an equation for ‘it’: it = 5 + "llama"

やったね! ghciは、`"llama"`は数値ではないから、どのように`5`と足すのかわからない、ということを伝えている。もちろん、`"llama"`の代わりに`"four"`や`"4"`にしたとしても、ghciはそれが数値であるとは認めてくれない。`+`は、その左右にあるものが数値であることを期待する。また、`True == 5`とすると、ghciはそれらの型が一致しないと言ってくる`+`が数値とみなせるものに対してのみ機能するように、`==`は比較できるものであれば、どんな2つのものに対しても機能する。ここで重要なのは、どちらも同じ型に属している必要がある、ということだ。りんごとみかんが比較できないように、ね。型については、後で詳しく見ていく。

> Note: 実は`5`は`Int`や`Float`として振る舞えるので、`5 + 4.0`というのができる。`4.0`は`Int`として振る舞えないので、`4.0`の型に`5`の型を合わせるのだ。

さて、まだ気づいていないかもしれないが、我々はすでに関数を使っている。たとえば、`*`というのは2つの数値を受け取り、それを乗算する関数だ。見ての通り、関数を呼び出すのに、2つの数値で関数を挟んでいる。これを中置関数(infix function)と言う。一方、数値を扱わないほとんどの関数は、前置関数(prefix function)と呼ばれる。実際に見てみよう。

通常、関数は前置記法となる。ということで、以降は関数が前置記法で書かれていることを明示的には示さない。最初からそうなっていると仮定する。命令的言語における関数の多くは、関数の名前を書いて、その後に普通はカンマで区切ったパラメータをカッコで包むことで呼び出される。一方、Haskellでは、関数の名前を書いた後に、1つスペースを置いてから、スペースで区切られたパラメータを置くことで関数が呼び出される。手始めに、Haskellの中で最もつまらない関数を呼び出してみよう。

    ghci> succ 8
    9

`succ`関数は、サクセッサが定義されたものであれば何でも受け取り、サクセッサを返す。ご覧のとおり、関数の名前とパラメータをスペースで区切っている。もちろん、ある関数を複数のパラメータを与えて呼び出すのも簡単だ。`min`関数と`max`関数は、数値のように、順番に並べることのできるものを2つ受け取る。そして、`min`は小さい方を、`max`は大きい方を返す。自分で確認してみよう。

    ghci> min 9 10
    9
    ghci> min 3.4 3.2
    3.2
    ghci> max 100 101
    101

関数適用(関数の後ろにスペースを置いて、その後にパラメータを置くことで関数を呼び出すこと)は、最も高い優先度を持つ。これが意味するところは、以下の2つの文が等しい、ということだ。

    ghci> succ 9 + max 5 4 + 1
    16
    ghci> (succ 9) + (max 5 4) + 1
    16

しかし、たとえば9と10を乗算した結果のサクセッサを得ようとするときに、`succ 9 * 10`として求めることはできない。なぜなら、`9`のサクセッサが先に求まってしまい、`10`と`10`の乗算になってしまうからだ。つまり、結果は`100`になる。`91`という結果を得るには、`succ (9 * 10)`と各必要がある。

2つのパラメータを受け取る関数は、バッククォートでその関数を囲むことで中置関数として使うことができる。たとえば、`div`関数は、2つの整数を受け取り、除算した結果を整数として返す。`div 92 10`の結果は`9`となる。しかし、このように関数を呼び出すと、どちらが割る数で、どちらが割られる数なのかわかりにくく、紛らわしい。そこで、中置関数を使って、`92 \`div\` 10`のように関数を呼び出せば、何をしているのかが明確になる。

命令的言語からやってきた多くの人々は、関数適用をするときに間違えてかっこを使ってしまう傾向がある。たとえばC言語では、関数を呼び出すのに、`foo()`や`bar(1)`、`baz(3, "haha")`などのようなかっこの使い方をする。先程説明したとおり、Haskellでは関数適用をするのにスペースを使う。つまり、これらの関数はHaskellでは、`foo`、`bar 1`、`baz 3 "haha"`のようになる。ということで、もし`bar (bar 3),`のような関数を見ても、`bar`という関数を`bar 3`というパラメータを与えて呼び出していると解釈してはいけない。これは、まず内側の`bar`に`3`というパラメータを与えて呼び出し、何らかの数値を得てから、その数値を外側の`bar`い与えて呼び出す、ということを意味する。これをC言語で書くと、`bar(bar(3))`となる。



## Baby's first functions - よちよち関数

ghciを起動したディレクトリで、次の内容を`baby.hs`として保存する。

    doubleMe x = x + x

`:l`で`baby.hs`を読み込む。

    ghci> :l baby
    [1 of 1] Compiling Main             ( baby.hs, interpreted )
    Ok, modules loaded: Main.

`+`はintegerをFloatとみなすので、`doubleMe`はどんな数にも対応できる。

    ghci> doubleMe 1
    2
    ghci> doubleMe 1.23
    2.46

次は、2つの引数を取って、それぞれ2倍した結果を足す`doubleUs`を作ってみる。

    doubleUs x y = x*2 + y*2

`baby.hs`を保存したら、もう一度`:l`で読み込むのをお忘れなく。

    ghci> :l baby
    [1 of 1] Compiling Main             ( baby.hs, interpreted )
    Ok, modules loaded: Main.

試そう。

    ghci> doubleUs 2 3
    10
    ghci> doubleUs 1.5 2.75
    8.5
    ghci> doubleUs 28 88 + doubleMe 123
    478

もちろん、関数の中で他の関数を使うこともできる。`doubleUs`を定義し直すと、次のようになる。

    doubleUs x y = doubleMe x + doubleMe y

ところで、Haskellには関数を定義する順番に制限がないので、`doubleUs`の前に`doubleMe`を定義することができる。

    doubleUs x y = doubleMe x + doubleMe y
    doubleMe x = x + x

次は`doubleSmallNumber`を定義してみる。いきなりだけど、Haskellにおけるifが登場。

    doubleSmallNumber x = if x > 100
                          then x
                          else x*2

命令型言語のifと、Haskellにおけるifの違いは、elseが必要かどうか、というところだ。Haskellでは必ずelseが必要になる。そして、もう一つの違いはHaskellにおけるifはstatementではなく、expressionである、というところだ。expressionというのは、値、あるいは値を返すコードのことで、例えば、`123`、`1 + 23`、`x * y`は、すべてexpressionになる。

Haskellにおけるifはexpressionだから、必ず値を返さなくてはいけない。だからelseを省略することはできない。ここで、ifがexpressionであることを確認してみよう。

    doubleSmallNumber' x = (if x > 100 then x else x*2) + 1

`()`を外してみる。

    doubleSmallNumber'' x = if x > 100 then x else x*2 + 1

ご想像の通り、elseより後ろは、まだexpressionが続いているのだ、と解釈されてしまい、`12 * 2 + 1`と扱われてしまう。

    ghci> doubleSmallNumber'' 12
    25

ちなみに、Haskellでは関数の名前に`'`を使うことができる。ということで、`doubleSmallNumber'`の`'`には特別な意味はない。Haskellの慣習では、関数`foo`を少し変更したときに`foo'`と名前をつけることが多い。

もちろん、次のような名前の関数を作ることだてできる。

    conanO'Brien = "It's a-me, Conan O'Brien!"

この関数について、注目してほしいことが2つある。

1. 関数の名前を小文字から始めている
1. 関数`conanO`は引数を取らない

1.は単にHaskellの制限でそうなっている。2.のような返される値の変わらない関数は、definitionという。



## An intro to lists - リストのご紹介

さて、次はリストについて説明しよう。Haskellにおけるリストはhomogenousなデータ構造だからたとえば `[123, True, "foo"]`というリストは作れない。次のように、リストの中身は同じ種類に揃える必要がある。(`let`は値の定義に使う。後で詳しく説明)リストは`[]`で値を包む。値は`,`で区切る。`,`と値の間にスペースが挟まれてもOKだ。

    ghci> let lostNumbers = [4,8,15,16,23,42]
    ghci> lostNumbers
    [4,8,15,16,23,42]

文字列はCharのリストになっている。例えば`"hello"`は`['h', 'e', 'l', 'l', 'o']`のシンタックスシュガーになる。

    ghci> "hello" == ['h', 'e', 'l', 'l', 'o']
    True

リストを連結するには`++`を使う。

    ghci> [1,2,3,4] ++ [9,10,11,12]
    [1,2,3,4,9,10,11,12]

もちろん、1つの値しか持たないリストを連結することもできる。

    ghci> [1,2,3] ++ [4]
    [1,2,3,4]

リストの先頭に値を追加したい場合、`:` (cons operatorとも言う)を使う。

    ghci> 'A':" SMALL CAT"
    "A SMALL CAT"
    ghci> 5:[1,2,3,4,5]
    [5,1,2,3,4,5]

実は`[1,2,3]`というのもシンタックスシュガーで、実際には`1:2:3:[]`と等しい。([]は空のリスト)

    ghci> 1:2:3:[]
    [1,2,3]

リストからインデックスを指定して値を取り出すには、`!!`を使う。

    ghci> "Steve Buscemi" !! 6
    'B'
    ghci> [9.4,33.2,96.2,11.2,23.25] !! 1
    33.2

存在しないインデックスを与えるとエラーになる。

    ghci> [1,2,3] !! 4
    *** Exception: Prelude.!!: index too large

リストは、リストのリスト、のリスト...のように、ネストすることができる。

    ghci> [[1,2], [3]]
    [[1,2],[3]]

ただし、最初に説明したように、リストの中身は同じ種類にする必要があるから注意してほしい。例えば`[1, [2,3]]`が含んでいるのははIntegerとリストのリストだから、エラーになる。

    ghci> [1,[2,3]]
    <interactive>:33:1:
        Non type-variable argument in the constraint: Num [t]
        (Use FlexibleContexts to permit this)
        When checking that ‘it’ has the inferred type
          it :: forall t. (Num t, Num [t]) => [[t]]

ここで便利な機能を紹介しよう。`>`や`==`などを使って、リストとリストを比較することができる。左側のリストの0番目の値と、右側のリストの0番目の値を比較して、次に左側のリストの1番目の値と右側のリストの1番目の値を比較して...というのを繰り返し、リスト内のすべての要素が条件を満たせば、`True`となる。

    ghci> [3,2,1] > [2,1,0]
    True

他にもリストを操作できる便利な関数が用意されている。headはリストの先頭から要素を1つ取り出す。

    ghci> head [1,2,3]
    1

tailはリストから先頭の要素を取り除いたリストを返す。

    ghci> tail [1,2,3]
    [2,3]

lastはリストの末尾の要素を取り出す。

    ghci> last [1,2,3]
    3

initはリストから末尾の要素を取り除いたリストを返す。

    ghci> init [1,2,3]
    [1,2]

ちなみに、これらは`[]`に対して使うとエラーになる。エラーは実行時に初めてわかるので、`[]`は慎重に扱う必要がある。

    ghci> head []
    *** Exception: Prelude.head: empty list
    ghci> tail []
    *** Exception: Prelude.tail: empty list
    ghci> last []
    *** Exception: Prelude.last: empty list
    ghci> init []
    *** Exception: Prelude.init: empty list

lengthはリストの長さを返す。

    ghci> length [1,2,3]
    3
    ghci> length []
    0

nullはリストが`[]`か判定する。

    ghci> null [1,2,3]
    False
    ghci> null []
    True

reverseはリストを反転する。

    ghci> reverse [1,2,3]
    [3,2,1]
    ghci> reverse []
    []

takeはリストの先頭から指定した数だけ、リストとして値を取り出す。指定した数がリストの長さより大きければ、リストをそのまま返す。

    ghci> take 2 [1,2,3]
    [1,2]
    ghci> take 4 [1,2,3]
    [1,2,3]

dropはtakeと逆の働きをする。

    ghci> drop 2 [1,2,3,4,5]
    [3,4,5]
    ghci> drop 10 [1,2,3,4,5]
    []

maximumはリストの中から最大値を取り出す。

    ghci> maximum [1,2,3]
    3

sumはリストの総和を返す。

    ghci> sum [1,2,3]
    6

productはリストの層積を返す。

  ghci> product [1,2,3,4]
  24

elemはリスト内に与えられた要素が含まれているか判定する。

    ghci> elem 1 [1,2,3]
    True
    ghci> elem 4 [1,2,3]
    False

elemはinfix functionとして使うほうが読みやすい。

    ghci> 1 `elem` [1,2,3]
    True
    ghci> 4 `elem` [1,2,3]
    False



## Texas ranges - テキサス・レンジャー巣

1,2,3...やa,b,c...など、列挙できる￥値のリストを作るときにはrangeを使うことができる。

    ghci> [1,2,3,4,5] == [1..5]
    True

rangeはその感覚を設定できるので、たとえば奇数のリストを作成できる。

    ghci> [1,3 .. 20]
    [1,3,5,7,9,11,13,15,17,19]

rangeは単に先頭2つの値の差を次の値に足しているだけなので、たとえば`[1,4,9,16]`というリストは作れない。

    ghci> [1,4.20]
    [1.0,4.2]

また、`[10..1]`というのは`[]`になるので`[10,9..1]`とする必要がある。

    ghci> [10..1]
    []
    ghci> [10,9..1]
    [10,9,8,7,6,5,4,3,2,1]

rangeでは実数が使えるものの、誤差が積み重なると値が正確ではなくなる。rangeでは実数を使うのはおすすめしない。

    ghci> [0.1, 0.3 .. 1]
    [0.1,0.3,0.5,0.7,0.8999999999999999,1.0999999999999999]  [

さて、ここで興味深い機能を紹介しよう。Haskellでは無限のリストを作り、値を取り出すことができる。ちなみに、`[1..]`とだけ入力すると、`[1,2,3...`と無限に結果が表示され続けてしまう。そのときは、`Ctrl-C`でキャンセルしよう。

    ghci> take 5 [1..]
    [1,2,3,4,5]

cycleは与えたリストを繰り返し、無限リストを作る。

    ghci> take 10 (cycle [1,2,3])
    [1,2,3,1,2,3,1,2,3,1]

repeatは与えた値で無限リストを作る。

    ghci> take 10 (repeat 7)
    [7,7,7,7,7,7,7,7,7,7]

replicateは第2引数で与えた値を第1引数の数だけ繰り返し、リストを作る。

    ghci> replicate 3 10
    [10,10,10]



## I'm a list comprehension - 我はリスト内包表記

ここで、ちょっとした数学の話をしよう。大丈夫、難しい話はしないから読み続けてほしい。以下の数式は、2,4,6...という偶数を10個含む集合を表している。ちなみに、$2 \cdot x$はoutput function、$x$はvariable。$\mathbb{N}$はinput set、$x \leq 10$はpredicateという。

```math
\{2 \cdot x \mid x \in \mathbb{N}, x \leq 10 \}
```

この数式をHaskellで書いてみよう。

    take 10 [2,4..10]

うん、まぁ便利だけど、でも、もっと複雑な場合は?



### List comprehension

もう一度、2,4..という偶数を10個とりだしてみる。List comprehensionを使うと、以下のように書ける。`x`には`[1..10]`から取り出された値が入る。そして、2倍されたxのリストが得られる。

    ghci> [2*x | x <- [1..10]]
    [2,4,6,8,10,12,14,16,18,20]

いいね、期待通り！

次は、条件(predicate)を加えてみる。条件は、`,`で区切った後に書く。試しに、「2倍された値が12より大きいか等しい」という条件を加えてみる。

    ghci> [2*x | x <- [1..10], 2*x >= 12]
    [12,14,16,18,20]

おお、期待通り！じゃあ、「50から100までの自然数の内、7で割ったあまりが3になる数」を求めるには?

    ghci> [x | x <- [50..100], x `mod` 7 == 3]
    [52,59,66,73,80,87,94]

これは便利。ちなみに、リストからpredicateにもとづいて取り出す値を決めることをfilterとも言う。

次は、「10より大きいか等しい奇数は"BANG!"、10より小さい奇数は"BOOM!"、それ以外の数は、何も表示しない(リストに含めない)。」というリストを作ってみる。もちろん、functionのなかでlist comprehensionを使うこともできる。

    boomBangs xs = [ if x < 10 then "BOOM!" else "BANG!" | x <- xs, odd x]

predicateに注目。`odd x`は、`x`が奇数の場合`True~を、そうでない場合は`False`を返す。前に確認したとおり、predicateがTrueになると、リストに値が含まれ、Falseのときはリストから値が覗かれる。

    ghci> boomBangs [7..13]
    ["BOOM!","BOOM!","BANG!","BANG!"]

もちろん、複数のpredicateを使うこともできる。例として、「10から20までの数の内、13、15、19を含めないリスト」を作ってみる。

    ghci> [x | x <- [10..20], x /= 13, x /= 15, x /= 19]
    [10,11,12,14,16,17,18,20]

リストに含まれるのは、すべてのpredicateを満たした値のみ、なので注意してほしい。

次は、複数のリストから値を取り出してみよう。取り出した値は、output functionでjoinできる。例として、リスト`[1,2,3]`と`[4,5,6]`の直積を求めてみよう。

    ghci> [x*y | x <- [1,2,3], y <- [4,5,6]]
    [4,5,6,8,10,12,12,15,18]

`x*y`の組み合わせは、1と4、2と5、3と6ではなく、1と4、1と5、1と6、2と4...となるので注意。この場合、結果として、リストの長さは3 * 3 = 9になる。

次は、`x*y >= 50`というpredictを与えてみる。

    ghci> [ x*y | x <- [2,5,10], y <- [8,10,11], x*y > 50]
    [55,80,100,110]

文字列はリストだから、この機能は文字列に対しても使える。

    ghci> let nouns = ["hobo","frog","pope"]
    ghci> let adjectives = ["lazy","grouchy","scheming"]
    ghci> [adjective ++ " " ++ noun | adjective <- adjectives, noun <- nouns]
    ["lazy hobo","lazy frog","lazy pope","grouchy hobo","grouchy frog",
    "grouchy pope","scheming hobo","scheming frog","scheming pope"]

さて、ここで`length`を自分で作ってみよう。

    length' xs = sum [1 | _ <- xs]

上記の`_`という変数は、この変数は意味を持たない、という意味を表す。つまり、実際には使わない、ダミーの変数であることを示すのに使う。この機能を使うと、たとえば変数を受け取るものの、その変数は使わない、という関数を定義することができる。

    ghci> let mom _ = "Do your homework!"
    ghci> mom "I want to play video games!"
    "Do your homework!"
    ghci> mom "OK. How about playing video games for 10 minutes?"
    "Do your homework!"

おっと、話を元に戻そう。`length'`は、与えられたリスト`xs`に含まれる値を、すべて`1`で置き換える。その後`sum`でリストの値の合計を求める。結果として、与えたリストの長さが得られる、というわけだ。

では、与えられた文字列から小文字を取り除く、という関数を作ってみよう。

    removeNonUppercase st = [ c | c <- st, c `elem` ['A'..'Z']]

文字列もリストだから、この関数は期待通り機能するはずだ。

    ghci> removeNonUppercase "Hahaha! Ahahaha!"
    "HA"
    ghci> removeNonUppercase "IdontLIKEFROGS"
    "ILIKEFROGS"

期待通り！もちろん、predicateの中で、リストが使える。そして、リストを含むリスト、も使えることに注目してほしい。ということで、リストの形を保ったまま、奇数を取り除く関数を作ってみよう。

    ghci> let xxs = [[1,3,5,2,3,1,2,4,5],[1,2,3,4,5,6,7,8,9],[1,2,4,2,1,6,3,1,3,2,3,6]]
    ghci> [ [ x | x <- xs, even x ] | xs <- xxs]
    [[2,2,4],[2,4,6,8],[2,4,2,6,2,6]]

リストを含むリスト、は読みづらいから開業するのがおすすめだ。



## Tuples - タプル

一つ、あるいは複数の値を保持できるという点で、タプルとリストは似ている。ただし、リストは無限リストが作れるのに対し、タプルではそれができない。そして、もう一つの重要な違いは、タプルはhomogenousではない、というところだ。タプルでは、異なる方の値を保持できる。タプルは`()`で値を包んで表す。値は`,`で区切る。

ここで、二次元のベクトルをHaskellで表現する方法を考えてみよう。ひとつはリストを使う方法...[x,y]とすれば、多分、期待通りに動くと思う。じゃあ、二次元の平面上で、なにか図形を表現するとして、幾つかのベクトルを含むリストを作ったらどうなる?そうだね、`[[1,2],[8,11],[4,5]]`という書き方ができる。

    ghci> [[1,2], [3,4], [5,6]]
    [[1,2],[3,4],[5,6]]

ただし，これには問題がある。Haskellのリストは、同じ種類の値しか含めることができない。逆に言えば、例えば`[[1,2], [3,4,5], [6,7]]`というリストはエラーにはならない。「リストを含むリスト」という構造には違反していないからだ。これでは、`[3,4,5]`という3次元のベクトルが含まれるのを防げない。

    ghci> [[1,2], [3,4,5], [6,7]]
    [[1,2],[3,4,5],[6,7]]

ここで、タプルの出番だ。タプル(要素数が2つの場合はペアとも言う)は、それ自身がtypeとして振る舞う。つまり、`(1,2)`と`(1,2,3,)`は違うものとして扱われる。試してみよう。

    ghci> [(1,2), (3,4), (5,6)]
    [(1,2),(3,4),(5,6)]

おおっと、間違えて3次元のベクトル`(3,4,5)`を含めてしまった！

    ghci> [(1,2), (3,4,5), (6,7)]
    <interactive>:97:9:
        Couldn't match expected type ‘(t, t1)’
                    with actual type ‘(Integer, Integer, Integer)’
        Relevant bindings include
          it :: [(t, t1)] (bound at <interactive>:97:1)
        In the expression: (3, 4, 5)
        In the expression: [(1, 2), (3, 4, 5), (6, 7)]
        In an equation for ‘it’: it = [(1, 2), (3, 4, 5), (6, 7)]

このエラーは、「リストには要素数が2つのタプルしか含まれないはずなのに、要素数が3つのタプルが含まれている。」ということを報告している。

もちろん、タプルの要素数だけではなく、タプルに含まれるtypeの組み合わせが一致しなければならない。ということで、、`[(1,2), ("foo", "bar)]`というリストも作ることができない。

    ghci> [(1,2), ("foo", "bar")]
    <interactive>:101:3:
        No instance for (Num [Char]) arising from the literal ‘1’
        In the expression: 1
        In the expression: (1, 2)
        In the expression: [(1, 2), ("foo", "bar")]

タプルは異なるtypeの値を含めることができる。例えば、性、名、年齢をまとめたデータ構造を作ることができる。

    ghci> ("Christopher", "Walken", 55)
    ("Christopher","Walken",55)

タプルの注意点は、すべてのタプルで共通に使える関数は作れない、というところだ。そして、要素数が1つのタプルは、値そのものになる、というところだ。というより、値と、要素数が1のタプルを区別できない、というのが正しい。

    ghci> (1) == 1
    True
    ghci> ("foo") == "foo"
    True

タプルはリストのように比較できる。ただし、先程説明したとおり、すべてのタプルに対して使用できる関数は作ることができない。最初から定義されているのは、ペアに対する関数だけだ。要素数が2より大きいタプルから値を取り出す方法は後で説明する。

`fst`はペアの1つ目の値を取り出す。

    ghci> fst (8,11)
    8
    ghci> fst ("Wow", False)
    "Wow"

`snd`はペアの2つ目の値を取り出す。

    ghci> snd (8,11)
    11
    ghci> snd ("Wow", False)
    False

`zip`は、リスト1とリスト2を与えると、リスト1のn番目の要素とリスト2のn番目の要素を含むペアを作る。

    ghci> zip [1,2,3,4,5] [5,5,5,5,5]
    [(1,5),(2,5),(3,5),(4,5),(5,5)]
    ghci> zip [1 .. 5] ["one", "two", "three", "four", "five"]
    [(1,"one"),(2,"two"),(3,"three"),(4,"four"),(5,"five")]

`zip`は、リストの要素数が一致しない場合、要素数は小さい方に合わせる。

    ghci> zip [5,3,2,6,2,7,2,5,4,6,6] ["im","a","turtle"]
    [(5,"im"),(3,"a"),(2,"turtle")]

`zip`は、無限リストに対しても使える。

    ghci> zip [1..] ["apple", "orange", "cherry", "mango"]
    [(1,"apple"),(2,"orange"),(3,"cherry"),(4,"mango")]

では、タプルとlist comprehensionを組み合わせた問題を説いてみよう。すべての辺が10より小さいか等しく、3辺の合計が24となる直角三角形を求めよう。まずは、すべての辺が10より小さいか等しい三角形を求める。

    ghci> let triangles = [(a,b,c) | c <- [1..10], b <- [1..10], a <- [1..10]]

`triangles`は、辺の長さが10より小さい三角形を列挙した結果となる。

    ghci> triangles
    [(1,1,1),(2,1,1),(3,1,1),(4,1,1),(5,1,1),(6,1,1...

次は、直角三角形という条件を加えよう。直角三角形は$a&2 + b^2 = c^2$となる。cが3つの辺の内、最も長い変だから、aとbはそれより小さくなる。これをHaskellで書くと、こうなる。

    ghci> let rightTriangles = [ (a,b,c) | c <- [1..10], b <- [1..c], a <- [1..b], a^2 + b^2 == c^2]
    ghci> rightTriangles
    [(3,4,5),(6,8,10)]

あとは、3辺の合計が24、という条件を加えれば完成だ。

    ghci> let rightTriangles' = [ (a,b,c) | c <- [1..10], b <- [1..c], a <- [1..b], a^2 + b^2 == c^2, a+b+c == 24]
    ghci> rightTriangles'
    [(6,8,10)]

まずは、問題から導かれる答えの断片を集めて、それから答えの断片を組み合わせたり、変形させたり、フィルターしたりして、目的の答えを得る。これがfunctional programmingの定石だ。
