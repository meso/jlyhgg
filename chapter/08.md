---
title: "Making Our Own Types and Typeclasses - 独自の型と型クラスをつくろう"
layout: chapter
---



これまでの商では、Haskellの既存のtypeやtypeclassについて概観してきた。この商では、独自のtypeやtypeclassを作成し、それをどのように扱うのかを説明しよう。



## Algebraic data types intro - 代数的データ型とは

ここまで、`Bool, Int, Char, Maybe`などのデータtypeを扱ってきた。しかし、自分で定義するにはどうするんだろう? 一つの方法としては、`data`キーワードを用いる方法がある。では、`Bool`というtypeが標準ライブラリの中でどのように定義されているのか見てみよう。

    data Bool = False | True

`data`は、新しくデータtypeを定義する、という意味だ。`=`の前の部分は、これが`Bool`というtypeであることを示している。`=`の後ろは、値のコンストラクタだ。ここでは、typeが持つことのできる異なる値を指定している。`|`は、orと読み替えても良い。つまり、これは`Bool`というtypeは`True`または`False`という値を持つ、と読むことができる。typeの名前と値のコンストラクタは、どちらも大文字からはじめなければならない。

同様に、`Int`というtypeは、次のような定義になりそうだ。

    data Int = -2147483648 | -2147483647 | ... | -1 | 0 | 1 | 2 | ... | 2147483647

値コンストラクタの最初と最後の値は、`Int`が取り得る値の最小値と最大値となるだろう。もちろん実際にこのような定義がされているわけではなく、説明のためにそう書いただけだ。

では、Haskellで図形を表現する方法を考えてみよう。ひとつは、タプルを使う方法だ。たとえば、円は、`(43.1, 55.0, 10.4)`と示すことができ、1、2番目は円の中心座標、3番目は円の半径となる。これは良さそうに見える。しかし、これでは3次元のベクトルなどと解釈されかねない。解決策としては、図形を表現する独自のデータtypeを作る、という手がある。では、円または長方形を表現するデータtypeを定義してみよう。

    data Shape = Circle Float Float Float | Rectangle Float Float Float Float 

さて、これは何なのか? 次のように考えてみよう。まず、`Circle`というコンストラクタは、それぞれ`Float`の値を受け取る3つのフィールドを持つ。値コンストラクタの後には、任意で型を追加することができ、これは値コンストラクタが持つことのできる値の型を示している。ここでは、最初の2つが座標、残りが円の半径となる。そして、長方形の値コンストラクタは、`Float`のみ受け取る4つのフィールドを持つ。最初の2つは長方形の左上の座標を、残りの2つは右下の座標を示している。

ところで、私はフィールドをパラメータであるかのように説明した。実は、値コンストラクタは関数であり、最終的にそのデータtypeの値を返す関数となっている。では、これら2つの値コンストラクタのtype signatureを確認してみよう。

    ghci> :t Circle
    Circle :: Float -> Float -> Float -> Shape
    ghci> :t Rectangle
    Rectangle :: Float -> Float -> Float -> Float -> Shape

やばいね。値コンストラクタは本当にすべて関数だった。すごくない? 次は図形を受け取ってその表面積を返す関数を定義してみよう。

    surface :: Shape -> Float
    surface (Circle _ _ r) = pi * r ^ 2
    surface (Rectangle x1 y1 x2 y2) = (abs $ x2 - x1) * (abs $ y2 - y1)

まず注目すべきは、型宣言だ。`Shape`を受け取り`Float`を返す、と宣言している。なお、`Circle -> Float`と書くことはできないのは、`Circle`が型ではないからだ。これは`True -> Int`という型宣言ができないのと同じ理屈だ。次に注目すべきは、コンストラクタに対してパターンマッチングを行っている、というところだ。実は、コンストラクタに対して(なんと毎回)パターンマッチングを行っていたのだ。たとえば`[]`や`False`、`123`などという値はフィールドが1つもない。コンストラクタを書いてから、値を名前へと束縛していたのだ。ここで注目しているのは円の半径だから、円が座標上のどこにあるのか教えてくれる最初の2つのフィールドを考える必要はないのだ。

    ghci> surface $ Circle 10 20 10
    314.15927
    ghci> surface $ Rectangle 0 0 100 100
    10000.0

よし、動いた。しかし、たとえば`Circle 10 20 5`をプロンプトに直接表示しようとするとエラーになる。これは、Haskellに我々が作成したデータtypeを文字列でどのように表現すればよいのかを、伝えていないのが原因だ。思い出してほしい。Haskellのプロンプトにある値を表示させるときHaskellはその値の文字列表現を得るために、まずは`show`関数を実行するのだった。すると、その文字列が表示される。では、`Shape`を`Show`という型クラスに属するよう、以下のように変更しよう。

    data Shape = Circle Float Float Float | Rectangle Float Float Float Float deriving (Show)

今のところは、まだ`deriving`について考えなくても良い。データ宣言の後ろに`deriving (Show)`というのを追加するだけで、Haskellが自動的にその型を`Show`という型クラスの一部にしてくれる、と考えることに仕様。つまり、こうなる。

    ghci> Circle 10 20 5
    Circle 10.0 20.0 5.0
    ghci> Rectangle 50 230 60 90
    Rectangle 50.0 230.0 60.0 90.0

さて、値コンストラクタは関数だから、マップしたり部分適用したり、なんでもできる。たとえば、半径が異なる同心円のリストがほしい場合、次のように求めることができる。

    ghci> map (Circle 10 20) [4,5,6,6]
    [Circle 10.0 20.0 4.0,Circle 10.0 20.0 5.0,Circle 10.0 20.0 6.0,Circle 10.0 20.0 6.0]

このデータ型はよくできていると思う。が、まだ良くすることができる。では、2次元の空間上のある点を定義する中間的なデータ型を作ってみよう。これを使えば、`Shape`がより理解しやすくなる。

    data Point = Point Float Float deriving (Show)
    data Shape = Circle Point Float | Rectangle Point Point deriving (Show)

`Point`を定義したときに、データ型の名前とコンストラクタの名前が同じである、ということに注目してほしい。これは特別な意味があるわけではなく、データ型とコンストラクタの名前を同じにすることは、値コンストラクタが1つしかない場合によく行われる。さて、`Circle`のフィールドは2つとなり、ひとつは`Point`、もうひとつは`Float`となる。これで、何をしているのかが理解しやすくなった。そして、長方形も同じようにする。この変更が反映される用、表面積を求める関数を調整する必要がある

    surface :: Shape -> Float
    surface (Circle _ r) = pi * r ^ 2
    surface (Rectangle (Point x1 y1) (Point x2 y2)) = (abs $ x2 - x1) * (abs $ y2 - y1)

変更の必要があったのはパターンマッチングの箇所のみだった。円に対するパターンでは、すべての点を無視した。長方形に対するパターンでは、2点のフィールドを得るためにネストされたパターンマッチングを使用した。何かの理由で、2つの点に対する参照が欲しい場合には、`as`パターンを使うことができる。

    ghci> surface (Rectangle (Point 0 0) (Point 100 100))
    10000.0
    ghci> surface (Circle (Point 0 0) 24)
    1809.5574

図形を小突く関数はどうだろう?その関数は図形とx軸方向の移動量とy軸方向の移動量を受け取り、新しい図形を、次元は保ったまま、新しい場所に移動させたものを返す。

    nudge :: Shape -> Float -> Float -> Shape
    nudge (Circle (Point x y) r) a b = Circle (Point (x+a) (y+b)) r
    nudge (Rectangle (Point x1 y1) (Point x2 y2)) a b = Rectangle (Point (x1+a) (y1+b)) (Point (x2+a) (y2+b))

かなり直感的だ。図形の位置を示す点に、小突いた量を加えている。

    ghci> nudge (Circle (Point 34 34) 10) 5 10
    Circle (Point 39.0 44.0) 10.0

`Point`を直接扱いたくなければ、ある大きさの原点に位置する図形を作成するための補助関数を作ってからそれらの図形を小突いてもいい。

    baseCircle :: Float -> Shape
    baseCircle r = Circle (Point 0 0) r
    
    baseRect :: Float -> Float -> Shape
    baseRect width height = Rectangle (Point 0 0) (Point width height)

    ghci> nudge (baseRect 40 100) 60 23
    Rectangle (Point 60.0 23.0) (Point 100.0 123.0)

もちろん、モジュール内にある自分で作ったデータ型を公開できる。そのためには、公開する関数と一緒にデータ型も記述してその後にかっこを加えて公開する予定の値コンストラクタをカンマ`,`で区切って記述する。もし、自作したデータ型に与えるすべての値コンストラクタを公開したい場合は、その部分を単にドット`...`と書く。

ここまで定義してきたデータ型や関数をモジュールにまとめて公開したい場合、以下のように書き始める。

    module Shapes
    ( Point(..)
    , Shape(..)
    , surface
    , nudge
    , baseCircle
    , baseRect
    ) where

`Shape(...)`とすると`Shape`の値コンストラクタをすべて公開する、という意味になるので、今作成したモジュールを読み込んだ人は誰でも`Circle`や`Rectangle`という値コンストラクタを使って図形を作ることができる。ちなみに、これは`Shape (Rectangle, Circle)`と書くのと同じだ。

また、値コンストラクタを1つも公開したくない場合は、エクスポート文に`Shape`と書くこともできる。すると、私達のモジュールを読み込んだ人は、`baseCircle`と`baseRect`という補助関数を使う場合のみ図形を作ることができるようになる。`Data.Map`は、この手法を使っている。たとえば、マップを`Map.Map [(1,2),(3,4)]`として作ることができないのは、値コンストラクタが公開されていないからだ。しかし、補助関数の一つである`fromList`を使うことでマップを作ることができる。思い出してほしい、値コンストラクタはただの関数であり、パラメータをフィールドとして受け取り、たとえば`Shape`などというtypeの値を結果として返す関数であることを。つまり、値コンストラクタを公開しないということはそれらの関数を使ってモジュールを読み込むのを防ぐことになるが、独自のデータ型を返す関数を公開していればその関数を経由して独自のデータ型を作ることができるのだ。

値コンストラクタを公開しないということは、独自のデータ型をより抽象的にして、内部の実装を隠すことになる。加えて、値コンストラクタに対して、私達のモジュールを使用する誰もパターンマッチングを行うことができなくなる。



## Record syntax - レコードシンタックス

OK、じゃあ次は人物を表すデータ型を作る、というのをやってみよう。人物について保持したい情報は次の通り: 姓、名、年齢、慎重、電話番号、そして好きなアイスクリームの味だ。君のことは知らないが、私が他人について知りたいことといえばこれが全てだ。さあ、はじめよう。

    data Person = Person String String Int Float String String deriving (Show)

いいね。最初のフィールドが名、次が姓、その次が年齢、...となっている。では、人物を表す値を作ってみよう。

    ghci> let guy = Person "Buddy" "Finklestein" 43 184.2 "526-2928" "Chocolate"
    ghci> guy
    Person "Buddy" "Finklestein" 43 184.2 "526-2928" "Chocolate"

まぁこれで良いといえば良いかもしれないが、ちょっと読みづらい。では、人物から個々の情報を得るための関数を作成するとしたらどうだろう? 人物から姓を取り出す関数、名を取り出す関数、...などなど。そうだね、それらの関数は次のように定義する必要がある。

    firstName :: Person -> String
    firstName (Person firstname _ _ _ _ _) = firstname
    
    lastName :: Person -> String
    lastName (Person _ lastname _ _ _ _) = lastname
    
    age :: Person -> Int
    age (Person _ _ age _ _ _) = age
    
    height :: Person -> Float
    height (Person _ _ _ height _ _) = height
    
    phoneNumber :: Person -> String
    phoneNumber (Person _ _ _ _ number _) = number
    
    flavor :: Person -> String
    flavor (Person _ _ _ _ _ flavor) = flavor

はぁー、こんな書き方したくないんだよ! かなり面倒で退屈な書き方にもかかわらず、この方法は問題なく動作する。

    ghci> let guy = Person "Buddy" "Finklestein" 43 184.2 "526-2928" "Chocolate"
    ghci> firstName guy
    "Buddy"
    ghci> height guy
    184.2
    ghci> flavor guy
    "Chocolate"

もっとマシな書き方があるに違いない、と思ったそこのあなた! ...ないんだな、これが。

いや、冗談、冗談。Haskellを開発した人達は非常に賢いからこのような状況になることは織り込み済みだ。彼らはデータ型を記述する別の方法を用意した。以下に、record syntaxを使用して、どのように上記の目的を達成するのかを示そう。

    data Person = Person { firstName :: String
                         , lastName :: String
                         , age :: Int
                         , height :: Float
                         , phoneNumber :: String
                         , flavor :: String
                         } deriving (Show)

、スペースで区切りながら1つ1つフィールドのtypeを命名する代わりに波括弧を使用する。まず、フィールド名(たとえば`firstName`など)を書いて、その後に2つのコロン`::`を続け、最後にtypeを指定する。このデータ型は、以前書いたものと全くおなじ結果になる。この方法のメリットは、フィールド名から値を探しだす関数がデータ型に作成されるところだ。データ型を作成するときにrecord syntaxを使うことで、Haskellは自動的に、`firstName, lastName, age, height, phoneNumber, flavor`という関数を作成してくれるのだ。

    ghci> :t flavor
    flavor :: Person -> String
    ghci> :t firstName
    firstName :: Person -> String

もう一つ、record syntaxを使う別の利点がある。データ型に`Show`を引き継がせると、record syntaxを使った場合は表示のされ方が異なり、型をインスタンス化する。たとえば、車を表現するデータ型があるとする。そこで、、、車の製造会社名、モデル名、そして製造された歳を追跡したい、としよう。

    data Car = Car String String Int deriving (Show)

    ghci> Car "Ford" "Mustang" 1967
    Car "Ford" "Mustang" 1967

record syntaxを使って定義した場合は、新しい車を以下のように作ることができる。

    data Car = Car {company :: String, model :: String, year :: Int} deriving (Show)

    ghci> Car {company="Ford", model="Mustang", year=1967}
    Car {company = "Ford", model = "Mustang", year = 1967}

新しい車を作るときは、すべての値を指定する場合に限り、フィールドに指定する値を順番に入力する必要はない。しかし、record syntaxを使わなければ、毎回フィールド名に値を順番通りに入力する必要がある。

record syntaxは、コンストラクタのフィールドが複数あって、どれがどれだか判断しづらい場合に使うとよい。たとえば、3次元のベクトルを作るために`data Vector = Vector Int Int Int`と定義しても、これはどのフィールドがどの要素なのか、というのは明らかだ。しかし、人物や車を表すdata typeは、どのフィールドがどの要素なのか明らかではないから、record syntaxの利点が最大限に享受できる。



## Type parameters - 型パラメータ

値コンストラクタは、ある値をパラメータとして受け取り、新しい値を生成する。たとえば、車のコンストラクタは、3つの値を受け取り、`Car`という新しい値を生成する。同様の方法で、型コンストラクタは、型をパラメータとして受け取り、新しい型を生成する。最初はこれが少々メタっぽく思えるかもしれないが、それほど複雑ではない。もし、C++のテンプレートに馴染みがあるのであれば、類似点がわかるだろう。型パラメータがどのように機能するのかを明らかにするために、既に見てきた型がどのように定義されているのかを見てみよう。

    data Maybe a = Nothing | Just a
i
これが型パラメータだ。そして、`a`という方パラメータがあるので`Maybe`を方コンストラクタと呼ぶ。`Maybe`に`Nothing`ではない、どのような型を保持させたいかにも依るが、この型コンストラクタは、最終的に`Maybe Int, Maybe Car, Maybe String,`などの新しい型を生成する。どんな値も`Maybe`という型を持つことができないのは、それ自身が型なのではなく、型コンストラクタだからだ。このため、ある値は実際に何らかの方の一部である必要があり、また、その型パラメータがすべて満たされている必要がある。

つまり、`Char`を型パラメータとして`Maybe`に渡せば、`Maybe Char`という型が得られる。たとえば`Just 'a'`という値は`Maybe Char`という型を持つのだ。

気づいていなかったと思うが、実は型パラメータを受け取る型を`Maybe`を紹介する前に使っていた。そう、リストという型だ。いくつかシンタックスシュガーはあるが、リスト型は具体的な型を生成するために、パラメータを受け取る。値の型は、`[Int]`や`[Char]`、`[[String], [String]]`などとなるが、値の型が`[]`となることはできない。

Maybe型を概観してみよう。

    ghci> Just "Haha"
    Just "Haha"
    ghci> Just 84
    Just 84
    ghci> :t Just "Haha"
    Just "Haha" :: Maybe [Char]
    ghci> :t Just 84
    Just 84 :: (Num t) => Maybe t
    ghci> :t Nothing
    Nothing :: Maybe a
    ghci> Just 10 :: Maybe Double
    Just 10.0

data typeに含めたい型によって異なる型を作ることができるから、型パラメータはとても便利だ。たとえば、`:t Just "Haha"`とすると、型推論エンジンがその型が`Maybe [Char]`であることを発見してくれるが、、`Just a`の`a`には文字列が入るので、`Maybe a`の`a`も同様に文字列型`[Char]`が入るのだ。

そして、`Nothing`の型が`Maybe a`となっているのに注目してほしい。これはpolymorphic typeだ。たとえばある関数がMaybeな値を受け取るとして、`Nothing`を受け取ったとしてもそれには何の値も入っていないので問題にはならない。`Maybe a`という型は、`123`が`Int`や`Double`として振る舞うのと同様に、`Maybe Int`としても、`Maybe Double`としても機能する。それと似たように、空のリストは`[a]`として振る舞う。空のリストは、どんな型のリストとしても振る舞えるのだ。これにより、`[1,2,3] ++ []`や`["ha","ha","ha"] ++ []`ということができる。

型パラメータを使うのはかなり有益であり、それらを使わない手はない。通常、あるデータ型の値が、型を持たなくても動作するようにしたい場合に型パラメータを使用し、たとえば`Maybe a`という型のように、型を内包させる。定義したい型がある種の箱とみなせるなら、型パラメータを使用すると良い。先程定義した車についてのデータ型を変更してみよう。

    data Car = Car { company :: String
                   , model :: String
                   , year :: Int
                   } deriving (Show)

変更後は、こうなる。

    data Car a b c = Car { company :: a
                         , model :: b
                         , year :: c
                         } deriving (Show)

しかし、これは本当に便利なのか? そうとはいえなさそうだ。なぜかといえば、以前は`Car String String Int`という方に対してのみ動作する関数を定義するだけで良かったからだ。たとえば、元々の車についてのデータ型はちょっとしたテキストを入力するだけで、車についての情報を表示する関数が簡単に作ることができた。

    tellCar :: Car -> String
    tellCar (Car {company = c, model = m, year = y}) = "This " ++ c ++ " " ++ m ++ " was made in " ++ show y

    ghci> let stang = Car {company="Ford", model="Mustang", year=1967}
    ghci> tellCar stang
    "This Ford Mustang was made in 1967"

ちょっとした関数だけど、良い感じだ。型宣言も良い感じに機能している。さて、`Car a b c`は、どうしよう?

    tellCar :: (Show a) => Car String String a -> String
    tellCar (Car {company = c, model = m, year = y}) = "This " ++ c ++ " " ++ m ++ " was made in " ++ show y

上記のように、関数に対して`(Show a) => Car String String a`という型を受け取るよう強制することになる。ご覧のとおり、型シグネチャがより複雑になり、実際に享受できる利便性は、`Car a b c`の`c`として、Showという型クラスのインスタンスであれば何でも受け入れられる、という店のみだ。

    ghci> tellCar (Car "Ford" "Mustang" 1967)
    "This Ford Mustang was made in 1967"
    ghci> tellCar (Car "Ford" "Mustang" "nineteen sixty seven")
    "This Ford Mustang was made in \"nineteen sixty seven\""
    ghci> :t Car "Ford" "Mustang" 1967
    Car "Ford" "Mustang" 1967 :: (Num t) => Car [Char] [Char] t
    ghci> :t Car "Ford" "Mustang" "nineteen sixty seven"
    Car "Ford" "Mustang" "nineteen sixty seven" :: Car [Char] [Char] [Char]

現実の世界では、結局殆どの場面で`Car String String Int`という型を使うことになるから、車というデータ型が型を受け取れるようパラメータ化する価値は、あまりないと言えそうだ。通常、ある型の中に多数の値コンストラクタが含まれていて、それらの型がどう機能するのかが重要ではない時に型パラメータを使う。あるリストが何かのリストであるとき、その何かが、何であるのかについては問題とはならない。もし、 数値のリストからその合計を求めたいのであれば、合計を求める関数は数値のリストを受け取る、という具合に後で定義すれば良い。これはMaybeにも当てはまる。`Maybe`は、何かがある、または何もない、という選択肢を表現する。その何かというのがどんな方であるのかは問題にはならない。

既に紹介した中で、型がパラメータ化されている例といえば、`Data.Map`の`Map k v`だ。`k`はマップのキーとなる型であり、`v`は、それに対応する値の型となる。これは型パラメータがどれほど役立つかを示すには格好の例となる’。キーの型が`Ord`という型クラスの一部であるかぎり、方のパラメータ化は、多数の型から別の多数の型へと対応付けるのを可能にしてくれる。そして、マップの型を定義したいのであれば、データ宣言に型クラス制限を追加したい、と思うかもしれない。

    data (Ord k) => Map k v = ...

しかし、Haskellの根強い監修により、データ宣言の中では型の成約を追加することは不可能となっている。なぜかって? そうだね、そうする利点がないからだ。しかも、型の成約を加えたくなかったとしても、結局それを加える事になる。仮に`Map k v`のデータ宣言にキーが`Ord`に属する、という製薬を加えたとしても加えなかったとしてもマップのキーは`Ord`の一部であること、という成約を関数に加えなければいけなくなる。また、キーが順番を持つかどうかを気にしない関数であれば`(Ord k) =>`を関数の型宣言に加える必要はないし、その制約をデータ宣言に加える必要もない、ということになる。そのような関数の例としては`toList`がある。これはマップを受け取り連想リストへと変換する関数だ。その関数の型シグネチャは`toList :: Map k a -> [(k, a)]`となっている。もし、`Map k v`がデータ宣言の中で型の制約を設けていたら、`toList`は`toList :: (Ord k) => Map k a -> [(k, a)]`のようになるだろう。キーの順番を元に比較したりすることはない関数であるにもかかわらず、だ。

つまり、データ宣言の中に制約を追加する必要はない、ということであり、たとえ理にかなっているように見えたとしても、どの道、関数に型宣言を加えなくてはいけなくなるのだ。

では、3次元のベクトルを表す型を実装して、それを操作する関数も追加してみよう。通常、ベクトルが保持するのは数値の型となるからそれらに対応するために、ここではパラメータ化された型を使用する。

    data Vector a = Vector a a a deriving (Show)
    
    vplus :: (Num t) => Vector t -> Vector t -> Vector t
    (Vector i j k) `vplus` (Vector l m n) = Vector (i+l) (j+m) (k+n)
    
    vectMult :: (Num t) => Vector t -> t -> Vector t
    (Vector i j k) `vectMult` m = Vector (i*m) (j*m) (k*m)
    
    scalarMult :: (Num t) => Vector t -> Vector t -> t
    (Vector i j k) `scalarMult` (Vector l m n) = i*l + j*m + k*n

`vplus`は、2つのベクトルを足し合わせる。2つのベクトルを足し合わせる、というのは、単純にそれぞれの要素を足し合わせればよい。`scalarMult`は、2つのベクトルのスカラー積を、`vectMult`は、ベクトルをスカラーで乗算した結果を求める。これらの関数は、`Int`のベクトル、`Integer`のベクトル、`Float`のベクトルなど、ベクトルが`Num`という型クラスに属してさえいればどんなベクトルに対する操作であっても行える。また、これらの関数の型宣言を確認すると、操作が行えるのは同じ型で構成されたベクトルのみであり、ベクトルが保持する数値の方も、その型と同じでなければならない、というのに気づくだろう。繰り返しになるが、`Num`というクラスに属する、という制約をデータ宣言に加える事ができないのは、そのデータ型を使用する関数でも同じ制約を加える事になるからだ。

ここでもう一度言おう。値コンストラクタと型コンストラクタの違いはとても重要である、と。データ型を宣言するときの、`=`の前にある部分が型コンストラクタであり、その後ろ、(あるいはパイプ`|`の後ろ)に続く部分が値コンストラクタとなる。たとえば、ベクトルを受け取る関数の方として、`Vector t t t -> Vector t t t -> t`という宣言をするのは誤りであり、なぜかといえばベクトルの値コンストラクタは3つのパラメータを受け取るのに対して、型コンストラクタが受け取るのは1つのみだからだ。では、今作ったベクトルを試してみよう。


    ghci> Vector 3 5 8 `vplus` Vector 9 2 8
    Vector 12 7 16
    ghci> Vector 3 5 8 `vplus` Vector 9 2 8 `vplus` Vector 0 2 3
    Vector 12 9 19
    ghci> Vector 3 9 7 `vectMult` 10
    Vector 30 90 70
    ghci> Vector 4 9 5 `scalarMult` Vector 9.0 2.0 4.0
    74.0
    ghci> Vector 2 9 3 `vectMult` (Vector 4 9 5 `scalarMult` Vector 9 2 4)
    Vector 148 666 222



## Derived instances - 産まれたてのインスタンス

Type classes 101という商では、型クラスの基本について学んだ。そこでは、型クラスというのは何らかの振る舞いを定義するある種のインターフェースである、と説明した。ある振る舞いをする型は、型クラスに対するインスタンスと言える。たとえば、`Int`という型は、`Eq`という型クラスのインスタンスであり、なぜかといえば型クラス`Eq`は等しさが比較できる、という振る舞いを定義するからだ。そして、`Intという型が、その方同士で等しさを比較できるのは型クラス`Eq`に属しているからだ。そして、型クラス`Eq`のインターフェースに付属する便利な関数といえば、、`==`と`/=`だ。たとえば、ある型が型クラス`Eq`に属していれば、`==`という関数をその型の値にたいして使用することができる。これが、`4 == 4`や`"foo" /= "bar"`に対して型検査ができる理由だ。

そして、Java、C++やPythonが備えているクラスとも異なるため、それが混乱を招いてしまい多くの人を落胆させるということにも言及した。それらの言語では、クラスはオブジェクトを作る際の設計図であり、そのオブジェクトというのはいくつかの状態を持ち、何らかの動きをするものだ。どちらかというと、型クラスはインターフェースだ。型クラスからデータを作ることはしない。その代わり、先にデータ型をつくり、その後にそれがどう振る舞うのかを考える。たとえば、それが等しさを比較できるようにしたければ、`Eq`のインスタンスとする。また、それが順番を持つようにしたければ、`Ord`という型クラスのインスタンスとすれば良い。

次は、型クラスによって定義された関数を実装することで、独自の方クラスのインスタンスとなる型を手動で作る方法を見ていこう。しかし、まずはEq, Ord, Enum, Bounded, Show, Read`という型クラスについて、ある型に対してHaskellがどのように、かつ自動的にインスタンス化を行なっているのかを見てみよう。あるデータ型を作るときに`deriving`キーワードを使うことで、、Haskellはその文脈内にて肩クラスの振る舞いを引き継がせる。

では、以下のデータ型を考えてみよう。

    data Person = Person { firstName :: String
                         , lastName :: String
                         , age :: Int
                         }

これは人物を表現している。次は、同姓同名かつ同じ年令の人物がいないことを前提としてみよう。そのとき、、2人の人物についてのレコードがあったとして、それが同じ人物を表していることが確認できるだろうか? もちろんできる。その2人に対して等しいか比較してみて、その結果を得ることができる。だから、以下のデータ型が型クラス`Eq`に属しているのは理にかなっている。属性をインスタンスへと引き継ぐのだ。

    data Person = Person { firstName :: String
                         , lastName :: String
                         , age :: Int
                         } deriving (Eq)

ある方に対して型クラス`Eq`をいんすたんすとして引き継がせ、ある方の値に対して`==`または`/=`で比較をすると、Haskellはまず値コンストラクタ(ここでは`Person`という1つの値コンストラクタ)が両方共一致するかを見て、それから両方の値が保持している中身について、それぞれのフィールドの組合せが一致するかを調べる。そして、これが上手くいくには、それぞれのフィールドの方は、すべて型クラス`Eq`に属している必要がある。しかし、両者は`Int`と`String`だから、問題ない。では、`Eq`のインスタンスをテストしてみよう。

    ghci> let mikeD = Person {firstName = "Michael", lastName = "Diamond", age = 43}
    ghci> let adRock = Person {firstName = "Adam", lastName = "Horovitz", age = 41}
    ghci> let mca = Person {firstName = "Adam", lastName = "Yauch", age = 44}
    ghci> mca == adRock
    False
    ghci> mikeD == adRock
    False
    ghci> mikeD == mikeD
    True
    ghci> mikeD == Person {firstName = "Michael", lastName = "Diamond", age = 43}
    True

もちろん、`Person`は`Eq`に属しているから`Person`という型の値に対して、型シグネチャに`Eq`という型の制約がある関数は何でも、たとえば`elem`などを使うことができる。

    ghci> let beastieBoys = [mca, adRock, mikeD]
    ghci> mikeD `elem` beastieBoys
    True

`Show`と`Read`という型クラスは、それぞれある値を文字列へ、あるいは文字列からある値へ変換する`Eq`と同様に、ある方を`Show`と`Read`のインスタンスとした場合は、その型の型コンストラクタが持つフィールドも、それぞれ`Show`と`Read`に属している必要がある。では、`Person`というデータ型を`Show`と`Read`にも属させてみよう。

    data Person = Person { firstName :: String
                         , lastName :: String
                         , age :: Int
                         } deriving (Eq, Show, Read)

これで、人物データを表示できるようになった。

    ghci> let mikeD = Person {firstName = "Michael", lastName = "Diamond", age = 43}
    ghci> mikeD
    Person {firstName = "Michael", lastName = "Diamond", age = 43}
    ghci> "mikeD is: " ++ show mikeD
    "mikeD is: Person {firstName = \"Michael\", lastName = \"Diamond\", age = 43}"

もし、人物データの型を`Show`に属させる前に、ターミナルへ表示させようとしたら、Haskellは人物のデータを文字列で表現する方法を知らない、と文句をつけてきただろう。だが、もう`Person`に`Show`を引き継がせたから、怒られることはない。

`Read`は`Show`とは正反対の型クラスだ。`Show`は`Person`という型の値を文字列へと変換してくれるが、`Read`は文字列から値へと変換する。覚えているかもしれないが、`read`を使って文字列からある値へ変換するときは、Haskellに結果として返してほしい目的の方を伝えるために、明示的な型注釈をする必要があるのだった。明示的に、結果の型を指定しなければ、Haskellはどんな型の値を返せばよいのか判断できない。

    ghci> read "Person {firstName =\"Michael\", lastName =\"Diamond\", age = 43}" :: Person
    Person {firstName = "Michael", lastName = "Diamond", age = 43}

もし、`read`で読み取った結果を同じ型とともに後で使うのであれば、Haskellは文字列から読み取った値の型を推論できるので、明示的な型注釈をしなくてもよい。

    ghci> read "Person {firstName =\"Michael\", lastName =\"Diamond\", age = 43}" == mikeD
    True

また、パラメータ化された方も読み取れるが、型パラメータをすべて満たす必要がある。つまり、`read "Just 't'" :: Maybe a`できないが、`read "Just 't'" :: Maybe Char`はできる。

さて、型クラス`Ord`をインスタンスとして引き継ぐことができその型の値は順番を持つのだった。もし、異なるコンストラクタで作られた2つの値を比較した場合、先に定義されたコンストラクタで作られた値のほうがより小さいと判断される。たとえば、値として`True`か`False`のどちらかを持つ`Bool`という型を考えてみよう。それぞれの値を比較した場合にどう振る舞うかを調べる目的のために、`Bool`が以下のように実装されているものと仮定しよう。

    data Bool = False | True deriving (Ord)

`False`という値コンストラクタが先に定義され、その後に`True`という値コンストラクタが定義されているので、`True`のほうが`False`より大きいと判断される。

    ghci> True `compare` False
    GT
    ghci> True > False
    True
    ghci> True < False
    False

`Maybe a`というデータ型は、`Just a`の前に`Nothing`という値コンストラクタが指定されているので、`Nothing`という値は、たとえ`Just a`の`a`がマイナス1億でも1兆でも関係なく常に`Nothing`のほうが小さいとみなされる。しかし、`Just a`という値同士を比較した場合は、中味の`a`の部分の値をもとに比較される。

    ghci> Nothing < Just 100
    True
    ghci> Nothing > Just (-49999)
    False
    ghci> Just 3 `compare` Just 2
    GT
    ghci> Just 100 > Just 50
    True

しかし、たとえば`Just (*3) > Just (*2)`のような比較は行えず、これは`(*3)`などの関数は、型クラス`Ord`に属していないからだ。

さて、`Enum`や`Bounded`という型クラスのおかげで、列挙可能な代数的データ型を簡単に作ることができる。では、以下のデータ型を考えてみよう。

    data Day = Monday | Tuesday | Wednesday | Thursday | Friday | Saturday | Sunday

すべての値コンストラクタがパラメータ、すなわちフィールドに引数を取らないので、型クラス`Enum`に属させることができる。型クラス`Enum`は、predecessorとsuccessorを持つもの、つまり前後関係があるものを対象とする。また、下限の値と上限の値を持つものに対しては型クラス`Bounded`に属することができる。では、上記で紹介したものに加えて、その他の継承可能な型クラスを引き継がせて、インスタンスを作ると、その結果がどうなるのか見てみよう。

    data Day = Monday | Tuesday | Wednesday | Thursday | Friday | Saturday | Sunday
               deriving (Eq, Ord, Show, Read, Bounded, Enum)

これは型クラス`Show`と`Read`に属しているから、このデータ型の値を文字列へ、あるいは文字列から変換できる。

    ghci> Wednesday
    Wednesday
    ghci> show Wednesday
    "Wednesday"
    ghci> read "Saturday" :: Day
    Saturday

型クラス`Eq`と`Ord`に属しているから、日付同士を比較できる。

    ghci> Saturday == Sunday
    False
    ghci> Saturday == Saturday
    True
    ghci> Saturday > Friday
    True
    ghci> Monday `compare` Wednesday
    LT

また、型クラス`Bounded`にも属しているから、曜日の最小値と最大値が得られる。

    ghci> minBound :: Day
    Monday
    ghci> maxBound :: Day
    Sunday

加えて、型クラス`Enum`にも属しているから、ある曜日の前後の曜日を得ることができるし、レンジを使って曜日のリストを作ることもできる。

    ghci> succ Monday
    Tuesday
    ghci> pred Saturday
    Friday
    ghci> [Thursday .. Sunday]
    [Thursday,Friday,Saturday,Sunday]
    ghci> [minBound .. maxBound] :: [Day]
    [Monday,Tuesday,Wednesday,Thursday,Friday,Saturday,Sunday]

いやあ、素晴らしいね。



## Type synonyms - 型シノニム

以前、型の書き方について説明した時、`[Char]`というのは`String`と同じであり、交換可能であると説明した。これは、、型シノニムにより実装されている。型シノニム自体が何かすることはなく、単純にある型に対して異なる名前を与えるものであり、コードの可読性を向上させたり、ドキュメンテーションを読みやすくしたりする。以下に、`[Char]`の型シノニムとして`String`が標準ライブラリでどのように定義されているかを示す。

    type String = [Char]

`type`キーワードを紹介しよう。このキーワードはミスリードを誘う。なぜかといえば新しく型を作るには`data`キーワードが必要であり、これはあくまで既存の型の別名を作るのであり、新しい型を作ることはないからだ。

たとえば、文字列を大文字へと変換する`toUpperString`のような関数をつくるとしたら、その方宣言は`toUpperString :: [Char] -> [Char]`または、`toUpperString :: String -> String`となるだろう。どちらの関数も本質的には同じだが、後者のほうが読みやすい。

さて、以前`Data.Map`モジュールを扱ったときは、マップへと変換する前に、まずは電話帳を表現するものとして連想リストを作った。そして、連想リストというのはキーと値のペアで構成されたものである、というのを学んだ。ここで、その電話帳をもう一度見てみよう。


    phoneBook :: [(String,String)]
    phoneBook =
        [("betty","555-2938")
        ,("bonnie","452-2928")
        ,("patsy","493-2928")
        ,("lucille","205-2928")
        ,("wendy","939-8282")
        ,("penny","853-2492")
        ]

電話帳の型は`[String, String)]`となっている。これは、連想リストが文字列から文字列へと対応しているのを示しているが、リストについての情報はそれだけだ。では、型シノニムを使ってもう少し型宣言の情報が伝わるようにしてみよう。

    type PhoneBook = [(String,String)]

これで、電話帳の型宣言は`phoneBook :: PhoneBook`とすることができる。では、`String`の代わりにこの型シノニムを使ってみよう。

    type PhoneNumber = String
    type Name = String
    type PhoneBook = [(Name,PhoneNumber)]

Haskellプログラマーが、ある関数の中で使われている文字列が何を表現しているのかを明らかにしたいときに`String`という方に型シノニムを与える、という方法を使用する。

それでは、名前と番号を受け取って、その組合せが先ほどの電話帳に存在するか確認する関数を実装するとしよう。私たちはわかりやすくかつ説明的な型宣言を行うことができる。

    inPhoneBook :: Name -> PhoneNumber -> PhoneBook -> Bool
    inPhoneBook name pnumber pbook = (name,pnumber) `elem` pbook


もし型シノニムを使わないと決めたのなら、関数は`String -> String -> [(String,String)] -> Bool`という型にしなくてはいけなくなる。そうすると、型宣言では、型シノニムのほうが理解しやすいというアドバンテージを得られる。しかし、型シノニムについて敏感になってはいけない。型シノニムは、関数の中に現れる既存の型について説明するものであり(そして、それが型宣言をより良いドキュメントへと変化させてくれるのであり)また、`[(String,String)]`を長々と繰り返すような型を持つ関数についてその型が何なのかを説明するものだという紹介をしたが、型シノニムは関数の文脈の中でより特定した何かを表すのだった。

型シノニムもパラメータ化できる。たとえば、連想リストを表す型がほしいとして、それをより汎用的にさせたい、つまり、どんな方でもキーやその値として使いたい場合には、以下のようにすることができる。

    type AssocList k v = [(k,v)]

さて、これで連想リストからキーをもとに値を得る関数の型は`(Eq k) => k -> AssocList k v -> Maybe v`となる。この`AssocList`は型コンストラクタであり、2つの型を受け取って、具体的な型、たとえば`AssocList Int String`という型を生成する。

？？？　「具体的な型の話をしたとき、あ、いや、それとpolymorphicな関数を扱うときにも話したっけ、具体的な型、っていうのは`Map Int String`みたいに全て適用された型っていう意味で話したんだ。ああ、それからさ、俺もたまに間違えるんだけど、あいつら`Maybe`は型だって言ってたでしょ? あれ間違ってて、型、じゃなくて型コンストラクタ、なんだよね。`Maybe Int`みたいに、なんか型を適用すれば具体的な型になるわけ。あとさ、知ってると思うけど、値の方ってのは具体的な型になるから。はい、じゃあ、まとめ!人生太く短く...じゃなくて、誰かと話すときは型と型コンストラクタを間違えない、間違えさせない。」

関数へ部分的に関数を与えれば、新しい関数が生成されるように、型コンストラクタに型パラメータを与えれば、新しい型が得られる。また、関数をパラメータが足りていない状態で呼び出せば新しい関数が得られうように、型コンストラクタへ部分的にパラメータを指定すると、部分適用された型コンストラクタが得られる。たとえば、(`Data.Map`の)マップについて、`Int`から何かへひも付けたければ、以下のように、どちらの方法を選択しても良い。

    type IntMap v = Map Int v

もしくは、以下のようにする。

    type IntMap = Map Int

どちらの方法にせよ、`IntMap`という型コンストラクタは、`Int`から何へ紐付けるか、という1つのパラメータを受け取る。

それから、コレを実装するなら`Data.Map`をqualified importすることになると思うが、qualified importするときは型コンストラクタのほうもモジュール名を先に付け加える必要がある。つまり、`IntMap = Map.Map Int`のようにする必要がある。


値コンストラクタと型コンストラクタの違いをしっかりと理解するようにしよう。なぜかと言えば、`IntMap`や`AssocList`という型シノニムを作ったが、`AssocList [(1,2),(4,5),(7,9)]`のようなことはできないからだ。これらが意味するのは、ある方を異なる名前で参照できるということだ。つまり、たとえば`IntMap`の場合、`[(1,2),(3,5),(8,9)] :: AssocList Int Int`のように`Int`型を前提として作ることになるが、これは、ただ単純に整数のペアを保持する普通のリストとしても使える。型シノニム(と一般的な型)は、、Haskellにおける型の一部だ。また、(`data`を使うときや型宣言をして新しい方を定義するときも常にHaskellの型の一部となり、また、`a ::`の後ろに位置するものは、すべて型となる。そう、コロン`::`を使うのは、型宣言か型注釈のときだ。

もうひとつ、2つのパラメータを受け取るデータ型として興味深いのが`Either a b`という型だ。こんな風に定義されている。

    data Either a b = Left a | Right b deriving (Eq, Ord, Read, Show)

値コンストラクタが2つある。`Left`が使われれば、その中味である`a`という型が使われ、`Right`が使われれば、その中身である`b`という型が使われる。つまり、この型を使うことで、ある値の型をどちらか一方に包み隠して、`Either a b`という型の値を得ることになる。通常、`Left`と`Right`が異なるのを前提に、両方に対してパターンマッチングを行う。

    ghci> Right 20
    Right 20
    ghci> Left "w00t"
    Left "w00t"
    ghci> :t Right 'a'
    Right 'a' :: Either a Char
    ghci> :t Left True
    Left True :: Either Bool b

ここまで、`Maybe`は、計算の結果が失敗したか否かを表現する手段として役立つということを見てきた。しかし、`Maybe`でも十分ではない場合があり、なぜかと言えば、`Nothing`は何かが失敗した、ということ以上の情報を伝えてくれないからだ。関数の中に失敗する恐れのある箇所が1つしかない場合や、関数がなぜ、どのように失敗したのかについて関心が無いのであれば、その関数にとって、`Maybe`はとても便利だ。たとえば、`Data.Map`のマップ内に探しているキーが存在しない場合のみ、検索が失敗するので何が起きたのかについて完全に把握する必要はない。しかし、ある関数がなぜ、どのように失敗したのかについて関心がある場合は、通常、結果の型として`Either a b`というのを使い、`a`には失敗の原因を伝えるための型を`b`には、成功した計算結果の型を格納する。従って、結果には`Right`を使うので、エラーは値コンストラクタ`Left`を使う。

たとえば、ある高校には生徒がコミケの戦利品をしまっておくためのロッカーがあるとしよう。そして、それぞれのロッカーには番号がついている。生徒が新しいロッカーが必要になったことを管理人に伝えると、生徒は新しいロッカーの番号を教えてもらう。しかし、誰かがそのロッカーを既に使っていた場合、管理人はそのロッカーが使用中であると生徒に伝えて、別の使われていないロッカーを選ぶ。ということで、これは、ロッカーの番号とそれが使われているかどうかのペアを持つマップとなる。

import qualified Data.Map as Map

data LockerState = Taken | Free deriving (Show, Eq)
type Code = String
type LockerMap = Map.Map Int (LockerState, Code)

分かりやすい。まず、ロッカーが使われているかを表現する新しいデータ型を作り、続いてロッカーの暗証番号を表現する型シノニムを作った。加えて、整数からロッカーの暗証番号と使用中かどうかを表すペアへとひも付けたマップの型シノニムも作った。では、ロッカーのマップから暗証番号を探す関数を作るとしよう。そこで、結果を表すのに`Either String Code`型を使用するが、コレはなぜかというと、この探索は失敗する場合が2通りあるからだ。ロッカーが使用中の場合は暗証番号を返すことはできないし、そもそもロッカーの番号が存在しないことだってある。そこで、探索が失敗した場合は、`String`を使って何が起きたのかを伝えるのだ

    lockerLookup :: Int -> LockerMap -> Either String Code
    lockerLookup lockerNumber map =
        case Map.lookup lockerNumber map of
            Nothing -> Left $ "Locker number " ++ show lockerNumber ++ " doesn't exist!"
            Just (state, code) -> if state /= Taken
                                    then Right code
                                    else Left $ "Locker " ++ show lockerNumber ++ " is already taken!"


まず、マップに対して通常の`lookup`を行う。その結果が`Nothing`であれば、ロッカーが存在しない、という文字列を`Left String`型の値として返す。もしロッカーが見つかれば、更にそのロッカーが使用中かどうかというのをチェックする。そして、ロッカーが使用中であれば、`Left String`として使用中である、という文字列を返す。また、ロッカーが使用中でなければ、`Right Code`という型の値として、ロッカーの番号に対応する暗証番号を生徒へと渡す。このとき、実際には結果が`Right String`となるが、事前に型宣言がドキュメントとなるように型シノニムを導入している。では、マップの例を見てみよう。

    lockers :: LockerMap
    lockers = Map.fromList
        [(100,(Taken,"ZD39I"))
        ,(101,(Free,"JAH3I"))
        ,(103,(Free,"IQSA9"))
        ,(105,(Free,"QOTSA"))
        ,(109,(Taken,"893JJ"))
        ,(110,(Taken,"99292"))

では、空いているロッカーを探してみよう。

    ghci> lockerLookup 101 lockers
    Right "JAH3I"
    ghci> lockerLookup 100 lockers
    Left "Locker 100 is already taken!"
    ghci> lockerLookup 102 lockers
    Left "Locker number 102 doesn't exist!"
    ghci> lockerLookup 110 lockers
    Left "Locker 110 is already taken!"
    ghci> lockerLookup 105 lockers
    Right "QOTSA"

もちろんロッカーを探した結果を`Maybe`で表現することもできるがなぜロッカーが見つからなかったのかという情報は得られない。しかし、上記のような型を使えば失敗の原因を伝えられる。



## Recursive data structures 再帰的データ構造

既に見てきたように、代数的データ型のコンストラクタは、(全くフィールドがないか)幾つかのフィールドを持ち、それぞれのフィールドは具体的な型である必要があった。ということで、ある型のコンストラクタのフィールドをその型と同じにすることができるのだ。そうすると、再帰的なデータ型を作ることができ、ある方の値は、その型の値と同じ型の値を保持することができ、ある値が保持している値も、その値と同じ型の値を保持する、などということができる。

`[5]`というリストについて考えてみよう。これは、`5:[]`のシンタックスシュガーだ。コロン`:`の右側には値があり、左側にはリストがある。この場合、リストは空のリスト`[]`だ。では、`[4,5]`というリストについてはどうだろう? そう、これも`4:5:[]`のシンタックスシュガーだ。最初のコロン`:`を見てみると、その左側には`4`という値があり、その右側には`5:[]`というリストがある。同じことが`[3,4,5,6]`にも当てはまり、(コロン`:`は右結合だから)このリストは`3:4:5:6:[]`とも書くことができる。

つまり、リストは空のリストになることができ、コロン`:`を使って要素と別のリスト(空のリストでもそうでなくても良い)を結合することができる、といえる。

では、独自のリストを実装するのに、代数的データ型を使ってみよう。

    data List a = Empty | Cons a (List a) deriving (Show, Read, Eq, Ord)

これは、前の段落の内容をそのままコードにしてリストを定義したものだ。このデータ宣言は、空のリストか、ある値とリストの組合せのどちらかであることを表現している。これが何をしているのかわからなければ、record syntaxを使えば理解しやすくなるかもしれない。

    data List a = Empty | Cons { listHead :: a, listTail :: List a} deriving (Show, Read, Eq, Ord)

`Cons`コンストラクタのせいで、また混乱させてしまったかもしれない。`Cons`は、コロン`:`の別名だ。ご覧のとおり、コロン`:`は、実際には値とリストを受け取り、新しいリストを返すコンストラクタだ。これで、新しい独自のリストが使えるようになった。言い換えれば、2つのフィールドを持ち、ひとつは`a`という型、もう一方は`[a]`という型である、と言える。

    ghci> Empty
    Empty
    ghci> 5 `Cons` Empty
    Cons 5 Empty
    ghci> 4 `Cons` (5 `Cons` Empty)
    Cons 4 (Cons 5 Empty)
    ghci> 3 `Cons` (4 `Cons` (5 `Cons` Empty))
    Cons 3 (Cons 4 (Cons 5 Empty))

`Cons`コンストラクタをinfixにして呼び出すことができる。つまり、コロン`:`と同じようになる。`Empty`が空のリスト`[]`であり、`4 \`Cons\` (5 \`Cons\` Empty`が、`4:5:[]`に相当する。

特殊な文字を加える事で、自動的にその関数をinfixな関数として定義できる。また、同じことをコンストラクタに対しても行うことができる。では、そのデータ型を返す関数を定義してみよう。以下のとおりだ。

    infixr 5 :-:
    data List a = Empty | a :-: (List a) deriving (Show, Read, Eq, Ord)

まず最初に新しいシンタックスについて気づいたと思う。infixr宣言だ。ある関数を演算子として定義するとき、そこに`fixity`を加える(が、それだけでほかは何もしない。)`fixity`というのは、演算子がどれほど右結合、あるいは左結合に強く束縛されるかというのを示す。たとえば、乗算の関数`*`は`infixl 7 *`という強度、加算の関数`+`の強度は`infixl 6 +`となっている。これは、どちらも右結合であることを意味し、`(4 * 3 * 2)`は、`((4 * 3) * 2)`と等しいが、`fixity`の値が大きいため乗算`*`は、加算`+`より強力に束縛されるので、`5 * 4 + 3`は、`(5 * 4) + 3`となる。

そうしなければ、`Cons a (List a)`と書く代わりに`a :-: (List a)`と書く必要がアアル。ということで、上記のリストの型を使って、以下のようにリストを書き表すことができる。

    ghci> 3 :-: 4 :-: 5 :-: Empty
    (:-:) 3 ((:-:) 4 ((:-:) 5 Empty))
    ghci> let a = 3 :-: 4 :-: 5 :-: Empty
    ghci> 100 :-: a
    (:-:) 100 ((:-:) 3 ((:-:) 4 ((:-:) 5 Empty)))

上記の型のように`Show`を継承したとき、演算子をカッコで囲むと`4 + 3`は`(+) 4 3`となるから、Haskellは、コンストラクタがprefix関数であるかのように表示する。

では、我々のリストを結合する関数を作ってみよう。以下に、普通のコロン`:`がどのように定義されているか示す。

    infixr 5  ++
    (++) :: [a] -> [a] -> [a]
    []     ++ ys = ys
    (x:xs) ++ ys = x : (xs ++ ys)

では、上記の定義を拝借するとしよう。そして、関数の名前は`.++`とする。

    infixr 5  .++
    (.++) :: List a -> List a -> List a
    Empty .++ ys = ys
    (x :-: xs) .++ ys = x :-: (xs .++ ys)

動いているか確認数r。

    ghci> let a = 3 :-: 4 :-: 5 :-: Empty
    ghci> let b = 6 :-: 7 :-: Empty
    ghci> a .++ b
    (:-:) 3 ((:-:) 4 ((:-:) 5 ((:-:) 6 ((:-:) 7 Empty))))

よしよし、良い感じだ。もし、そうしたければ、リストに対するすべての演算子は我々のリストに対しても実装することができる。

`(x :-: xs)`に対してどのようにパターンマッチングが機能するか注目してほしい。これが機能するのはパターンマッチングが実際にはコンストラクタに対して行われているからだ。`:-:`は我々のリスト型のコンストラクタだからパターンマッチングができる。同様に、`:`は最初から組み込まれたリスト型のコンストラクタだから、これに対してもパターンマッチングができる。また、同じことが空のリスト`[]`にも当てはまる。なぜかと言えば、パターンマッチングはコンストラクタ(のみ)に対して機能するからだ。そのようなコンストラクタや、普通の`Just 123`のようなコンストラクタ、あるいは`'a'`や`1.23`などのコンストラクタに対してもパターンマッチングは機能するが、後者は実際には文字`Char`や数値のコンストラクタとなっている。

さて、ここで二分探索木を実装するとしよう。もし、あなたがC言語などのユーザーかつ二分探索木についてよく知らないのであれば、以下の様なものだ、と考えよう。ある要素は、2つの要素を指し示し、1つは左側の要素、もう1つは右側の要素となる。また、それに対して左側の要素は小さく、右側の要素は大きい。加えて、左右の要素は(要素を持たないか、1つ、あるいは)2つの要素を指し示すことができる。結果として、ある要素は2つまで部分木をもつことができる。二分探索木の興味深い点は、すべての要素についての関係を知ることができる、という点であり、たとえば`5`という要素の左側にある部分木が持っている左側の要素はすべて`5`より小さくなる。また、右側の部分木が持っている右側の要素もすべて`5`より大きくなる。つまり、たとえば`8`という要素を探したい時、`5`より小さいから`5`という要素の右側へと進む。すると`7`に行き着くが、これも`8`より小さいから右側へと進む。これで、目的の要素へと3段階で辿りつけた。もし、これが普通のリスト(あるいは上記のルールに従っていない普通の木構造)であれば、3段階で探索できるところが、`8`という要素を見つけるのに7段階も必要になってしまう。

> メモ: 図の色が原因でよく見えなかった。おそらく
>
>        5
>       x 7
>    x x x 8
>
> という構造のツリーになっているはず。コレをそのままリストにすると`[5, x, 7, x, x, x, 8]`となるので、たしかに8が見つかるまで7ホップ必要。

`Data.Map`のマップや`Data.Set`の集合は、木構造を用いて実装されているが、普通の二分木の代わりに、常に2つの要素を持つ平衡二分木を使用している。しかし、ここでは普通の二分探索木を実装することにする。

以下のように実装するとしよう。あるツリーは、何も持たないか、あるいは、ある値の要素と、それに対応する2つのツリーを保持する。これは完璧な代数的データ型のように聞こえる。

    data Tree a = EmptyTree | Node a (Tree a) (Tree a) deriving (Show, Read, Eq)

いいね、良さそうだ。では、手動でツリーを構築する代わりに、ツリーと要素を受け取って、要素をツリーへと挿入する関数を作るとしよう。これを実現するには、ツリーのルートとなるノードと挿入したい要素の値を比較して、値が小さければ左側へ、大きければ右側へ進んでいく。これを空のツリーに到達するまでノードのノードへと順々に続ける。そして、空のツリーに到達した時点で、空のツリーの代わりに要素を挿入する。

たとえば、Cのような言語の場合は、ツリーに含まれる要素のポインタを変更することで、これを実現することになるだろう。しかし、Haskellでは、実際にはツリーを変更することはできないので、挿入用の関数が返す結果の新しいツリーに加えて、挿入用の関数が内部でツリーの左へ、あるいは右へ進む、と決めた瞬間にその都度内部では新しいツリーが生成されることになる。Haskellにはポインタの概念は存在せず、値のみが存在するからだ。従って、我々のツリーへ要素を挿入するための関数の型は、`a -> Tree a - > Tree a`のようになるだろう。要素とツリーを受け取って、その要素と同じ型を持つ新しいツリーを返すのだ。これは非効率的に思えるかもしれないが、HaskellのLazinessがその点の問題を解決してくれる。

そこで、2つの関数を用意する。ひとつはシングルトンツリー(要素を1つしか持たないツリー)を作るためのユーティリティ関数であり、もうひとつは、実際にツリーへ要素を挿入するための関数だ。

    singleton :: a -> Tree a
    singleton x = Node x EmptyTree EmptyTree
    
    treeInsert :: (Ord a) => a -> Tree a -> Tree a
    treeInsert x EmptyTree = singleton x
    treeInsert x (Node a left right)
        | x == a = Node x left right
        | x < a  = Node a (treeInsert x left) right
        | x > a  = Node a left (treeInsert x right)

`singleton`関数は、要素と空のツリー2つを含むツリーを作るための単なるショートカットだ。挿入用の関数では、まず境界条件となるパターンを定義する。空の部分木に到達したら、それは目的のツリーに到達したことを意味するから、その部分を空のツリーの代わりに挿入したいシングルトンツリーへと置き換える。また、空のツリーではないツリーへ要素を挿入する場合は、いくつか検査をする必要がある。まず、ツリーのルート要素と挿入したい要素が等しい場合、挿入前と同じツリーを返す。もし、要素のほうが小さければ、挿入対象のルート要素とツリーの右側の部分木はそのままに、左側の部分木に目的の要素が挿入された状態のツリーを返す。同じことを(同じ方法ではないが)、挿入したい要素が大きい場合に右側の部分木に対しても行う。

次は、ある要素がツリー内に存在するか探索する関数を作るとしよう。まずは、境界条件から定義する。もし空のツリーに対してある要素が存在するか検査した場合は、確実に要素は見つからない。いいね。ところで、これはリストに対して要素を探す場合と同じ境界条件となっていることに気づいただろうか。空のリストに対して要素を探したとしても、必ず見つからない。おっと、話を戻そう。要素を探す対象が空のツリーではない場合、いくつか検査を行う必要がある。もし、ルート要素が探している要素と一致すれば、それが答えだ。そうでなければ、さて、どうしよう? ここで、ツリー内の左側の要素は必ずルート要素より小さい、というルールの恩恵が得られる。探している要素がルート要素より小さければ、左側の部分木の要素と比較する。同様に、ルート要素より大きければ、右側のツリー内の要素に目的の要素があるかを調べる。

    treeElem :: (Ord a) => a -> Tree a -> Bool
    treeElem x EmptyTree = False
    treeElem x (Node a left right)
        | x == a = True
        | x < a  = treeElem x left
        | x > a  = treeElem x right

前の段落の内容をそのままコードとして書くだけで良かった。では、我々が作ったツリーのおもしろさを確認してみよう。(もちろんそうしても良いが)手動でツリーを構築する代わりに、`foldr`を使ってリストからツリーを生成してみよう。リストの中味を1つ1つ取り出して、最終的にある種の値をえる方法としてはfoldが使えることを思い出してほしい。まず空のツリーから開始して、リストから要素を取り出すたびに、それをツリーへと挿入して、その挿入済みのツリーをaccumulatorとして次のステップで使用するのだ。

    ghci> let nums = [8,6,4,1,7,3,5]
    ghci> let numsTree = foldr treeInsert EmptyTree nums
    ghci> numsTree
    Node 5 (Node 3 (Node 1 EmptyTree EmptyTree) (Node 4 EmptyTree EmptyTree)) (Node 7 (Node 6 EmptyTree EmptyTree) (Node 8 EmptyTree EmptyTree))

上記の`foldr`では、`treeInsert`が、(要素とツリーを受け取って、ツリーを生成する)畳み込み用の関数であり、`EmptyTree`がaccumulatorの初期値であり、`nums`はもちろん、ツリーへと変換させたいリストとなっている。

コンソールへ生成されたツリーを表示させてみると、とても読みやすいとは言えない。しかし、ツリーの構造がどうなっているのか、というのは把握できる。たとえば、ルート要素は`5`であり、また、部分木を2つ持ち、一方はルート要素が`3`のツリー、もう一方はルート要素が`7`のツリーである、などというのが読み取れる。

    ghci> 8 `treeElem` numsTree
    True
    ghci> 100 `treeElem` numsTree
    False
    ghci> 1 `treeElem` numsTree
    True
    ghci> 10 `treeElem` numsTree
    False

ツリーに要素が含まれるかを調べる関数も機能している。素晴らしいね。

ご覧のとおり、代数的データ構造は、Haskellにおける強力な機能だ。これを使えば、真偽値から曜日を表す列挙型、そして二分探索木までなんでも作ることができるのだ。



## Typeclasses 102 - 102匹型クラスちゃん

ここまで、Haskellの標準的な型クラスについて、また、それに含まれる型について学んできた。そして　、Haskellに依頼することで、標準の型クラスを自分で定義した型にたいして自動的に継承させる方法も学んだ。この節では、手動で独自の型クラスを定義してから、ある型をその型クラスのインスタンスにする方法を学ぶことにしよう。

では、軽く型クラスについておさらいしよう。型クラスはインターフェースのようなものだ。型クラスは、(等しさを比較したり、順番を比較したり、列挙できるようにするなどの)振る舞いを定義し、それに従う振る舞いをする型は、その型クラスのインスタンスとなる。型クラスの振る舞いは、ある関数を定義したり、型宣言を実装したりすることで達成される。つまり、ある型がある肩クラスのインスタンスである、といった場合、それは型クラスが定義する関数をその肩に対して使えることを意味する。

JavaやPythonなどのクラスとは異なり、Haskellの型クラスは実際のところ何もしない。これが多くの人を混乱させる。ここからは、命令的言語のクラスについて知っていることの全てを完全に忘れてほしい。

たとえば、`Eq`という型クラスは、等しさを比較するための型クラスだ。また、`Eq`は`==`と`/=`という関数を定義する。車を表す型があり、2つの車に対して等しさを調べる関数`==`で比較するのは理にかなっている。そして、車という型が`Eq`という型クラスのインスタンスとなるのも理にかなっている。

以下に、`Eq`という型クラスが標準モジュールの`Prelude`でどのように定義されているかを示す。

    class Eq a where
        (==) :: a -> a -> Bool
        (/=) :: a -> a -> Bool
        x == y = not (x /= y)
        x /= y = not (x == y)

おっと、幾つか見慣れない奇妙な文やキーワードが登場した。が、大丈夫だ。すぐにこれらの意味は明らかになる。まず、最初に`class Eq a where`というのを書く。これは、新しく`Eq`という名前の型クラスを定義する、という意味だ。`a`は型変数であり、これが`Eq`という型クラスのインスタンスである型がどんな役割をするのかを示す。また、`a`の部分を`a`のように1文字で書く必要はないが、この部分は小文字で書く必要がある。続いて、幾つかの関数を定義する。ここで関数の本体を実装するのは必須ではないが、関数の型宣言だけは、必ず指定し無くてはならない。

ちなみに、等しさを表現する`Eq`というクラスを書いた後に`(==) :: equatable -> equatable -> Bool`という型宣言をするほうが良いと考える人もいるだろう。それでも問題ない。

おっと、話を戻そう。ところで、`Eq`が定義する関数について、我々はその関数の本体を実装したが、関数は、それぞれ相互に再起している。2つの型クラス`Eq`のインスタンスに対して、それらが等しくなければ、それらは異なり、それらが異ならなければ、それらは等しいということを言っている　。実際、こんなことをする必要はないが、後にこれが我々を助けてくれることに気づくだろう。

もし、`class Eq a where`と書いた後に、そのクラスの方宣言の中で、`(==) :: a -> -a -> Bool`のように定義したとして、その後に関数の型を調べたとしたら、以下の様な型`(Eq a) => a -> a -> Bool`を持つことになるだろう。

さて、クラスを得たのは良いが、これで何ができるんだろう? そうだね、実は何もできない。しかし、その型クラスのインスタンスを作り始めた瞬間から、いくつかの便利な機能を享受できるようになる。では、以下の型を見てみよう。

    data TrafficLight = Red | Yellow | Green

上記は、信号の状態を定義している。ここで、インスタンスとして型を一切継承していないことに注目してほしい。`Eq`や`Show`などの型クラスを継承しようと思えばできるのにもかかわらず、そうしないのはインスタンスをこれから主導で書き表すからだ。以下に、それらを`Eq`のインスタンスとする方法を示す。

    instance Eq TrafficLight where
        Red == Red = True
        Green == Green = True
        Yellow == Yellow = True
        _ == _ = False

手動で行うには、`instance`キーワードを使う。つまり、`class`は、新しく型クラスを定義するために`instance`は、その型クラスのインスタンスとなる型を定義するために使用する。

以前、型クラス`Eq`を定義したとき、`class Eq a where`のように書いて、`a`が、その型クラスのインスタンスである型を代表して、どんな型としても振る舞う、ということを言った。ここで、その背景が明らかになった。インスタンスを作るときに`instance Eq TrafficLight where`のように書くからだ。

型宣言の中で、`==`は、`/=`を反対にしたものとして定義されているから、インスタンス宣言の中で、それらのどちらか一方を上書きすれば良い。これが、最小の実装し無くてはならない関数であり、これが、最小で完全な型クラスの定義となる。つまり、我々の型は、肩クラス`Eq`のインスタンスとして振る舞うことができるのだ。上記のように、`Eq`を依り単純に定義する場合は、型クラス`Eq`の最小限の定義を完全に満たすためには、`==`または`/=`のどちらかを上書きすればよい。しかし、以下の場合、

    class Eq a where
        (==) :: a -> a -> Bool
        (/=) :: a -> a -> Bool

Haskellは、これら2つの関数がどのように関係しているのかを知らないので、この型とこの型のインスタンスを作るときは、それぞれの関数を両方とも実装する必要がある。ということで、最小かつ完全な定義は、`==`と`/=`ということになる。

さて、パターンマッチングにより、`==`を単純に実装できる、というのがわかったと思う。複数のケースが考えられるので、2つの信号が等しくない場合ではなく、さきに2つの信号が等しい場合を定義してから、前のケースに一致しなかったものすべてをパターンマッチングにより捉えることで、2つの信号が異なる場合を定義することができるのだ。

では、`Show`のインスタンスを主導で作ってみよう。`Show`の最小で完全な定義を満たすために、`show`という値を受け取り、それを文字列へと変換する関数のみを定義する必要がある。

    instance Show TrafficLight where
        show Red = "Red light"
        show Yellow = "Yellow light"
        show Green = "Green light"

目的を達成するためにはパターンマッチングを使うのだった。では、これがどのように機能するか見てみよう。

    ghci> Red == Red
    True
    ghci> Red == Yellow
    False
    ghci> Red `elem` [Red, Yellow, Green]
    True
    ghci> [Red, Yellow, Green]
    [Red light,Yellow light,Green light]

いいね。(手動は面倒なので、実際には`deriving`を使うことになるが)これで、`deriving`で`Eq`を継承した場合と同じ効果を得ることができた。しかし、`Show`の継承については、直接値コンストラクタを値へと変換することになる。そのため、たとえば、信号の例のように`Red`を`Red Light`のように表示させたければ、手動でインスタンス宣言をする必要がある。

また、他の型クラスのサブクラスの型クラスを定義することもできる。型クラス`Num`の宣言はやや長くなるが、最初の部分は以下のようになる。

    class (Eq a) => Num a where

以前にも触れたとおり、クラスの制約を詰め込める箇所は、たくさんある。つまり、`class Num a where`のように書くこともでき、`a`という型は、`Eq`のインスタンスでなければならない、というのを表明できる。`Num`のインスタンスを作る前に`Eq`のインスタンスを作らなければならない、という本質的なところに変わりはない。ある型が数値として扱えるかを考慮する前に、どの型の値が等しさを判定できるのか否かを決定するというのは、理にかなっている。サブクラスについて言えることは以上だ。これは、単なるクラス宣言におけるクラスの制約だ。クラス宣言の中で関数の本体を定義するときやインスタンス宣言を定義するときに、`a`という型は、`Eq`に属している前提となるから、その型の値に対して`==`を使うことができる。

しかし、`Maybe`やリスト型を型クラスのインスタンスにするには、どうするんだろう? `Maybe`と`TrafficLight`の違いはなにかといえば、`TrafficLight`は`Maybe`を内包しており、それ自体は具体的な方ではない、という点だ。(`Char`などの型を受け取って)具体的な型(`Maybe Char`などの型)を生成したりする、1つの型パラメータを受け取る型コンストラクタに過ぎないのだ。ここで、もう一度`型クラス`Eq`を確認してみよう。

    class Eq a where
        (==) :: a -> a -> Bool
        (/=) :: a -> a -> Bool
        x == y = not (x /= y)
        x /= y = not (x == y)

関数の中では、すべての型が具体的な型である必要があるから、上記の型宣言における`a`は、具体的な型として扱われる、ということを学んだ。(たとえば、関数の型を`a -> Maybe`とすることはできないが`a -> Maybe a`や、`Maybe Int -> Maybe String`などと定義することはできる、というのを思い出してほしい。)そのため、以下の様なことはできない。

    instance Eq Maybe where

なぜかと言えば今まで見てきたとおり、`a`は具体的な型でなければならないのに、`Maybe`は具体的な型ではないからだ。`Maybe`は、型パラメータを1つ受け取って具体的な型を生成する型コンストラクタだ。しかし、たとえば型クラスを作るたびに`instance Eq (Maybe Int) whereや、`instance Eq (Maybe Char) where`などというのを一々書くのは退屈極まりないだろう。ということで、これは以下のように記述することができる。

    instance Eq (Maybe m) where
        Just x == Just y = x == y
        Nothing == Nothing = True
        _ == _ = False

これは、すべての`Maybe 何か`という具体的な型を型クラス`Eq`のインスタンスにする、という意味になる。ということで、本当に`(Maybe something)`と記述することもできるが、Haskellの監修に習って、1文字を選択するのが普通だ。`(Maybe m)`が`a`に相当し、`class Eq a where`という役割を果たす。`Maybe`は具体的な型ではないから、`Maybe m`とするのだ。型パラメータを(小文字で)指定することにより、`m`はすべての型を意味し、`Maybe m`という具体的な型をすべて型クラス`Eq`のインスタンスにしたい、ということが伝えられる。

ただし、この方法には1つ問題がある。何が問題か、発見できたかな? そう、`Maybe`の中味に対して`==`を使っているが、`Maybe`の中味を`Eq`のそれに対して使える、という保証はできないのだ。　そこで、上記のインスタンス宣言を以下のように変更する必要がある。

    instance (Eq m) => Eq (Maybe m) where
        Just x == Just y = x == y
        Nothing == Nothing = True
        _ == _ = False

そう、クラス制や区を追加する必要があったのだ。この宣言は、次のようなことを言っている。すべてのMaybe型を、`Maybe m`という形で、型クラス`Eq`のインスタンスにする。ただし、`Maybe`の中味の型として保持するのは、型クラス`Eq`に属する型のみとする。これは、実際にはHaskellが型クラスを`deriving`したときに行っていることだ。

多くの場面で、クラス制約やクラス宣言は、ある肩クラスを別の型クラスのサブクラスにするときに使用し、インスタンス宣言におけるクラス制約はある型の中味を要求していることを表明するために使用される。たとえば、上記のように、`Maybe m`が`Eq`に属するとともに、その中身の`m`も`Eq`に属する、というのを指定することができる。

インスタンスを作るとき、たとえば、`a`が`a -> a -> Bool`のように、型宣言の中で型が具体的な型として使われているのを見つけたらカッコを追加して、型パラメータを指定する必要がある。そうして、最終的に具体的な型にするのだ。

クラス宣言では、ある型をインスタンスにしようとしている箇所は、パラメータとして置き換えられないかを検討してほしい。たとえば、`class Eq a where`の`a`というのは、インスタンスにしようとしている具体的な型で置き換えられるから、その型は関数の型宣言に移動できないかを考慮に入れてほしい。それから、`(==) :: Maybe -> Maybe -> Bool`というのは機能しないが、`(==) :: (Eq m) => Maybe m -> Maybe m -> Bool`というのは機能する。しかし、これについてはいくつか考慮すべきことがありなぜかといえば、`==`は常に`(==) :: (Eq a) => a -> a -> Bool`という型になるから、作ろうとしているインスタンスは問題にはならない。

おっと、最後にもう一つ、確認することがある。もし、型クラスのインスタンスとして何があるのかを確認したければ、ghciに`:info 型クラス名`と入力する。たとえば、`:info Num`とん有力すれば、その型クラスが定義している関数と、その型クラスに属している型のリストが表示される。また、`:info`は、型や型コンストラクタに対しても機能する。たとえば、`:info Maybe`と入力すると、Maybeがどの型クラスのインスタンスなのか、という型クラスのリストが表示される。加えて、`:info`は関数の型宣言についても表示してくれる。いやぁ、便利だね。



## A yes-no typeclass - ゆるふわ型クラス

JavaScriptなどの弱い肩づけがされた言語ではif文にほぼなんでも置くことができる。たとえば、以下はすべて可能だ。

    if (0) alert("YEAH!") else alert("NO!")
    if ("") alert ("YEAH!") else alert("NO!")
    if (false) alert("YEAH") else alert("NO!)

そして、これらはすべて`"NO!"`というアラートを表示する。JavaScriptは空の文字列`""`を真らしい値として扱うからだ。

    if ("WHAT") alert ("YEAH") else alert("NO!")

ということで、上記は`"YEAH!"`とアラートが表示される。

もちろん、Haskellでは真偽値として厳密には`Bool`を使うほうが良いが、ここではJavaScriptっぽい振る舞いを実装してみよう。まずはクラス宣言からはじめる。

    class YesNo a where
        yesno :: a -> Bool

単純だ。型クラス`YesNo`は、ひとつの関数を定義する。この関数は、真らしいものとかんがえられる型の値を受け取り、それが`True`か否かを確認して表示してくれる。ところで、関数の中で`a`というのを使っているが、`a`は具体的な型となるので気をつけよう。

次は、いくつかインスタンスを定義しよう。数値については、JavaScriptっぽく、0ではない数値はすべて真らしいものとみなし、0については、偽らしいものとみなす。

    instance YesNo Int where
        yesno 0 = False
        yesno _ = True

空のリスト(に加えて文字列)は、noっぽい値、空ではないリストはyesっぽい値とする。

    instance YesNo [a] where
        yesno [] = False
        yesno _ = True

リストの中味の型については何の仮定もしていないにもかかわらず、リストを具体的な型にするため、そこへ型パラメータを置いていることに注目してほしい。他には、。`Bool`自身は、真らしいものと偽らしいものを保持しており、どちらがどちらなのか明確だ。

    instance YesNo Bool where
        yesno = id

はァ? `id`って何だ?`id`はHaskellの標準ライブラリに含まれる関数であり、受け取ったパラメータと全く同じものを返す。つまり、今まで書いていたものとおなじになる。

では、`Maybe a`をインスタンスにしてみよう。

    instance YesNo (Maybe a) where
        yesno (Just _) = True
        yesno Nothing = False

Maybeの中味については特に仮定していないので、クラス制約を設ける必要はない`Just`という値は真らしいもの、`Nothing`という値は偽らしいものとするだけでよい。また、ここでも`(Maybe a)`の代わりに`Maybe`と記述することはできない。(`Maybe`は具体的な型ではないので)ご想像の通り、`Maybe a -> Bool`というのは全く問題ないが、`Maybe -> Bool`という関数は存在できないからだ。しかし、これは素晴らしい。`Maybe something`の`something`の部分がどんな型であるかは、問題にはならないからだ。

ところで、以前、二分探索木を表現するために、ツリーの肩`Tree a`というのを定義した。空のツリーについては偽らしいもの、それ以外のツリーについては真らしいものと言えそうだ。

    instance YesNo (Tree a) where
        yesno EmptyTree = False
        yesno _ = True

では、信号を表す肩もyesかnoを表す値になれるだろうか? もちろんだ。赤は止まれ、青は進め、黄色は...私は生き急いでいるから進む。

    instance YesNo TrafficLight where
        yesno Red = False
        yesno _ = True

いいね。では、いくつかインスタンスが揃ったので、これらを試してみよう。

    ghci> yesno $ length []
    False
    ghci> yesno "haha"
    True
    ghci> yesno ""
    False
    ghci> yesno $ Just 0
    True
    ghci> yesno True
    True
    ghci> yesno EmptyTree
    False
    ghci> yesno []
    False
    ghci> yesno [0,0,0]
    True
    ghci> :t yesno
    yesno :: (YesNo a) => a -> Bool

よしよし、良い感じに動いている。では、if文を真似る関数を定義してみよう。

    yesnoIf :: (YesNo y) => y -> a -> a -> a
    yesnoIf yesnoVal yesResult noResult = if yesno yesnoVal then yesResult else noResult

かなり直感的だ。この関数は、yes-noな値と、2つの値を受け取る。yes-noな値がyesっぽければ、2つの値の中から最初の方を返す。それ以外の場合は、2番目の値を返す。

    ghci> yesnoIf [] "YEAH!" "NO!"
    "NO!"
    ghci> yesnoIf [2,3,4] "YEAH!" "NO!"
    "YEAH!"
    ghci> yesnoIf True "YEAH!" "NO!"
    "YEAH!"
    ghci> yesnoIf (Just 500) "YEAH!" "NO!"
    "YEAH!"
    ghci> yesnoIf Nothing "YEAH!" "NO!"
    "NO!"



## The Functor typeclass - ファンクタ型クラス

ここまでで、多くの標準ライブラリにある肩クラスと遭遇してきた。たとえば、`Ord`は、何か順番を持つものを表す。`Eq`も習った。これは、何か等しさが比較できるものを表す。`Show`は、ある肩の値を文字列で表現するためのインターフェースを提供する。`Read`は文字列からある型の値へと変換してくれる、我々の友達だ。では、ここからはあるものがマッピングされることができることを表す型クラス`Functor`について見ていくことにしよう。マッピング、と聞いてリストを思い浮かべたかもしれないが、リストはHaskellにおいて重要なイディオムだ。実際その通りで、リストはファンクタに属している。

型クラス`Functor`を知って、どのように実装されているかを理解する良い方法は何だろう? ちょっと除いてみることだ。

    class Functor f where
        fmap :: (a -> b) -> f a -> f b

これだけだ。`fmap`という関数が定義されているが、その関数のデフォルトの実装は含まれていない。`fmap`の型は興味深い。ここまでの型クラスにおける定義では、　`(==) :: (Eq a) => a -> a -> Bool`における`a`のように、　型変数は、型クラスにおける具体的な型となる役割を担っていた。しかし、`f`は(`Int`や`Bool`、`Maybe String`などの値を持つことができる)具体的な型ではなく、1つのパラメータを受け取る型コンストラクタとなっている。　何度もしつこいようで恐縮だが、`Maybe Int`などは具体的な型であり、`Maybe`は、パラメータとして1つの型を受け取る型コンストラクタだ。話を戻そう。`fmap`は、ある型から別のある型にマップする関数を受け取り、ファンクタがある型を適用し、ファンクタが別のある型を適用したものを返す。

なんだか紛らわしく聞こえるかもしれないが、心配しないで欲しい。いくつか例を確認してから、また見直すことに仕様。うーむ、しかし、この`fmap`の肩宣言はなにかひっかかる。`map`の肩シグネチャは`map :: (a -> b) -> [a] -> [b]`となっている。

ああ、なるほど。`map`は、ある型から別の型にする関数と、ある型のリストを受け取り、別の型のリストを返している。これはまさしく私達の友達であるファンクタではないか。事実、`map`というのはリストにたいする`fmap`といえる。以下に、リストが型クラス`Functor`のインスタンスであることを示す。

    instance Functor [] where
        fmap = map

以上だ。ここで、`instance Functor [a] where`のように記述できないことに注目してほしい。なぜなら、`fmap :: (a -> b) -> f a -> f b`と、定義されており、`f`は1つの型を受け取るコンストラクタとなっているからだ。`[a]`は既に(中味にどんな型でも保持できる)具体的な型となっているが、`[]`は1つの型を受け取って`[Int]`や`[String]`、あるいは`[[String]]`さえも生成する型コンストラクタとなっている。

リストに対する`fmap`は`map`と同じだから、リストに対してそれを使っても同じ結果が得られる。

    map :: (a -> b) -> [a] -> [b]
    ghci> fmap (*2) [1..3]
    [2,4,6]
    ghci> map (*2) [1..3]
    [2,4,6]

では、空のリストにたいして`map`か`fmap`すると、何が起きるだろう?そうだね、空のリストが帰ってくるだけだ。 [a]`という型の空のリストを`[b]`という型の空のリストに変えるだけだ。

ある種の箱とみなせる型は、ファンクタとして振る舞う。リストは仕切りが無限に入れられる箱のようなものと考えることができる。その箱は、空でもいいし、仕切りの1つはいっぱいになっているが、ほかは空でもいいし、すべてがいっぱいになっていても良い。では、他に箱のようなものとみなせるものは何があるだろう? その一つが`Maybe`だ。`Maybe`は、何もない、というのを持つことができる箱とみなせて、その場合保持する、値は`Nothing` となり、あるいは1つのアイテム、たとえば値が`Just "HAHA"`となる`"HAHA"`というものを保持することができる。では、`Maybe`がファンクタであることを確認してみよう。

    instance Functor Maybe where
        fmap f (Just x) = Just (f x)
        fmap f Nothing = Nothing

もう一度、`instance Functor Maybe where`ではなく`Maybe`や`YesNo`を扱ったときと同様に`instance Functor (Maybe m) where`となっていることに注目してほしい。ファンクタは、具体的な型ではなく、パラメータを1つ受け取る型コンストラクタを求める。もし、`f`をすべて`Maybe`に置き換えたくなったら、`fmap`は、この型に対して　`(a -> b) -> Maybe a -> Maybe b`のように振る舞う。これは良さそうだ。しかし、`f`を`(Maybe m)`で置き換えた場合、これは`(a -> b) -> Maybe m a -> Maybe m b`のように振る舞うと見なされ、意味を成さなくなってしまう。なぜなら、`Maybe`は1つの型パラメータしか受け取らないからだ。

ところで、`fmap`の実装は至ってシンプルうだ。`Nothing`という空の値であれば、単に`Nothing`を返す。空のリストに対してマッピングすれば空のリストが得られるように、空の箱に対してマッピングをすれば、空の箱が得られる、というのは理にかなっている。もし、空の値でなければ、と言うより、`Just`に単一の値が詰め込まれていたら、`Just`の中味の値に対して関数を適用する。

    ghci> fmap (++ " HEY GUYS IM INSIDE THE JUST") (Just "Something serious.")
    Just "Something serious. HEY GUYS IM INSIDE THE JUST"
    ghci> fmap (++ " HEY GUYS IM INSIDE THE JUST") Nothing
    Nothing
    ghci> fmap (*2) (Just 200)
    Just 400
    ghci> fmap (*2) Nothing
    Nothing

他に`Functor`のインスタンスとなり、マッピングできるものと言えば、`Tree a`という型がある。(値がないか、いくつかの値を保持するので)これはある種の箱とみなすことができ、たしかに`Tree`という型のコンストラクタは1つの型パラメータを受け取る。もし、`fmap`が`Tree`に対してのみ機能する関数だとしたら、`fmap`の肩シグネチャは`(a -> b) -> Tree a -> Tree b`のようになるだろう。これについては、再帰を使うことになる。空のツリーに対するマッピングは、空のツリーを生成する。空ではないツリーに対してマッピングすると、ルートの値と左右のサブツリーに関数を適用した値を保持するツリーになり、その左右のサブツリーもマッピングされたツリーになる。

    instance Functor Tree where
        fmap f EmptyTree = EmptyTree
        fmap f (Node x leftsub rightsub) = Node (f x) (fmap f leftsub) (fmap f rightsub)

    ghci> fmap (*2) EmptyTree
    EmptyTree
    ghci> fmap (*4) (foldr treeInsert EmptyTree [5,7,3,2,1,7])
    Node 28 (Node 4 EmptyTree (Node 8 EmptyTree (Node 12 EmptyTree (Node 20 EmptyTree EmptyTree)))) EmptyTree

いいね。では、`Either a b`はどうだろう? これはファンクタになれるのか? 型クラス`Functor`は、1つの型パラメータを受け取る肩コンストラクタを要求するが、`Either`は2つ受け取る。いや、1つにする方法は知っているぞ。そう、`Either`へ部分的にパラメータを与えれば1つが空く。以下に、標準ライブラリでは`Either`がファンクタであることを示す。

    instance Functor (Either a) where
        fmap f (Right x) = Right (f x)
        fmap f (Left x) = Left x

ちょっと待った。
これは何をしているんだ? `Either`ではなく`Either a`をインスタンスにしている。これは、`Either`は2つ受け取れるが、`Either a`はパラメータを1つ受け取る型コンストラクタとなっているからだ。もし、`fmap`が`Either a`に限定していたら、その方シグネチャは、`(b -> c) -> Either a b -> Either a c`となるだろう。なぜかと言えば、`(b -> c) -> (Either a) b -> (Either a) c`と同じだからだ。しかし、実装では、値コンストラクタ`Right`に対してマッピングしているが、`Left`にはしていない。なぜかって? では、`Either a b`がどのように定義されているか確認してみよう。以下のとおりだ。

    data Either a b = Left a | Right b

もし、`a`と`b`の両方に関数をマッピングしたければ、それらを同じ型にする必要がある。たとえば、文字列から文字列へマッピングを行う関数があっても、`a`が数値で`b`が文字列の場合は機能しない、ということだ。また、`fmap`の型が`Either`の値のみに対して機能する場合、2番目のパラメータの型は変更できても1番目の型は同じ型を保つ必要があり、最初のパラメータは値コンストラクタ`Left`により具体的な型にされている必要がある。

これは、我々の箱に例える方法と合致していて、`Left`の部分をある種の空の箱とみなし、`Right`にはなぜ空の箱になるのか、というエラーメッセージを持たせる。

`Data.Map`の`Map`も、値があるかないか、というのを保持できるのでファンクタになる。`Map k v`の場合、`fmap`は`v -> v'`という関数を`Map k v`という型にマッピングして、`Map k v'`という型のマップを生成する。

以前も説明したが、型や値の命名について、`'`は特別な意味を持たないので注意してほしい。`'`は、ちょっとした変更を加えたときに名前の後ろにつける。

`Map k`がファンクタのインスタンスであることを、確認するのは宿題にしよう。

さて、　型クラス`Functor`を使うことで、型クラスが高階関数のような概念を表すことを学んだ。それから、型を部分適用することで、インスタンスにする実用的な方法も学んだ。後の章では、ファンクタに適用されるいくつかの法則について学ぶとしよう。

それから、もう一つ、ファンクタはいくつかの規則に従わなくてはいけないので、いくつかのプロパティを持つが、それらについて我々は特になにも考えなくて良い。たとえば、`fmap (+1)`をリスト`[1,2,3,4]`にマッピングすると、その結果は`[2,3,4,5]`になることを期待しても、`[5,4,3,2]`になることは期待しないだろう。もし、`fmap (\a -> a)`という(与えられたパラメータをそのまま返すだけの)関数をリストにマッピングしたら、結果は元と同じリストになることを期待するだろう。たとえば、`fmap`をツリーの左側のサブツリーはノードの値より小さく、右側のサブツリーは　ノードの値より大きいという我々の`Tree`型に間違ったファンクタを与えると、ノードが正しく配置されていないツリーを生成するかもしれない。ファンクタに適用される規則の詳細については後の章で説明する。



## Kinds and some type-foo - 型のようなkindのような

型コンストラクタは他の型をパラメータとして受け取り、最終的に具体的な型を生成する。これは、値を受け取り値を返す関数のようだ。また、型コンストラクタは関数のような(たとえば、`Either String`は、パラメータとして1つの型を受け取り、最終的に`Either String Int`のような具体的な型を生成する、という)部分適用が可能であることを学んだ。これは非常に興味深い。この節では、型宣言を使用することで値が関数によってどのように適用されるかを厳密に定義したようにある型が型コンストラクタによって、どのように適用されるかを厳密に定義する方法について見ていく。Haskellをめぐる冒険を続けるためにこの節を読み進める必要はないし、理解する必要もないから、心配しないで欲しい。しかし、ここを読めば、Haskellが備える型システムの真髄が理解できるようになるだろう。

そう、`3`や`"YEAH"`、そして(関数は関数に渡すことができるから、関数も値となるので)`takeWhile`のような値はすべて各々の型を持つ。型は値に付けられたラベルのようなものであり、これにより値を推論することができる。しかし、型もkindというラベルのようなものを持っている。kindというのは、型の型のようなものだ。これは奇妙で紛らわしく聞こえるかもしれないが、かなり興味深い概念だ。

kindとは何で、kindの何が良いんだろう? では、型のkindについて`:k`というコマンドをghciに入力して実際に調べてみよう。

    ghci> :k Int
    Int :: *

スター`*`が表示された。何だこりゃ? これはどういう意味なんだ? スター`*`というのは、型が具体的な型であることを意味する。具体的な型というのは、型パラメータを一切受け取らない型であり、値が保持できるのは具体的な型のみとなる。(これまで必要に迫られた経験はないが)私が`*`について声に出して説明するとしたら、`*`は型そのものだ、と言うだろう。

わかった。次は`Maybe`のkiindは何かを見てみよう。

    ghci> :k Maybe
    Maybe :: * -> *

型コンストラクタ`Maybe`は1つの、具体的な型(`Int`など)を受け取り、具体的な型(`Maybe Int`など)を返す。これが、上記の結果が意味するところだ。ちょうど`Int -> Int`というのが`Int`を受け取って`Int`を返す関数を意味するように、`* -> *`というのは、型コンストラクタが1つの具体的な型を受け取って1つの具体的な型を返すことを意味する。では、`Maybe`に型パラメータを与えてみて、kindがどうなるか見てみよう。

    ghci> :k Maybe Int
    Maybe Int :: *

まさに期待通りだ。`Maybe`に型パラメータを適用すると、具体的な型が得られる。これが`* -> *`の意味するところだ。(型とkindは異なるものであり、両者は等しくないので)並列する`:t isUpper`と`:t isUpper 'A'`の型は異なる。`isUpper 'A'`という値は`True`になるので、`isUpper`の型は、`Char -> Bool`であり、`isUpper 'A'`の型は`Bool`となる。しかし、両者のkindはどちらも`*`となる。

`:t`を使って値の型を得るように、`:k`を使って型のkindを得る。先程、型は値のラベルのようなものであり、kindは型のラベルのようなものであるが、両者の間には並列の関係がある、ということを言った。

では、他のkindも見てみよう。

    ghci> :k Either
    Either :: * -> * -> *

ああ、これは、`Either`が、型パラメータとして具体的な型を2つ受け取り、具体的な型を生成する、ということを言っている。これは、2つのパラメータを受け取って値を返す関数の型宣言のようにも見える。型コンストラクタも関数のようにカリー化できるので、部分適用が可能となっている。

    ghci> :k Either String
    Either String :: * -> *
    ghci> :k Either String Int
    Either String Int :: *

`Either`を型クラス`Functor`のインスタンスにするとき、部分適用をしておく必要があるが、これは`Either`は2つパラメータを受け取るのに対し、`Functor`が1つのパラメータを受け取る型を要求するからだ。言い換えれば、`Functor`は、`* -> *`という型を要求するので、`Either`を元の`* -> * -> *`から`* -> *`というkindの型を得るために部分適用しておく必要がある。ここで、もう一度型クラス`Functor`の定義を確認しよう。

    class Functor f where
        fmap :: (a -> b) -> f a -> f b

`f`という型変数が具体的な型を受け取り、具体的な型を生成する、ということが読み取れる。また、関数の中で、変数の型を使っているから、具体的な型を生成する必要がある、ということを我々は知っている。ということで、ファンクタの友達になりたがっている型は`* -> *`というkindでなくてはいけない、という推測ができる。

次の型クラスをミてみよう。これは、今適当に考えたものだ。

    class Tofu t where
        tofu :: j a -> t a j

何か、変な感じだ。ある型をこの奇妙な型クラスのインスタンスにするには、どうしたらいいんだろう?では、そのkindがどうなれば良いのかをミてみよう。`j a`は、`tofu`関数がパラメータとして受け取る値の方として使用されているから、`j a`は`*`というkindを持つ必要がある。`*`は`a`い対応する前提だから、`j`は`* -> *`というkindを持つことを推測できる。また、`t`は2つの型を受け取り、具体的なアタいを生成することになる、というのが読み取れる。ここまでで、`a`のkindは`*`であり、`j`のkindは`* -> *`であることが分かったから、`t`は`* -> (* -> *) -> *`というkindを持つ必要がある、と推測できる。つまり、具体的な型(`a`)を受け取り、型コンストラクタは具体的な型(`j`)を1つ受け取り、具体的な型を生成する、ということが読み取れる。

いいね。では、``* -> (* -> *) -> *`というkindを持つ型を作ってみよう。以下は実現方法の1つだ。

    data Frank a b  = Frank {frankField :: b a} deriving (Show)

どうやって、この型のkindが`* -> (* -> *) -> *`であることを知るんだろう? ADTのフィールドは、値を保持するために作られたから、そのkindは明らかに`*`となる。`*`は`a`のために、と仮定したが、これは、1つの型パラメータを受け取るから、そのkindは`* -> *`となる。さて、これで`a`と`b`の両方のkindが明らかになった。これらは`Frank`のパラメータだから、`Frank`のkindは`* -> (* -> *) -> *`となることが分かる。最初の`*`は`a`を表しており、`(* -> *)`は`b`を表している。いくつか`Frank`の値を作って、その型を調べてみよう。

    ghci> :t Frank {frankField = Just "HAHA"}
    Frank {frankField = Just "HAHA"} :: Frank [Char] Maybe
    ghci> :t Frank {frankField = Node 'a' EmptyTree EmptyTree}
    Frank {frankField = Node 'a' EmptyTree EmptyTree} :: Frank Char Tree
    ghci> :t Frank {frankField = "YES"}
    Frank {frankField = "YES"} :: Frank Char []

うーむ。
`frankField` は、`a b`という形の型を持つから、その値も同じ形の型を持つ必要がある。つまり、これらは`Maybe [Char]`という型を持つ`Just "HAHA"`という値や、`[Char]`という型を持つ`['Y','E','S']`という値になれる。(もし、独自のリスト型を作っていたら、`List Char`のような型を持つだろう。)また、`Fるrank`という型の値は、`Frank`のkindに対応していることが読み取れる。`[Char]`は`*`というkindを持ち、`Maybe`は`* -> *`というkindを持つ。値を持つには、具体的な型である必要があるから、すべて適用されている必要があり、`Frank blah blaah `という値は`*`というkindを持つことになる。

`Frank`を`Tofu`のインスタンスにするのは至って簡単だ。`Tofu`は`a j`とう(という形式の型の例は`Maybe Int`など)を受け取って、`t a j`を返す。つまり、`Frank`を`j`で置き換えれば、結果の型は`Frank Int Maybe`のようになる。

    instance Tofu Frank where
        tofu x = Frank x

    ghci> tofu (Just 'a') :: Frank Char Maybe
    Frank {frankField = Just 'a'}
    ghci> tofu ["HELLO"] :: Frank [Char] []
    Frank {frankField = ["HELLO"]}

とても役立つとは言えない。しかし、型という筋肉が柔軟になった。では、もう少し`data`について見てみよう。

    data Barry t k p = Barry { yabba :: p, dabba :: t k }

そして、我々は今これを`Functor`のインスタンスにしたいとする。`Functor`は`* -> *`というkindの型を要求するが、とてもそのようなkindには見えない。では、どんなkindにすれば良いのだろう? そうだね、これは3つの型パラメータを受け取るから、`something -> something -> something -> *`とすることにしよう。これは、`p`が具体的な型であり、`*`というkindを持つといえるので安全だ。`k`については、`*`であると仮定して、ついでに`t`は`* -> *`であるとしよう。これでこれらのkindをプレースホルダとして使用した`something`で置き換えると、そのkindが`(* -> *) -> * -> * -> *`となる。では、ghciで確かめてみよう。

    ghci> :k Barry
    Barry :: (* -> *) -> * -> * -> *

おお、我々は正しかったようだ。しっかり満たされている。では、この型を`Functor`の一部にするために、最初の2つの型パラメータを部分適用する必要がある。そうすれば、`* -> *`が残るこれは、インスタンス宣言が`instance Functor (Barry a b) where`のように始まることを意味する。もし、`fmap`が`Barry`のためだけに作られていたら、その型は、`fmap :: (a -> b) -> Barry c d a -> Barry c d bのようになるだろう。なぜなら、`Functor`の`f`を`Barry`の`c d` で置き換えたからだ。`Barry`の3番目の型パラメータは変更する必要があり、それが自身のフィールドにあることが確認できる。

    instance Functor (Barry a b) where
        fmap f (Barry {yabba = x, dabba = y}) = Barry {yabba = f x, dabba = y}

やったね。`f`を最初のフィールドだけにマップで来た。

この節では、型パラメータがどのように機能するか学び、また、関数のパラメータを型宣言によって厳密にしたように、型パラメータをkindによって厳密にする方法を学んだ。そして、型コンストラクタと関数には興味深い共通点があることを見てきた。しかし、これらは全く異なるものだ。実世界でHaskellを使うときは、kindを散らかしたり、手動でkindを推測することは、まずないだろう。独自の型クラスを標準ライブラリの型クラスのインスタンスにするときに`*`や`* -> *`を部分適用したりする必要があるが、それが実際には、なぜ、どのように機能するかを知っている、というのは良いことだ。加えて、ある型自身もまたある種の型を持っている、というのも興味深い。繰り返しになるが、このチュートリアルを読み進めるために、この節を理解する必要は全くないkindがどのように機能するか理解できたなら、Haskellの型システムについて確実に把握できたといえるだろう。

