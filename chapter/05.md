---
title: "Recursion"
layout: article
---



## Hello recursion!

再起については、前の章で少し触れた。この商では催奇について詳しく見て、Haskellでは何故催奇が重要なのか、そして、催奇の考え方を用いてエレガントかつ明快に問題を解決する方法を学ぶ。

もし、まだ催奇というものが何なのか知らなければ、次の一文を読んで欲しい。はぁ? からかってるの? 催奇は関数定義の中で、定義しようとしている関数を呼び出す方法のことだ。

数学の世界では、定義はしばしば再帰的に行われる。たとえば、フィボナッチ数列は再帰的に定義される。まず、フィボナッチ数列の最初の2つを非再帰的に定義する。$F(0) = 0$と$F(1) = 1$は、それぞれフィボナッチ数列の0と1番目の値が0と1であることを定義している。次に、他の自然数について、求めたいフィボナッチ数は、1つ前と2つ前のフィボナッチ数を足すことで得られる。つまり$F(n) = F(n - 1) + F(n - 2)$となる。たとえば、F(3) = F(2) + F(1) = (F(1) + F(0)) + F(1)となる。ここまでは非再帰的にフィボナッチ数を定義したから、安全に$(3)が2になることを確認できた。

再帰的な関数の定義の中で、再起していない要素、たとえばフィボナッチ数のF(0)やF(1)はedge conditionとよばれ、再帰関数を停止させるために重要となる。もし、edge conditionを定義していなければ、フィボナッチ数の場合はF(-1)、F(-2)...を計算し続けることになり、関数が永遠に停止できなくなり、答えが得られない。

命令型言事は異なり、Haskellにおいて催奇は重要だ。Haskellでは、なにかを求める手順ではなく、それが何なのかを宣言する。Haskellにはforやwhileループがないのは、その代わりとして催奇を使うからだ。



## Maximum awesome

`maximum`関数は、リストの中身がOrdering、type classがOrdに属していれば、その最大値を取り出す。これを命令的に定義する方法を考えてみよう。

おそらく、最大値を保持するための変数を用意して、リストの要素をwhileループを使って1つ1つ調べ、保持している最大値と取り出した要素を比較して、取り出した要素のほうが大きければそれを保持して、最終的にリスト内の最大値を得ることになると思う。

こんな簡単なアルゴリズムなのに、説明するのが大変だ。では、`maximum`関数を再帰的に定義する方法を見てみよう。

最初に、singleton listの場合は最大値がその要素と等しいから、その要素を返す、というedge conditionを定義する。次に、要素が2つ以上あるリストの場合は、リストの先頭の要素と、残ったリストを分割して、先頭のほうが大きければ、それを返す。残ったリストのほうが大きければ、それに対して`maximum`を求めた結果を返す。

以上! 早速、実装してみよう。

    maximum' :: (Ord a) => [a] -> a
    maximum' [] = error "maximum of empty list"
    maximum' [x] = x
    maximum' (x:xs)
        | x > maxTail = x
        | otherwise = maxTail
        where maxTail = maximum' xs

ご覧のとおり、パターンマッチは催奇でその効果を発揮する。殆どの命令言語はパターンマッチの機能を備えていないので、大量のif-elseを用いてedge conditionをテストすることになる。

ここでは、催奇とパターンマッチの組み合わせで問題を解決している。最初のedge conditionは空のリストに対するパターンだ。空のリストに対して最大値は求められないから、これはエラーとする。2番目のパターンもedge conditionだ。singleton listであれば、要素は一つしかないから最大値はその要素となる。

最後のパターンは、3番目のパターン、再起している部分だ。まず、パターンマッチでリストを先頭と残りの部分に分割する。残りのリストに対して最大値を求めるmaxtail関数を定義するのにwhereを使用しているが、これは、リストに対する催奇として一般的なイディオムだから、なれておこう。

そして、リストの先頭が残りの部分より大きいか調べる。もし大きければ、先頭を返す。そうでなければ、リストの残りの部分に対する`maximum`の結果を返す。

例として`[2,5,1]`をこの関数に与えた時、どのように動作するのか調べてみよう。まず、最初の2つのパターンにはマッチしない。3番目のパターンにはマッチするので、リストは`2`と、`[5,1]`に分割される。whereで定義されたmaxtailは、`[5,1]`の最大値を求めるために、maximumを求めることになる。再び3番目のパターンで、`[5,1]`は`5`と`[1]`に分割される。そして、再びwhereでは`[1]`の最大値を求めることになる。`[1]`はedge conditionだから、`1`が返される。最終的に、5と1を比較することになり、ここでは5を返すことになる。つまり、`[5,1]`のmaximumは5であることがわかる。そして、ステップを進めると、2と`[5,1]`のmaximumを求めることになる。`[5,1]`のmaximumは既に5であることが分かっているので、これは2と5を比較することになるから、5を選ぶことになる。


関数`max`を使うことで、この関数をより明確に定義できる。`max`は2つの引数を取り、大きい方を返す。`maximum`を`max`を使って書くと、以下のようになる。

    maximum' :: (Ord a) => [a] -> a
    maximum' [] = error "maximum of empty list"
    maximum' [x] = x
    maximum' (x:xs) = max x (maximum' xs)

なんてエレガントなんだ。ここで重要なのは、リストのmaximumは、リストの先頭とmaxtailに対するmaxの結果になる、というところだ。



## A few more recursive functions

さて、催奇の考え方がわかってきたから、他にも催奇を用いた関数を幾つか定義してみよう。最初に、replicateを定義してみよう。replicateはIntで繰り返しの回数と要素を受け取り、その要素を与えられた回数だけ繰り返したリストを返す。たとえば、`replicate 3 5`は`[5,5,5]`となる。

まずは、edge conditionから考えよう。ぱっと思いつくedge conditionは0か、それより小さい値だ。与えた要素がなんであれ、0回繰り返すというのは、結果として空のリスト`[]`になる。もちろん、負の数に対しても、空のリストを返すべきだろう。

    replicate' :: (Num i, Ord i) => i -> a -> [a]
    replicate' n x
        | n <= 0    = []
        | otherwise = x:replicate' (n-1) x

ここでは、条件を真偽値で判定したいので、パターンマッチングを使う代わりにガードを使った。nが0より小さいか等しければ、空のリストを返す。nが0より大きければ、リストの要素と、要素を(n - 1)回繰り返したリストを連結したリストを返す。結局、n-1という部分はedge conditionに到達することになる。

Note: `Num`というtypeclassは、`Ord`というtypeclassのサブクラスではない。つまり、数値を構成するものの中にはOrderingは含まれていない、ということを意味する。比較を行うためには、NumとOrdの両方を記述する必要があるのはそのためだ。

次は`take`を実装してみよう。takeは、リストから指定した数だけ要素を取り出して、リストとして返す。たとえば、`take 3 [5,4,3,2,1]`を実行すると、`[5,4,3]`が返される。もし、リストの要素数より小さいか、0を指定すると、空のリストが返される。空のリストに対しては、取り出す要素の数に関係なく、空のリストが返される。edge conditionは異常。早速実装してみよう。


    take' :: (Num i, Ord i) => i -> [a] -> [a]
    take' n _
        | n <= 0   = []
    take' _ []     = []
    take' n (x:xs) = x : take' (n-1) xs

最初のパターンは、リストから取り出す値として、0または0より小さい値を指定した時に空のリストを返す、というedge conditionだ。このとき、リストが何であるかは気にしないので、変数名に`_`を使用している。そして、otherwiseなしにガードを使っていることにも注目しよう。このガードの条件がFalseになったときは、次のパターンマッチに進むことを意味する。2番目のパターンは、空のリストに対してマッチするので、取り出す要素の数に関係なく、空のリストが返される。3番目のパターンは、リストを先頭と残りの部分に分割している。そして、先頭の要素と、残りの要素から、指定した数、(n - 1)だけ要素を取り出したリストを連結したリストを返すことになる。

次は、`reverse`はリストを反転させる。edge conditionを考えてみよう。ええと、どうなるだろう。まず、空のリストを反転した結果は、空のリストになる。OK。では、残りはどうなる? リストを先頭と残りの部分に分割して、残りの部分を反転したものと、先頭を連結することになると思う。

    reverse' :: [a] -> [a]
    reverse' [] = []
    reverse' (x:xs) = reverse' xs ++ [x]

Haskellでは無限リストがサポートされているから、edge conditionは必ずしも必要ではない。しかし、無限リストのような無限という構造を持つデータを扱うにはどうすればいいのだろう。無限リストを扱う方法としては、必要な部分だけを切り取る、というのが考えられる。

関数`repeat`は、受け取った値を無限に繰り返して、無限リストを返す。これを再起で定義する方法は簡単だ。見てみよう。

    repeat' :: a -> [a]
    repeat' x = x:repeat' x

`repeat 3`をcallすると、ghciの画面が`3`でうめつくされるだろう。`repeat 3`は`repeat 3`をevaluateすることになり、その`repeat 3`というのは`repeat 3`をevaluateすることになるから、これは止まらなくなる・このままでは止まらなくなるので、`take 3 (repeat 3)`のように要素をいくつ取り出すか指定する必要がある。これは、`replicate`関数で部分的に行っていることだ。

`zip`関数は、リストを2つ受け取り、それらをまとめる。zipに渡されるリストの要素っすうが一致しない場合は、短い方に合わせる。zipに空のリストを渡すと、もう一方のリストに関係なく空のリストが返される。これらがedge conditionになる。しかし、zipは2つのリストを受け取るから、実際には2つのedge conditionが必要になる。

    zip' :: [a] -> [b] -> [(a,b)]
    zip' _ [] = []
    zip' [] _ = []
    zip' (x:xs) (y:ys) = (x,y):zip' xs ys

最初の2つのパターンは、zipに渡されたリストのどちたかが空であれば、空のリストを返すことを示している。3番目のパターンは、2つのリストの先頭をタプルにまとめて、それを残りのリストにたいしてzipした結果と結合したリストお返すことを示している。`zip [1,2,3] ['a', 'b']`の結果は、最終的には`[3]`と`[]`をzipすることになる。`zip [3] []`の結果は`[]`だから、結果として`(1, 'a'):(2, 'b'):[]`することになり、期待通りの結果`[(1,'a'),(2,'b')]`が得られる。

もうひとつ、標準的なライブラリ関数である`elem`を実装してみよう。この関数は、要素とリストを渡すと、リストの中にその要素が存在するか判定する。リストに対するedge conditionは、これまで何度も見てきたように、空のリストに対するものだ。空のリストには何も要素がないから、探したい要素は含まれない。

    elem' :: (Eq a) => a -> [a] -> Bool
    elem' a [] = False
    elem' a (x:xs)
        | a == x    = True
        | otherwise = a `elem'` xs

予想通りの結果が得られるし、定義はシンプルだ。リストの先頭が目的の要素か調べ、違っていれば残りのリストにたいして`elem'`を求める。もし、目的の要素が存在しなければ、最終的には空のリストにたどり着いて、Falseが返される。



## Quick, sort!

ソート可能な要素を持つリストがある。要素のtypeclassはOrdだ。では、クイックソートを使って、要素をソートしてみよう。これは、要素をソートするための賢い方法だ。これを実装するには、命令言語では10行以上必要になるところを、Haskellでは10行より少なく、エレガントに、そしてシンプルに実装できる。クイックソートはHaskellの縮図とも言える。

では、早速実装してみよう。Haskellのエレガントさを説明するのにクイックソートはうってつけだ。　

まず、type signatureは、`(Ord a) => a -> [a] -> [a]`となる。特に驚くことはないね。edge conditionは、ご想像のとおりだ。空のリストをソートしても空のリストになる。では、本題のアルゴリズムについて。まず、ソート済みのリストはリストの先頭要素と、残りの要素で構成される。残りのリストはソート済み、かつ先頭の要素より小さいか等しい値で構成される。次に、リストの中から、先頭の要素を取り出し、ソート済みリストのすべての要素の内、先頭の要素より大きいものを取り出す。この定義では、ソートを2回行っているのに気づくと思う。つまり、催奇を2回callすることになる。そして、アルゴリズムを定義するのにあれをして、これをして、...という手順を示す代わりに動詞を使っているのにも気づいただろう。これがfunctional programmingの美しさだ。リストから先頭の要素より小さい値を取り覗いてのこったリストからもっとも大きい値を取り出すにはどうすればいい?そう、list comprehensionを使えばいい。では、関数を実際に定義してみよう。

    quicksort :: (Ord a) => [a] -> [a]
    quicksort [] = []
    quicksort (x:xs) =
        let smallerSorted = quicksort [a | a <- xs, a <= x]
            biggerSorted = quicksort [a | a <- xs, a > x]
        in  smallerSorted ++ [x] ++ biggerSorted

適当なリストを与えて、これが正しく動作するかテストしてみよう。

    ghci> quicksort [10,2,5,3,1,6,7,4,2,3,4,8,9]
    [1,2,2,3,3,4,4,5,6,7,8,9,10]
    ghci> quicksort "the quick brown fox jumps over the lazy dog"
    "        abcdeeefghhijklmnoooopqrrsttuuvwxyz"

やったね、うまく動いた! これが長々と説明したクイックソートの結果だ。

では、`[5,1,9,4,6,7,3]`をソートする過程を追跡しよう。このアルゴリズムは、まずリストから先頭の要素`5`を取り出し、残りのリストにたいして、`5`より小さいか等しい値で構成されたリストと、`5`より大きい値で構成されたリストを求める。この段階では、`[1,4,3] ++ [5] ++ [9,6,7]`となる。そして、小さい方のリスト、`[1,4,3]`がソートされても、`5`の位置はッ変化せず、先頭から4番目にとどまることに注目してほしい。小さい方のリストには`5`より小さいか等しい値しか存在しないので、`5`はリストの4番目に位置し続けることになる。次に、小さい方のリストと大きい方のリストをソートする。どちらのソートにも同じクイックソート関数を使っていることに注目してほしい。最終的に、空のリストにたどり着くが、空のリストはソート済み、と見なされるので、ソートはうまく機能する。図で説明しよう。

(分かりやすい図が掲載されているので、オリジナルのページを見てください。)

ソート済みの要素は、一度その場所に留まると動かない。左から右へ眺めると、ソート済みのリストになる。type declarationでtypeclassがOrdの要素を受け取るようにしたので、比較可能な要素で構成されたリストであれば、どんなリストに対してもソートできる。クイックソートでは、比較対象となる戦闘の要素のことをピボットと呼ぶ。図の中の、緑色で示した部分だ。なぜリストの先頭要素を選んだのかというと、パターンマッチを使って簡単に取り出せる体。図の中では、ピボットより小さいものは淡い緑色で、ピボットより大きい物は深い緑色で示している。黄色で示した部分は、クイックソートを適用していることを示している。



## Thinking recursively

再起について少し学んだので、ここで再帰的に考えるためのパターンを紹介しよう。まず、edge caseを定義して、それからある要素に対する操作を定義する。そして、残ったリストに対して関数を適用する。催奇の対象はツリーやリストに限らないので、どんなデータ構造でも問題ない。

たとえば、`sum`はリストの先頭要素と、残りのリストに対する`sum`の結果を足したものを返す。 `product`はリストの先頭要素と残りのリストのproductの結果を返す。 `length`は1と残りのリストに対する`length`の結果を足したものを返す。

もちろん、これらの関数にはedge caseが存在する。通常、edge caseは再帰的に関数を適用できない場合のために用意する。リストを扱う場合、空リストは頻繁にedge caseとなる。木構造を扱う場合であれば、子要素を持たない、というのがedge caseになるだろう。

数値を再帰的に扱う場合もこれに似ている。通常、ある数値を操作して、変更された数値に対して関数を再び適用する。以前、階乗を求める`factorial`を定義したが、あのかんすうでは、　受け取った数値`n`にたいして、その数と`factorial (n - 1)`の結果を求めていた。この再帰関数は性の数に対する会場を定義しているので、0に対して催奇を求める意味は無い。多くの場合、edge caseではそれがedge caseであることを示す値、identityを返す。

ある数値に対して1をかけるとその数値になるので、乗算のidentityは1となる。リストから要素を取り出して合計を求めるときは、空のリストがedge caseとなるが、その値は加算のidentityである、0に対応する。クイックソートではedge caseは空のリストとなるし、identityも空のリストとなる。空のリストをソートすると、空のリストになるからだ。

つまり、問題を再帰的に解決するには催奇を適用できない場合を洗い出し、それをedge caseとしてていぎして、催奇を停止させるidentityが何になるかを考える。例えば、リストの場合はパターンマッチにより先頭の要素と末尾の要素に分割して、それらを再帰的に利用する。

