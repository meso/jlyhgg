---
title: ""Higher order functions" - 高階関数"
layout: article
---



Haskellの関数は関数をパラメータとして受け取り、値として返すことができる。このような関数をHigher order functionという。高階関数はHaskell固有の機能ではないが、Haskellで使うことができる。

高階関数は、関数の持つ状態を変化させつつループさせたい場合に使うものであり計算の手順ではなく、その関数自体を返す。Haskellにとって高階関数は不可欠だ。これは、なにか問題を解決するときに、プログラムを考える強力な手段となる。



## Curried functions - カリー化された関数

正確に述べると、Haskellでは、すべての関数が一度に1つのパラメータしか受け取ることができない。では、これまで2つ以上のパラメータを受け取る関数をいくつか定義してきたが、あれはどうして可能なんだろう? 実は賢いトリックが隠されている。複数のパラメータを受け取ることができる関数はすべてcurried function、カリー化された関数だったのだ。...これがどういう意味７日、実際の例から理解するのが一番だろう。

さて、関数`max`を覚えているかな? この関数は、2つのパラメータを受け取り、大きい方を返しているように見える。

`max 4 5`を実行すると、まず、「4か、与えられた引数のどちらか大きい方を返す関数」を返す。次に、その関数に`5`を適用すると、4と5のどちらが大きいか判定して、望みの結果が得られる。一言で軽く説明してしまったが、これは興味深い概念だ。

つまり、以下の2つの関数呼び出しは等しい。

    ghci> max 4 5
    5
    ghci> (max 4) 5
    5


2つのものの間にスペースを挟むと、それはkfunction application、関数適用になるのだった。スペースは演算子であり、最も優先度が高い。`max`関数のtypeを調べてみよう。

    ghci> :t max
    max :: Ord a => a -> a -> a

これは`(Ord a) => a -> (a -> a)`と書くこともできる。`max`はaというtypeのパラメータを受け取ってまず、aというtypeのパラメータを受け取る関数を返し、その関数はaというtypeの値を返す。

これが、返されるtypeと関数のパラメータが、それぞれ区別なく、単に矢印`->`で句切られていた理由だ。それで、これの何が便利なんだろう? 単純にエヴァ、関数にパラメータの一部だけを与えると、部分的にパラメータが適用された関数が得られる。つまり、まだ与えていないパラメータの数だけ、パラメータを受け取れる関数が得られる。

部分適用(部分的にパラメータを与えて関数を呼び出すこと)は、手っ取り早くかつ、お手軽に関数を作る方法だ。そして、部分的にパラメータが適用された関数は、他の関数に渡すこともできるし、データとして扱うこともできる。

ここで、超単純な関数を見てみよう。

    multThree :: (Num a) => a -> a -> a -> a
    multThree x y z = x * y * z

では、`multThree 3 5 9`と` ((multThree 3) 5) 9`の違いは何だろう?

まず、スペースで区切られているので、3は`multThree 3`が適用される。すると、パラメータを1つ受け取り、関数を返す関数が作られる。続いて、5をその関数に適用する。すると、パラメータを1つ受け取り、15とそのパラメータを乗算した結果を返す関数が作られる。最後に、9をパラメータとしてその関数に適用すると、結果として、135が返される。

`multThree`は、`multThree :: (Num a) => a -> (a -> (a -> a))`と書けることを思い出してほしい。矢印`->`の前の部分は関数が受け取るパラメータを、後ろの部分は、関数が何を返すかを表しているのだった。

つまり、いま定義した関数は、typeがaのパラメータを受け取り、`(Num a) => a -> (a -> a)`を返す、という読み取り方ができる。同様に、この関数はtypeがaのパラメータを受け取り、`(Num a) => a -> a`を返すという読み取り方もできる。そしてこの関数は、最終的にはaというtypeのパラメータを受け取り、aというtypeの値を返す。

確認してみよう。

    ghci> let multTwoWithNine = multThree 9
    ghci> multTwoWithNine 2 3
    54
    ghci> let multWithEighteen = multTwoWithNine 2
    ghci> multWithEighteen 10
    180

部分的にパラメータを与えて関数を呼ぶと、それはつまり関数を作ることになる。例えば、数値を受け取り、`100`と比較する関数は、次のように定義できる。

    compareWithHundred :: (Num a, Ord a) => a -> Ordering
    compareWithHundred x = compare 100 x

この関数に99を与えれば結果は`GT`となるのは理解できると思う。等式の両辺の右側にある`x`に注目してほしい。`compare 100`が何を返すのか考えてみよう。この関数は、100とパラメータを比較して結果を返す。おや? これは`compareWithHundred`と同じことじゃないか。つまり、次のように定義できる。

    compareWithHundred :: (Num a, Ord a) => a -> Ordering
    compareWithHundred = compare 100

`compare 100`は関数を返すことに変わりはないから、`compareWithHundred`のtype declarationは全く変化していない。`compare`のtype declarationは、以下のとおりだ。`compare 100`の`100`は、type classが`Num`であることにも注目してほしい。

    ghci> :t compare
    compare :: Ord a => a -> a -> Ordering

カリー化と部分適用は重要な概念だから、しっかり理解してほしい。

さて、infix functionは、sectionを使って部分的に適用することができる。infix functionをsectionするには、関数をかっこで包み、その隣にパラメータを置く。これで、パラメータをひとつ受け取る関数が作られるので、足りていないパラメータを与えると、結果が得られる。ちょっとした関数を定義して試してみよう。

    divideByTen :: (Floating a) => a -> a
    divideByTen = (/10)

`divideByTen 200`をcallした結果は、`200 / 10`と等しい。次は、与えた文字が小文字化判定する関数を作ってみよう。

    isUpperAlphanum :: Char -> Bool
    isUpperAlphanum = (`elem` ['A'..'Z'])

sectionについて、唯一特殊な点は`-`を使う時だ。sectionの定義通りに解釈すると、`(-4)`は、数値を受け取り、4を引く関数になってしまう。しかし、利便性のために`(-4)`は、マイナス4と解釈される。ということで、ある数値から4を引く、という関数を定義したい場合は、`subtract`関数を使って`subtract 4`と定義する必要がある。

さて、ghciで`multThree`関数を`let`で変数にbindしたり、他の関数にパラメータとして渡すことなく、直接パラメータが足りない状態で呼び出すとどうなるか試してみよう。

    ghci> multThree 3 4
    <interactive>:1:0:
        No instance for (Show (t -> t))
          arising from a use of `print' at <interactive>:1:0-12
        Possible fix: add an instance declaration for (Show (t -> t))
        In the expression: print it
        In a 'do' expression: print it

ghciのメッセージは、与えられたexpressionを実行した結果、typeが`a -> a`となる関数が返されたものの、これをどのように表示すればいいかわからない。ということを表している。関数はShowというtypeclassに属していないから、文字列でどう表現すべきかわからなかったのだ。

ghciでは、たとえば`1 + 1`を計算した時、数値`2`という答えが得られた後にその文字列表現である`show 2`を求める。そして、数値`2`の文字列表現は`'2'`になるから、画面上に表示できたわけだ。



## Some higher-orderism is in order - 高階する理由

関数は関数をパラメータとして受け取り、関数を返すことができる。これを説明するために、関数を受け取り、その関数にパラメータを2回適用する、という関数を定義してみよう。

    applyTwice :: (a -> a) -> a -> a
    applyTwice f x = f (f x)

まず、type decralationについて注目してみよう。以前、パラメータを複数受け取る関数のtype decralationでは、右から順に解釈されるので、パラメータをカッコで包む必要はない、と説明した。しかし、ここでは必須となる。まず、最初のパラメータは、それが、パラメータと同じtypeのパラメータを受け取る関数であることを示している。2番目のパラメータは、同じtypeの値を返すことを示している。

このtype decralationでは、カリー化を使う選択肢もあるが、安全を重視して、この関数は2つのパラメタを受け取り、値を返す、というように定義している。最初のパラメータは、typeが`(a -> a)`という関数であり、2番目のパラメータは、同じtypeとなる。パラメータとなる関数にはもちろん`Int -> Int`や`String -> String`など、どんなtypeを指定しても問題はない。ただし、2番目のパラメータは、最初のパラメータと同じtypeにする必要がある。

Note: 此処から先は、何か値をかえすまで、実際には部分的にパラメータが与えられた状態の関数を返すことになるが、「複数のパラメータを受け取る関数だ」ということにしよう。

既に`a -> a -> a`がカリーかされた関数であり、実際には1つのパラメータを受け取る関数で構成されているのを学んだが、説明を単純にするために、は2つのパラメータを受け取る関数だ、とみなすことに仕様。

関数のbodyは実にシンプルだ。パラメータでは`f`を関数として受け取り、パラメータ`x`にスペースを挟んで関数`f`を適用したものに、またその関数`f`を適用する。実際にこの関数を試してみよう。

    ghci> applyTwice (+3) 10
    16
    ghci> applyTwice (++ " HAHA") "HEY"
    "HEY HAHA HAHA"
    ghci> applyTwice ("HAHA " ++) "HEY"
    "HAHA HAHA HEY"
    ghci> applyTwice (multThree 2 2) 9
    144
    ghci> applyTwice (3:) [1]
    [3,3,1]

関数の部分適用の素晴らしいところは明らかだ。もし、パラメータを一つだけ受け取る関数、を受け取るようにしたい場合、部分適用した状態の関数を、必要になった箇所でその関数に渡すようにすればいい。

では、高階関数を使って、標準ライブラリにあるような便利な関数を自分で定義してみよう。それは`zipWith`という関数だ。この関数は2つのリストと関数をパラメータとして受け取り、それぞれのリストの要素に対して関数を適用した結果をリストとして結合して返す。いかが、実装方法だ。

    zipWith' :: (a -> b -> c) -> [a] -> [b] -> [c]
    zipWith' _ [] _ = []
    zipWith' _ _ [] = []
    zipWith' f (x:xs) (y:ys) = f x y : zipWith' f xs ys

では、type declarationを見てみよう。最初のパラメータは、パラメータを2つ受け取る関数だ。その2つのtypeは異なるが、同じものを与えることもできる。2、3番目のパラメータはリストだ。そして、結果もリストとなる。関数がパラメータとしてtypeがaの値を受け取るので、最初のリストは、typeがaの要素で構成されたリストでなければならない。2番目のリストは、同じ理由によりtypeがbの要素で構成されたリストでなければならない。

そして、結果のリストはtypeがcの要素で構成されなければならない。`zipWith`がパラメータとして受け取る関数のtype decralationは`a -> b -> c`となているから、もちろん`a -> a-> a`というのもこれに含まれる。Haskellでは、高階関数に限らず、関数を定義するときに、そのtype declarationが正しいか自信がない時や、一々書くのが面倒なときに、type declarationを省略して、`:t`でその関数のtypeをHaskellが推測した結果を確認できる、というのを覚えているかな?

関数の挙動は、普通のzipに似ている。edge conditionも同じだ。ただし、関数を受け取っているので、そこは変数名に`_`を使って、いる。最後のパターンも、`関数の　bodyが`(x, y)`の代わりに`f(x,y)`としている点を除けば、よく似ている。A single higher order functionは、タスクが一般的であれば、、複数のタスクをこなすのに使われる。以下に、`zipWith`がどのように動作するかを示す。

    ghci> zipWith' (+) [4,2,5,6] [2,6,2,3]
     [6,8,7,9]
     ghci> zipWith' max [6,3,2,1] [7,3,1,5]
     [7,3,2,5]
     ghci> zipWith' (++) ["foo ", "bar ", "baz "] ["fighters", "hoppers", "aldrin"]
     ["foo fighters","bar hoppers","baz aldrin"]
     ghci> zipWith' (*) (replicate 5 2) [1..]
     [2,4,6,8,10]
     ghci> zipWith' (zipWith' (*)) [[1,2,3],[3,5,6],[2,3,4]] [[3,2,2],[3,4,5],[5,4,3]]
     [[3,4,6],[9,20,30],[10,12,12]]

ご覧のとおり、single higher order functionは、多彩な使い方ができる。

これを命令言語で実現しようとすると、forやwhileループを使って、何か操作してはその状態を変数に保持して、また何か操作をして...と、面倒なことになる。そして、その振る舞いをまとめて実現するためのインターフェースとして、命令言語における関数で、それを包むことになる。

これに対して、functional programmingでは、高階関数が共通のパターンに対する抽象的な処理の方法、例えば、ある2つのリストに対し、それをペアにまとめたり、あるいは別の何かとして答えを返したり、不要な要素をリストから取り除いたり、といったことができる。

次は、別の標準ライブラリ関数、`flip`を自分で実装してみよう。`flip`に関数を渡すと、関数のbodyはそのままに、パラメータを受け取る順番を逆にした関数を返す。では、実装してみよう。

    flip' :: (a -> b -> c) -> (b -> a -> c)
    flip' f = g
        where g x y = f y x

`flip'`のtype declarationを見ると、a、bという順番でパラメータを受け取る関数を受け取り、b、aの順番でパラメータを受け取る関数を返す、ということが読み取れる。ただ、すべての関数はすでにcurried functionなので、`(b -> a -> c)`は、あえてカッコで包む必要はない。また、`b -> a -> c`は`(b -> (a -> c))`とも等しい。

さて、この関数では、`g x y = f y x`と書いている。もし、それが正しければ、`f x y = g y x`ということになる。つまり、この関数は以下のように書ける。

     flip' :: (a -> b -> c) -> b -> a -> c
     flip' f y x = f x y

ここで、関数が最初からcurryされている利点が享受できる。もし、`flip`に関数だけを与えれば、パラメータを逆順で受け取る関数が返される。受け取るパラメータを逆順にした関数は、他の関数に渡される事が多いので、パラメータが完全に適用された結果がどうなるか、さきのことを考えて、高階関数を作るときに、curryingの利点が享受できる。



## Maps and filters - マッピングとフィルタリング

`map`は、関数とリストを受け取って、リストのすべての要素に関数を適用した結果からなる、新しいリストを返す。まずはtype signatureを確認して、この関数がどのように定義されているか見てみよう。

    map :: (a -> b) -> [a] -> [b]
    map _ [] = []
    map f (x:xs) = f x : map f xs

type signatureから、`a -> b`という関数と、、`[a]`というリスト、を受け取って、`[b]`というリストを返すことが読み取れる。関数のtype signatureを見るだけで、、その関数が何をしたいのかが分かる。`map`は、多彩な高階関数の一つであり、何万通りもの使い方ができる。実際に試してみよう。

    ghci> map (+3) [1,5,3,1,6]
    [4,8,6,4,9]
    ghci> map (++ "!") ["BIFF", "BANG", "POW"]
    ["BIFF!","BANG!","POW!"]
    ghci> map (replicate 3) [3..6]
    [[3,3,3],[4,4,4],[5,5,5],[6,6,6]]
    ghci> map (map (^2)) [[1,2],[3,4,5,6],[7,8]]
    [[1,4],[9,16,25,36],[49,64]]
    ghci> map fst [(1,2),(3,5),(6,3),(2,6),(2,5)]
    [1,3,6,2,2]

`map`関数で実現したいことは、list comprehensionでも実現できる、ということにお気づきだろうか。たとえば、`map (+3) [1,5,3,1,6]`というのは、`[x+3 | x <- [1,5,3,1,6]]`と、同じだ。しかし、あるリストの要素すべてに関数を適用したい場合、`map`を使うほうがより読みやすくなる。特に、`map`に対して`map`を適用する場合は、list comprehensionで同じことをしようとすると、カッコだらけになって、読みづらくなるだろう。

`filter`はpredicate、`True`か`False`を返す関数とリストを受け取り、リストからある要素をpredicateにもとづいて取り除いたリストを返す関数だ。type signature と実装は、このようになる。

    filter :: (a -> Bool) -> [a] -> [a]
    filter _ [] = []
    filter p (x:xs)
        | p x       = x : filter p xs
        | otherwise = filter p xs

シンプルだね。predicateが`True`なら、その要素`x`と残りのリスト`xs`を`filter' p xs`おして連結した結果を返す。では、この関数の使用例を見てみよう。

    ghci> filter (>3) [1,5,3,2,1,6,4,3,2,1]
    [5,6,4]
    ghci> filter (==3) [1,2,3,4,5]
    [3]
    ghci> filter even [1..10]
    [2,4,6,8,10]
    ghci> let notNull x = not (null x) in filter notNull [[1,2,3],[],[3,4,5],[2,2],[],[],[]]
    [[1,2,3],[3,4,5],[2,2]]
    ghci> filter (`elem` ['a'..'z']) "u LaUgH aT mE BeCaUsE I aM diFfeRent"
    "uagameasadifeent"
    ghci> filter (`elem` ['A'..'Z']) "i lauGh At You BecAuse u r aLL the Same"
    "GAYBALLS"

これらは、list comprehensionのpredicateでも同じことができる。`map`や`filter`か、list comprehensionか、どちらを選ぶべきかという明確な基準はないコードの読みやすさやコーディング規約などをもとにその都度決めればいい。list comprehensionでは複数のpredicateを記述できたが、`filter`関数の場合は、`&&`でpredicateを結合するか、`filter`を何回か適用することで代用できる。

さて、前の商でクイックソートをlist comprehensionを用いて実装したのを覚えているかな?ピボットに対して、残りのリストと比較して値がより小さいか、等しいか、大きいか、というのをlist comprehensionで調べていた。同じ機能を`filter`関数を用いて実現できる。


    quicksort :: (Ord a) => [a] -> [a]
    quicksort [] = []
    quicksort (x:xs) =
        let smallerSorted = quicksort (filter (<=x) xs)
            biggerSorted = quicksort (filter (>x) xs)
        in  smallerSorted ++ [x] ++ biggerSorted

functional programmingにおいて、`map`と`filter`はパンとバターのようなものだ。その機能をlist comprehensionを使うか、関数として使うかは問題ではない。

さて、3辺の合計がある値になる直角三角形をどのように求めたかを思い出してほしい。命令言語では、3段階ネストしたループを用いて、いまの値が目的の直角三角形を満たすかどうか、3つのパラメータをその都度計算することになる。そして、目的の値に一致すれば、それを表示する。

Functional programmingでは、これはmapとfilterを用いて実現できる。まず、パラメータを受け取って、答えとなりうるものを列挙する関数を作る。`map`でリストにたいして関数を適用し、その結果から`filter`で条件を満たさないものを取り除くことで期待通りの結果が得られる。Haskellのlazinessのおかげで、リストに対する`map`や`filter`を何回か行う場合でもリストを一度与えるだけで住む。

では、0から100000の内、3829で割り切れる最大の値を求めてみよう。単純に、答えとなりうる集合から、条件に合わないものをfilterするだけでいい。

    largestDivisible :: (Integral a) => a
    largestDivisible = head (filter p [100000,99999..])
        where p x = x `mod` 3829 == 0

まずは、降順に100000までの整数を含むリストを作る。そして、リストは降順に並んでいるから、条件に合わない要素を取り除いたリストの先頭の要素を答えとして取り出す。そして、開始時点では有限のリストを使う必要はない。

`head`で要素を取り出したいだけなので、対象となるリストが無限化有限か、ということを気にする必要はない。evaluationは、最初に条件に合致するものを見つけた時点で止まるからだ。

次は、2乗した結果が奇数となるものを全て合計した結果農地、100000より小さいものをを返す関数、を実装してみよう。まず、答えを求めるのに必要となる`takeWhile`関数を紹介する。この関数にリストとpredicateを渡すと、リストの先頭の要素から順番にpredicateを試して、それがTrueである間はその要素をリストから取り出し続ける。Falseになれば、その時点で要素を取り出すのを止める。

例えば、文字列`"elephants know how to party"`から最初の単語を取り出したければ、`takeWhile (/=' ') "elephants know how to party"`とする。結果は`elephants`となる。いいね。

では、100000より小さい、すべての2乗の結果を求める。まず、無限リストに対して`^ 2`で、2乗した結果をマッピングする。そして、その中から奇数となるものを取り除く。さらに、その中空100000より小さいものを取り出す。最後に、それらの合計を求める。この関数は、1行で定義できる。


    ghci> sum (takeWhile (<10000) (filter odd (map (^2) [1..])))
    166650

これはすごい。初期値として、自然数1から始まる無限リストを用意して、それをmapして、filterして、最後に得られたリストを合計する。もちろん、これはlist comprehensionを使って書くこともできる。

    ghci> sum (takeWhile (<10000) [n^2 | n <- [1..], odd (n^2)])
    166650

どちらが綺麗な方法に見える化は、好みの問題だ。繰り返しになるが、HaskellのLazinessがこれを可能にしている。無限リストに対する`map`や`filter`は、実際にその場で即座に`map`や`filter`するのではなくその操作は遅延して行われる。Haskellに`sum`関数が求めた総和を表示させようとすると、`sum`は`takeWhile`に総和を求めたいリストが必要だ、と伝える。そして、`takeWhile`は、10000より大きいか等しい値に遭遇するまでマッピングとフィルタリングを続ける。

次は、自然数に対するコラッツ数列を求めてみよう。もし、ある数が偶数なら、2で割る。もし、ある数が奇数なら、その数に3をかけて1を足す。これらの結果に対して、再度同じ手順を踏むことで結果を求める。そして、自然数の連鎖が得られる。、どんな数から始めてもいいが、結果が1になった時点で、この連鎖を止める。

では、コラッツ数列が何であるか分かったところで、1から100までのコラッツ数列の内、その長さが15より大きい物はいくつ存在するか、求めてみよう。まずは連鎖を生み出す関数から実装しよう。

    chain :: (Integral a) => a -> [a]
    chain 1 = [1]
    chain n
        | even n =  n:chain (n `div` 2)
        | odd n  =  n:chain (n*3 + 1)

連鎖は1で止まるから、これは催奇のedge caseとなる。

    ghci> chain 10
    [10,5,16,8,4,2,1]
    ghci> chain 1
    [1]
    ghci> chain 30
    [30,15,46,23,70,35,106,53,160,80,40,20,10,5,16,8,4,2,1]

うん、問題なく動いている。では、先ほどの問題に対する答えを求めてみよう。

    numLongChains :: Int
    numLongChains = length (filter isLong (map chain [1..100]))
        where isLong xs = length xs > 15

まず、連鎖のリストを得るために、`[1..100]`に対して`chain`関数をマッピングしている。そして、連鎖のリストから、その長さが15より大きい物を取り出す。フィルタリングが完了すれば、連鎖した結果が15より大きくなるもののリストが得られるわけだ。

Note: `length`は歴史的な理由により、その結果を`Int`として返すので、上記の関数のtype declarationでは`Int`を使用している。もし、`length`が`Num`を返すのであれば、`Int`の代わりに`Integral`という、もっと一般的なtypeを使用できる。

`map`関数は、無限リストに対して、例えば`map (*) [0..]`という事ができる。curryされた関数(と、部分適用された関数)は、値として他の関数に渡したり、リストにたいして使うことができるのだった。ただし、関数を文字列として表現できない、ということも学んだ。

さて、ここまで`map`関数はたとえば、`map (*2) [0..]`という具合に、リストにたいして一つのパラメータを受け取ってそれをリストの各要素に対してマッピングしていたので、結果のtypeは``(Num a) => [a]`となっていた。

しかし、`map (*) [1..]`というのも問題なくできる。どういうことかというと、リストの要素は、関数`*`が適用された状態になり、そのtypeは`(N、um a) => a -> a -> a`となる。

2つのパラメータを受け取る関数にひとつだけパラメータを与えると、ひとつのパラメータを受け取る関数になるのだった。つまり、リストにたいして関数`*`をマッピングすると、一つのパラメータを受け取る関数、のリストが得られる。

実際にはできないが、文字列で表現すると、`[(1 *), (2 *), (3 *)..]`というリストになるだろう。そして、そのリストのtypeは、`(Num a) => [a -> a].となる。

    ghci> let listOfFuns = map (*) [0..]
    ghci> (listOfFuns !! 4) 5
    20

リストの4番目を取り出すと、関数が得られる。その関数は`(4 *)`と等しいので、この関数に`5`を適用できる。つまり、`(*) 4 5`もしくは`4 * 5`と等しくなり、結果として`20`が得られる。



## Lambdas - ッラムダ

lambdaは一度しか使わない場合に使う、匿名関数だ。普通、ラムダは公開関数を作るために用いる。ラムダを使うには、バックスラッシュ`\`の後にパラメータをスペースで区切って書く。ちなみに、バックスラッシュは、ギリシャ文字のラムダを意図している。そして、パラメータの後には、矢印`->`を起き、その後に関数のbodyを記述する。どこまでが関数のbodyか判断できるように、ラムダを記述するときは、それをかっこ`()`で包む。

もし、`numLongChain`関数の中で、数列の長さでフィルタリングをしたくなっったら、`where`を使って`isLong`という関数を定義するだろう。そうする代わりに、ラムダを使うことができる。

    numLongChains :: Int
    numLongChains = length (filter (\xs -> length xs > 15) (map chain [1..100]))

ラムダはexpressionだから、上記のように`filter`へ渡すことができる。`(\xs -> length xs > 15)`というexpressionは、与えたリストの長さが15より大きいか判定した結果を返す関数だ。

カリー化や、部分適用がどのように機能するのかをよく理解していない人は、ひつようのない場面でラムダを使ってしまうことがある。たとえば、`map (+3) [1,6,3,2]`というexpressionに対して`map (\x -> x + 3) [1,6,3,2]`という書き方をしてしまう。パラメータを受け取って、それに3を足したものを返すという関数`\x -> x + 3`は、`+ 3`と等しい。言うまでもなく、この場合はラムダを使う必要はないし、`+ 3`のほうが読みやすい。

普通の関数のように、ラムダは複数のパラメータを受け取ることができる。

    ghci> zipWith (\a b -> (a * 30 + 3) / b) [5,4,3,2,1] [1,2,3,4,5]
    [153.0,61.5,31.0,15.75,6.6]

そして、普通の関数と同様に、ラムダでもパターンマッチが使える。唯一の違いは、一つのパラメータに対して複数のパターン、例えば、`[]`と`(x:xs)`のようなパターンを調べ、これに当てはまらなければフォールスルーして次のパターンを試す、というような、記述ができない、というところだ。

もしラムダでパターンマッチが失敗すると、ランタイムエラーとなるので、ラムダの中では慎重にパターンマッチをする必要がある。

    ghci> map (\(a,b) -> a + b) [(1,2),(3,5),(6,3),(2,6),(2,5)]
    [3,8,9,8,7]

ラムダは、意図してそうする目的がない限り、かっこで包むのが普通だ。ここで面白い例を紹介しよう。Haskellではすべての関数が最初からcurryされているから、以下の2つは等しくなる。

    addThree :: (Num a) => a -> a -> a -> a
    addThree x y z = x + y + z

    addThree :: (Num a) => a -> a -> a -> a
    addThree = \x -> \y -> \z -> x + y + z

関数をこのように記述すると、type declarationの意図が明確になる。どちらのtype declarationにも矢印`->`が登場する。ただ、もちろん最初の関数のほうが、何をする関数７日が見た目で分かりやすいし、2爪の関数はcurryの機能を説明する方法としてなら使えるだろう。

しかし、この記法を活かせる場面がある。`flip`関数の定義はその一例ではないかと思う。

    flip' :: (a -> b -> c) -> b -> a -> c
    flip' f = \x y -> f y x

これは、`flip' f x y = f y x`と同じ意味になる。しかし、ラムダを使えばこの関数が新しく関数を返すのだ、という糸を明確にできる。

flipの最も一般的な使用例は、flipに何か関数を与えて、それを`map`や`filter`に渡す、というものだ。ラムダは、その関数が部分適用されていることを明確にして他の関数にパラメータとして渡したい場合の方法として使える。



## Only folds and horses - 畳み込めるもの

さて、ここで催奇の話に戻ろう。催奇はリストにたいしてよく使われる。そして、リストに対するedge caseは普通、空のリストになるのだった。`(x:xs)`というのはリストを先頭と残りの部分に分割する、というのも紹介した。このようなリストに対する処理は一般的で、カプセル化されている。これらの関数は`fold`と呼ばれる。`map`関数のように、リストを受け取ってある1つの値を残すという関数だ。

`fold`関数は、binary functionとリストを受け取り、リストを畳み込む関数だ。、binary functionというのは2つのパラメータを受けとる関数だ。binary functionは、最初、あるいは最後の要素とaccumulator を伴ってcallされ、新しいaccumulatorを返す。そして、binary functionはその新しいaccumulatorと最初、あるいは最後の要素を伴ってcallされ、というのを繰り返す。リストの要素全てに対し、この操作が終わるとaccumulatorが残る。これが、リストをreduceした結果となる。

まずは、fold関数を見てみよう。foldはleft fold関数とも言う。これはリストの要素を左から順にfoldする。binary functionは、まずリストの先頭の要素と初期値に適用される。すると、新しいaccumulatorが返されるので、binary functionはそれをパラメータとして受け取り、またaccumulatorを返し、...というのを繰り返す。

では、催奇を使う代わりにfoldを使って、`sum`を実装してみよう。

    sum' :: (Num a) => [a] -> a
    sum' xs = foldl (\acc x -> acc + x) 0 xs

`[1,2,3]`をテストしてみる。

    ghci> sum' [3,5,2,1]
    11

foldlがどのように動作するのか追跡してみよう。まず、`\acc x -> acc + x`というのがbinary functionとなる。`xs`は対象のリストであり、`0`は初期値で、この値からfoldが開始される。まず、`ac`には0が、`x`には3が与えられ、最初のbinary funcitonがcallされる。`0 + 3`は`3`だから、次の段階では`ac`に`3`が与えられることになる。次の段階では、`ac`に`3`が、`x`にはリストから取り出された値である`5`が与えられた状態となる。続けると、`8`が計算した結果となるから、次の`ac`には`8`が与えられることになる。こうして、最終的には`ac`に`10`が、`x`に`1`が与えられた状態となり、`11`が得られる。おめでとう、これでfoldは完了だ。

このプロフェッショナルな図は(冗談)は、foldlが動作するさまを順番に説明したものだ。緑色の部分が`ac`に相当する。リストが左の要素から順に消費されているのが読み取れるだろう。

いやいや、ちょっとまってほしい、関数のカリー化を考慮すれば、もっとシンプルにこの関数を実装できるはずだ。

    sum' :: (Num a) => [a] -> a
    sum' = foldl (+) 0

`\x y -> x + y`というラムダは、`+`と全く同じだ。関数`foldl (+) 0`というのはリストを受け取る関数になるから、`xs`という変数を用意する必要はなくなるのだ。カリー化のおかげで、一般的な関数`foo a = bar b a`は、`foo = bar b`のように省略することができる。

とにかく、right foldの話に進む前に、他の関数を定義してみよう。`elem`関数がどんなものかは、よく知っていると思うが、foldを使ってもう一度この関数を実装してみよう。

    elem' :: (Eq a) => a -> [a] -> Bool
    elem' y ys = foldl (\acc x -> if x == y then True else acc) False ys

ちょーっと待った! ちょ基地もaccumulatorも真偽値になっているけど、これはどういうことなんだ。accumulatorもfoldlの結果も、どちらもおなじになる。初期値に何を渡せばいいのかわからない場合の方法がある。`False`から始めるという方法だ。Falseであると仮定するのだ。空のリストに対するfoldlも同様に、初期値と同じ空のリストとなる。いま取り出した要素が目的の要素か判定する。目的の要素であればaccumulatorとしてTrueを返す。そうでなければ、accumulatorを変化させない。前の段階の結果がFalseであれば、そのaccumulatorが引き継がれることになる。そして、それがTrueの場合も引き継がれる。

right foldはleft foldによく似ているが、accumulatorにわたされる要素が右から順番に取り出されるという違いがある。つまり、left foldのbinary functionは、accumulatorをひとつ目の引数、いまの値を2つめの引数として受け取るが、right foldはいまの値を一つ目の引数、accumulatorを2つめの引数として受け取る。accumulatorを受け取る順番から、right foldが右から順に要素を取り出すことになる理由がわかるだろう。

もちろん、この関数はleft foldを用いて実装することもできる。たとえば、map' f xs = foldl (\acc x -> acc ++ [f x]) [] xs`というのは、`:`より`++`を使うほうがわかりやすいだろう。つまり、right foldはリストから新しいリストを得る場合に使うのが一般的だ。

accumulatorの値から、foldrの結果がどんなものでも構わないことが分かるだろう。数値やリスト、真偽値など、なんでも良い。ここでは、`map`関数をright foldを使って実装する。accumulatorはリストになるし、返されるのもリストになる。というわけで、初期値は空のリストから始めることに仕様。

    map' :: (a -> b) -> [a] -> [b]
    map' f xs = foldr (\x acc -> f x : acc) [] xs

たとえば、リスト`[1,2,3]`に対して、`(+3)`をマッピングすると、その順番は右からとなる。　最後の要素は`3`だから、`+3`を適用すると結果として`6`が得られる。そして、`6`をaccumulatorとして空のリスト`[]`の先頭に追加する。`6:[]`は`[6]`だから、accumulatorは`[6]`となる。次は`2`に対して`+3`を適用するから、結果の`5`をリスト`[6]`と連結して`5:[6]`だから、accumulatorは`[5,6]`となる。最後に`1`に対して`+3`を適用して、結果の`4`とリスト`[5,6]`を連結した結果の`[4,5,6]`が得られる。

もちろん、これはright foldの代わりにleft foldを使っても同じことが実現できる。実際に定義するとしたら、`map' f xs = foldl (\acc x -> acc ++ [f x]) [] xs`となるだろう。ただ、リストを連結する関数`++`より関数、`:`のほうが扱いやすいから、リストから何か新しいリストを作るときはright foldを使うのが一般的だ。

たとえば、リストを反転させたい場合は、left foldで行うのと逆のことをright foldで行えばいい。ただ、そのひつようがない場合もある。left foldを使っても、right foldを使っても、同じ実装になる関数がある。

left foldとright foldの大きな違いのひとつは、無限リストに対するものだ。無限リストは、リストの大きさが無限だから最後の要素、というものが存在しない。従って、無限リストの範囲を区切って部分的なリストを取り出してから、最初の要素までリストをfoldすることになる。ただし、left foldの場合は、どれが最後の要素なのか判断できないので、やはりright foldと同様に、無限リストに対する操作の前には、範囲を指定して部分的なリストとして取り出しておく必要がある。

foldは、受け取ったリストの各々の要素に対して何か操作をして結果を返す関数を実装するときに役立つ。リストをトラバースしようとしているなら、foldを活かせるチャンスだ。`map`や`filter`に加えて、foldはfunctional programmingが最もその効果を発揮する一例だ。

さて、`foldr1`と`foldl1`を紹介しよう。唯一異なるのは、foldr`や`foldl`では初期値を指定する必要がない、というところだ。これらの関数は、リストの先頭の要素、あるいは末尾の要素を初期値とみなして、次の要素に対してfoldを行う。つまり、関数`sum`は、`sum = foldl1 (+)`と実装できる。ただし、foldされるリストは少なくとも1つの要素を持つ必要があるから、空のリストを与えるとランタイムエラーとなる。一方、`foldr`と`foldl`は、空のリストにたいしてfoldづることができる。foldが空のリストに対して、どのように動作するか考えてみよう。定義しようとしている関数が、空のリストを受け取る必要がなければ`foldr`か`foldl`を選択するのが理にかなっているだろう。

いかにfoldが強力か示すために、いくつか標準ライブラリ関数を自分で定義してみる。

    maximum' :: (Ord a) => [a] -> a
    maximum' = foldr1 (\x acc -> if x > acc then x else acc)

    reverse' :: [a] -> [a]
    reverse' = foldl (\acc x -> x : acc) []

    product' :: (Num a) => [a] -> a
    product' = foldr1 (*)

    filter' :: (a -> Bool) -> [a] -> [a]
    filter' p = foldr (\x acc -> if p x then x : acc else acc) []

    head' :: [a] -> a
    head' = foldr1 (\x _ -> x)

    last' :: [a] -> a
    last' = foldl1 (\_ x -> x)

`head`はパターンんマッチでも実装できるが、ここでは例を示すためにfoldを使って実装した。特に`reverse`の定義は、かなり賢いと思うね。最初は空のリストからはじめて左の要素から結果となるリストの戦闘に追加していく。すると、最終的にはリストを反転させることになる。ラムダ`\acc x -> x : acc`というのは、パラメータを入れ替えているだけだ。だから、この`reverse`関数は、`flip`を使って定義することもできる。

right foldとleft foldを説明する他の方法は、こうだ。まず、`z`を初期値とするbinary function、`f`について考えよう。right foldの場合、`[3,4,5,6]`というリストをfoldするということは、`f 3 (f 4 (f 5 (f 6 z)))`をしていることになる。`f`は、リストの最後の要素と`z`を受け取り、その結果を次の`f`がパラメータとして受け鳥、その結果をッ次の`f`がパラメータとして受け取り、...というのを繰り返す。

たとえば、`f`として`+`を与えれば、`3 + (4 + (5 + (6 + 0)))`を計算した結果が得られる。prefix functionとして書き表すなら、、`(+) 3 ((+) 4 ((+) 5 ((+) 6 0)))`となる。

同様に、left foldの場合は、binary functionとして`g`を受け取る場合、`g (g (g (g z 3) 4) 5) 6`を求めることになる。たとえば、`flip (:)`をbinary functionとして、空のリスト`[]`をaccumulatorとしてleft foldに与えた場合、`flip (:) (flip (:) (flip (:) (flip (:) [] 3) 4) 5) 6`を求めることになる。もちろん、ご想像の通り結果は`[6,5,4,3]`となる。

`scanr`と`scanl`は、`foldr`と`foldl`と同じ働きをするが、計算途中の様子をリストとして返す関数だ。もちろん、`foldr1`と`foldl1`に類似した`scanr1`と`scanl1`もある。

    ghci> scanl (+) 0 [3,5,2,1]
    [0,3,8,10,11]
    ghci> scanr (+) 0 [3,5,2,1]
    [11,8,3,1,0]
    ghci> scanl1 (\acc x -> if x > acc then x else acc) [3,4,5,3,7,9,2,1]
    [3,4,5,5,7,9,9,9]
    ghci> scanl (flip (:)) [] [3,2,1]
    [[],[3],[2,3],[1,2,3]]

`scanl`を使った場合、その結果は`scanr`の結果の先頭の要素が、結果のリストの末尾の要素となる。

scanは、foldを使った関数を実装するとき、その進行状況を監視するのに使われる。では、自然数の平方根の内、それらを合計していった結果が1000を超えないとき、その要素数はいくつになるか、というのを求めてみよう。

まず、すべての自然数の平方根を得るために、`map sqrt [1..]`を求める。そして、これらの合計を求めるにはfoldすればOKだ。しかし、今回はその途中の様子を知りたいので、foldではなくscanを使う。scanが完了すると、1000以下となる合計の値がいくつ存在するか、というのが得られる。`sqrt 1`は`1`だから、最初のscan結果は、`1`となるだろう2番目の結果は、その結果に`sqrt 2`を加えた結果、つまり`1 + (sqrt 2)`となるだろう。3番目の結果は、その結果に`sqrt 3`を加えた結果になるだろう。そして、結果が1000を超えた時点で、それまでの結果を取り出せば、求めていた答えとなる。

    sqrtSums :: Int
    sqrtSums = length (takeWhile (<1000) (scanl1 (+) (map sqrt [1..]))) + 1
    ghci> sqrtSums
    131
    ghci> sum (map sqrt [1..131])
    1005.0942035344083
    ghci> sum (map sqrt [1..130])
    993.6486803921487

無限リストに対しては`filter`は使えないので、ここでは、`takeWhile`をその代わりとして使用している。この例では、リストは昇順に並んでいるから、最初に合計が1000を超えた時点で、その無限リストを切り取ることになる。



## Function application with $ - $を使った関数適用

さて、次は`$`関数についてだ。これは、function applicationとも呼ばれる。なにはともあれ、まずは`$`がどのように定義されているか調べよう。

    ghci> :t ($)
    ($) :: (a -> b) -> a -> b

なんだこれ。この関数の用途は何なんだ?

これは、ただのfunction applicationに見えるが、実は違う。通常のfunction applicationは、関数とパラメータの間にスペースを置くことで適用され、その優先度は最高となるが、この関数は逆に、優先度が最も低くなる。

通常は左から順に適用されるので関数適用`f a b c`というのは、`(((f a) b) c)`という意味になるが、関数`$`は右から順に適用される。

`$`の使い方は分かったけど、これの何が便利なんだ?

まず、`map sqrt [1..130])`というexpressionを例に考えてみよう。`$`の優先度は最も低いから、先ほどのexpressionは、`sum $ map sqrt [1..130]`と書きなおすことができる。キー入力の手間を省けるわけだ。`$`に出くわすとその右側のexpressionは、左側の関数にパラメータとして適用される。では、`sqrt 3 + 4 + 9`というのはどうだろう?これは、3の平方根に4と9を足す、という意味になる。もし、`3 + 4 + 9`に対して平方根を求めたい場合は、`sqrt (3 + 4 + 9)と記述するか、または、`$`の優先度が最も低いから、`sqrt $ 3 + 4 + 9`と記述することができる。`$`は他のどのoperatorよりも優先度が低いから、`$`をexpressionの前に置くだけで、expressionの両端をかっこで包むという手間を省ける。

では、`sum (filter (> 10) (map (*2) [2..10]))`というexpressionはどうだろう? `$`はright-associativeだから、`f (g (z x))`というのは、`f $ g $ z x`というのと等しい。つまり、`sum (filter (> 10) (map (*2) [2..10]))というのは、`sum $ filter (> 10) $ map (*2) [2..10]`というように書きなおすことができる。

`$`がfunction applicationとして扱われるのは、expressionからかっこを取り除くときに、そう扱われる必要がある体。これにより、例えば関数のリストに対して、function applicationをマッピングできる。

    ghci> map ($ 3) [(4+), (10*), (^2), sqrt]
    [7.0,30.0,9.0,1.7320508075688772]



## Function composition - 関数合成

数学の世界では、function compositionは、$(f * x)(x) = f(g(x))$のように定義される。`g)(x) = f(g(x)),`というのは、2つの関数を合成して、ひとつの新しい関数にすることを意味している。そして、その関数に`x``を与えることは、`g(x)`の結果に対して、`f`をcallすることと同じである、というのを意味している。
`x`は`g(x)`

Haskellでは、関数合成は、同じように行える。関数合成は、`.`で関数を連結することで行える。

    ghci> :t (.)
    (.) :: (b -> c) -> (a -> b) -> a -> c

type declarationに注目してほしい。`f`が受け取るパラメータのtypeは、`g`が返す値のtypeと同じである必要がある。そして、合成された関数も、`f`と`g`のtypeと同じtypeにする必要がある。たとえば、`negate.(*3)`はパラメータを受け取り、それに3をかけたものに`-1`をかけた結果尾を返す。

関数合成の便利なところは、他の関数に渡すための関数を即席で作れる、というところだ。もちろんラムダを使っても実現できるが、関数合成はそれより手軽でわかりやすい。たとえば、数値で構成されたリストの要素をすべて負の数にする、というのを試してみよう。一度`abs`でそれぞれの絶対値を求めてから負の数にする、というのが一つの方法だ。

    ghci> map (\x -> negate (abs x)) [5,-3,-6,7,-3,2,-19,24]
    [-5,-3,-6,-7,-3,-2,-19,-24]

このようにラムダを使う、という方法もあるが、このラムダが意味するところは`.`を使って関数合成したのと全く同じだ。

    ghci> map (negate . abs) [5,-3,-6,7,-3,2,-19,24]
    [-5,-3,-6,-7,-3,-2,-19,-24]

すばらしい。そして、関数合成は、right-associativeだから、`.`を使って、関数をその場で次々に合成することができる。たとえば、`f (g (z x))`というexpressionは、`f.g z x`というのと等しい。これを覚えたうえで、例えば次の関数を見てほしい。

    ghci> map (\xs -> negate (sum (tail xs))) [[1..5],[3..6],[1..7]]
    [-14,-15,-27]

これを書き直すと、こうなる。

    ghci> map (negate . sum . tail) [[1..5],[3..6],[1..7]]
    [-14,-15,-27]

ところで、複数のパラメータを受け取る関数の関数合成はどうなるんだろう? もし、そのような関数で関数合成がしたい場合は、その関数がひとつのパラメータを受け取る関数になるまで部分適用してから、関数合成をする必要がある。

たとえば、`sum (replicate 5 (max 6.7 8.9))` というのは書き直しができて、`(sum . replicate 5 . max 6.7) 8.9`または、`sum .replicate 5 . max 6.7 $ 8.9`という記述ができる。

ここで何が起きているかというと、まず、`max 6.7`という関数を受け取り、`replicate 5`に適用させた関数が作られる。そして、その結果を`sum`に適用させて、関数合成が完了する。これでパラメータを一つ受け取る関数が出来上がったので、最後に、その関数に`8.9`を渡してcallする。ここまで複雑な説明をしてしまったが、この関数は、`8.9`を`max`に適用した結果を、`replicate 5`に適用して、最後にその合計を求めるため、`sum`に適用する、という読み取り方をするのが普通だ。

例示した2番目の関数合成のexpressionを、ドット`.`の代わりにかっこを使って書きなおすとするなら、expressionの右はじにあるパラメータを、まずは`$`の後ろ、一番深くにある関数に与えて、それから、残りの関数をパラメータがひとつ足りていない状態のまま並べていき、最後にそれらをドット`.`で連結していけば、関数合成の完成となる。たとえば、`replicate 100 (product (map (*3) (zipWith max [1,2,3,4,5] [4,5,6,7,8])))`というのは、`replicate 100 . product . map (*3) . zipWith max [1,2,3,4,5] $ [4,5,6,7,8]`のように書きなおすことができる。もし、関数が3つ以上の閉じカッコで終わっているなら、それは関数合成を使って書き直せるチャンスだ。

関数合成の使いみちとしては、他に`point free`あるいは`pointless`とよばれる記述をするときに使われる。先程定義した関数を例に説明しよう。

    sum' :: (Num a) => [a] -> a
    sum' xs = foldl (+) 0 xs

`xs`は両サイドに露出している。しかし、カリー化のおかげで、`foldl (+) 0`というのがリストを受け取る関数を作り出すことになるから、両サイドの`xs`というのを省略することができる。　たとえば、`sum' = foldl (+) 0`のような関数は、point freeで記述されていると言える。

では、次の関数をpoint freeで記述するとどうなるだろう。

    fn x = ceiling (negate (tan (cos (max 50 x))))

右側の`x`は省略することができない。関数のbodyにある`x`はその後ろにかっこが続いている。このため、`(max 50)`が意味を成さなくなってしまう。この関数には余分なところがない。

ここでできるのは、`fn`を関数の合成として書き直す、という方法だ。

    fn = ceiling . negate . tan . cos . max 50

すばらしい。 多くの場合、point freeで記述したほうがより読みやすくかつ完結になる。なぜなら、データがどのように扱われるかを考える代わりに目的の結果を返す関数をどのように合成するかを考えることに集中できるからだ。

関数合成は、かんたんな関数を組み合わせて複雑な関数に仕立てる、接着剤のようなものだ、と考えるのがいいだろう。しかし、point freeで関数を記述しようとすると、読みやすさを失って、複雑なものになってしまう。長い関数合成の連鎖を作るのは、複雑さを回避してpoint freeの恩恵をうけるためだ。

ただ、これに対して`let`を使って、解決したい問題を小さな問題に分割して、それらの答えを求めたうえで、答えの断片をまとめ上げて最終的な答えとする方法もあり、巨大な関数合成の連鎖を作る代わりに、小さな問題を解決する関数の集まりを定義するというのも一つの方法ではある。

さて、maps and filtersの商では、1000未満の間は、2乗した結果が奇数になるものを合計し続けて、その結果を得る、という関数を定義した。この問題を個別の関数に切り出して答えを求めようとすると、たとえば以下のようになるだろう。

    oddSquareSum :: Integer
    oddSquareSum = sum (takeWhile (<10000) (filter odd (map (^2) [1..])))

関数合成の楽しさを伝えるべく、この関数を定義し直すと、こうなる。

    oddSquareSum :: Integer
    oddSquareSum = sum . takeWhile (<10000) . filter odd . map (^2) $ [1..]

しかし、これにはもっと読みやすくできる余地が残されている。こんなふうに書けるだろう。

    oddSquareSum :: Integer
    oddSquareSum =
        let oddSquares = filter odd $ map (^2) [1..]
            belowLimit = takeWhile (<10000) oddSquares
        in  sum belowLimit

コードゴルフ大会に出場する場合を除いて、自分や他人のためにも関数合成を用いてより読みやすい関数を定義しよう。

