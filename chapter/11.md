---
title: "Functors, Applicative Functors and Monoids - ファンクタと適用可能なファンクタ、そしてモノイド"
layout: chapter
---



Haskellの純粋さ、高階関数、パラメータ化された代数的データ型、そして型クラスの組合せが、ポリモーフィズムを他の言語と比較してもより高度なレベルで実装可能にしてくれる。型が巨大な改装に属しているということを考える必要はないのだ。その代わり、型がどのように振る舞うか、について考える。そして、その型を適切な型クラスに接続する。たとえば、`Int`型は様々なものとして振る舞える。等しさが比較できるもの(`Eq`)、順番を持つもの(`Ord`)、列挙できるもの(`Enum`)などとして振る舞える。

そして、型クラスは開かれている。これは、我々が、独自のデータ型を定義できることを意味する。定義した型がどのように振る舞うのかを考え、振る舞いを定義している型クラスへとその型を接続する。また、コレに加えて、Haskellの素晴らしい型システムにより、型宣言を知るだけで、ある関数がどのような関数であるか、より多くのことを知ることができる。それから、一般的で抽象的な振る舞いについて定義する型クラスについても我々が独自に定義できる。我々は既に、2つのものが等しいとみなせるかを判定する、あるいは2つのものを何らかの順番に基づいて比較するという型クラスを見てきた。これらはかなり抽象的で、振る舞いもエレガントだ。しかし、我々の人生の大半をこれらを扱うことに費やしてきたから、これらが何か特別なものである、とは考えたりしない。また、少し前には、ファンクタについて触れた。基本的に、ファンクタとはマッピングされるもの、のことだ。これは、まだ声質が抽象的なものを型クラスが表現できることを示す、格好の例だ。この章では適用可能なファンクタ(appricative functor)と呼ばれる、ちょっとだけ協力で役に立つファンクタについて詳しく見ていこう。それから、モノイド(monoid)という、靴下のようなものも見ていく。



## Functors redux - ファンクタ、再び

<img src="//s3.amazonaws.com/lyah/frogtor.png" alt="挿絵 frogs dont even need money" class="img-right">

ファンクタについては前の節で少しだけ触れた。もし、まだ読んでいないのであれば、時間のあるときにその節をちら見するくらいはしたほうが良いかもしれない。あるいは、もう読んだことにしてしまおう。

それでは、軽くおさらいしよう。ファンクタとは、リストや`Maybe`、ツリーなど、マッピングされることが可能なもの、のことだ。Haskellでは、これらは`Functor`という型クラスで表現され、`Functor`は、1つの型クラスメソッド、`fmap`のみを持ち、その型は、`fmap :: (a -> b) -> f a -> f b`となる。これは、`a`を受け取り`b`を返す関数と、箱のなかに`a`を1つ(あるいは複数)入れて渡してくれたら、箱のなかに`b`を1つ(あるいは複数)入れて返すよ、というのを意味している。言ってみれば、箱のなかに入った要素に関数を適用するようなものだ。

ここで、アドバイスを一言。箱を使った例えは、直感的な例えとして使われる。ファンクタの働きを説明するのにも使ったこの例えは、後で、適用可能なファンクタやモナドに対しても使う。この例えは、まずファンクタを理解するためのものとしては問題ないといえる、なぜなら。箱に例えるというのは真実を含んでいて、その考えを拡張できるファンクタもあるので、全く字面通りに受け取らなくてよい。ファンクタをより正確な用語で例えるなら、計算の文脈(computational context)、となるだろう。文脈、というのは、ある計算が値を持つか、あるいは失敗する(`Maybe`や`Either`になる、あるいはその他の値(リストなど)になるかもしれない、ということを表す。

もし、`Functor`のインスタンスとなる型コンストラクタを作りたければ、`* -> *`というkindを持たなくてはならない。これは、型パラメータとして、確実に具体的な型を1つ受け取るということを意味する。たとえば、`Maybe`はインスタンスになることができる。なぜなら、1つの型パラメータを受け取って、`Maybe Int`や`Maybe String`などの具体的な型を生成するからだ。もし、型コンストラクタが`Either`のように2つのパラメータを受け取る場合、1つの型パラメータのみを受け取るようになるまで、その型コンストラクタを部分適用しなくてはならない。つまり、`instance Functor Either where`というのはかけないが、`instance Functor (Either a) where`とすることはできる。もし、`fmap`が`Either a`に限定されていたら、`fmap`の方宣言は、`fmap :: (b -> c) -> Either a b -> Either a c`となるだろう。見ての通り、`Either`の部分が固定されている。`Either a`は1つのパラメータしか受け取らないのに対して、`Either`は2つ受け取るから、`fmap :: (b -> c) -> Either b -> Either c`というのは意味を成さない。

我々は、ここまで多くの型について学んできた。そして、`[]`、`Maybe`、`Either a`、我々が作った`Tree a`などの型コンストラクタは、実際`Functor`のインスタンスとなっている。また、これらに対して関数がどのようにマッピングできるのか、についても見てきた。この節では、ファンクタのインスタンスである`IO`と`(<>)`について見ていく。

たとえば、ある値が、`IO String`という型を持っているとしたら、それは、実行されると実世界へでかけて何らかの文字列を持って帰ってくるというI/Oアクションが結果として生み出されることを意味する。`<-`は、`do`シンタックスの中で、その結果を名前に束縛するのに使う。以前、I/Oアクションは、実世界へでかけて、何らかの値が入った状態で戻ってくる箱のようなものだ、と言った。持ってきてほしいものを思い描いたら、その後は、戻ってくる値を`IO`で包む必要がある。では、この箱に例えることを使って、`IO`がファンクタとして振る舞うことを確認してみよう。

さて、I/Oが`Functor`のインスタンスであるかを確認しよう。I/Oアクションに対して`fmap`をマッピングすると、そのI/Oアクションは同じことをするが、結果の値には関数が適用されていることを期待する。

    instance Functor IO where
        fmap f action = do
            result <- action
            return (f result)

I/Oアクションに対してマッピングして得られた何らかの結果は、I/Oアクションになる。つまり、`do`シンタックスを使って、2つのI/Oアクションを一つにまとめることができる。`fmap`の実装のために。最初に元のI/Oアクションを実行して、その結果に対して関数`result`を呼ぶというI/Oアクションを作る必要がある。つまり、`return (f result)`をする。`return`は、御存知の通り、I/Oアクションを作る関数だ。この関数は何もしないが、その結果を表す。`do`ブロックが生成するアクションは、常に最後に実行されるアクションの結果の値を保持する。実際には何もしない`return`を使ってI/Oアクションを作るのは、`f result`が新しいI/Oアクションの結果を表すからだ。

とりあえず触ってみれば、直感が働くかもしれない。実際、単純で簡単だからだ。以下のコードを見てほしい。

    main = do line <- getLine
              let line' = reverse line
              putStrLn $ "You said " ++ line' ++ " backwards!"
              putStrLn $ "Yes, you really said" ++ line' ++ " backwards!"

ユーザーになにか1行入力するように求めて、入力されたものを反転して表示する。これは、、`fmap`を使って書き直すことができる。

    main = do line <- fmap reverse getLine
              putStrLn $ "You said " ++ line ++ " backwards!"
              putStrLn $ "Yes, you really said" ++ line ++ " backwards!"

<img src="//s3.amazonaws.com/lyah/alien.png" alt="挿絵 w00ooOoooOO" class="img-left">

たとえば、`"halb"`という結果を得るために`"blah"`に対して`fmap reverse`をするように、`getLine`に対しても`fmap reverse`することができる。`getLine`は`IO String`という型を持ち、これに対するマッピングは、現実の世界へでかけて、1行を取得してから、その結果に対して`reverse`を適用するI/Oアクションとなる。Maybeという箱のなかの何かに対して関数を適用できるように、IOという箱のなかにある何かに対しても関数を適用できる。ただし、現実の世界へ何かをとりに出かける。ただし、IOの場合は何かを取得するために現実の世界へ出かける必要がある。そして、その何かを`<-`を使って名前に束縛する。すると、その名前は既に`reverse`が適用された結果を反映している。

`fmap (++"!") getLine`というI/Oアクションは、単なる`getLine`のように振る舞うが、その結果には常に`"!"`が付加されている。

もし、`fmap`の型が`IO`に限定されていたとしたら、`fmap :: (a -> b) -> IO a -> IO bという型になるだろう。`fmap`は、関数とI/Oアクションを受け取り、中味に対して関数が適用されていることを除いて、古いほうと似たような新しいI/Oアクションを結果として返すだろう

もし、I/Oアクションの結果を名前に束縛してから、その結果に対して関数を適用した結果を別の名前に束縛しようとしているのなら、コードが綺麗になるので`fmap`を使うことを考慮に入れてほしい。もし、複数の変換をファンクタの中にあるデータに対して適用したいという場合は、ラムダ関数を作るか、あるいは、理想的には関数合成を使ってコード全体から使える独自の関数を定義すると良い。

    import Data.Char
    import Data.List
    
    main = do line <- fmap (intersperse '-' . reverse . map toUpper) getLine
              putStrLn line
    $ runhaskell fmapping_io.hs
    hello there
    E-R-E-H-T- -O-L-L-E-H

おそらく理解していると思うが、`intersperse '-' .reverse . map toUpper`は、受け取った文字列に対して`toUpper`をマッピングし、その結果に対して`reverse`を適用してから`intersperse `を適用するという関数だ。これは、`(\xs -> intersperse '-' (reverse (map toUpper xs)))`と書くのと同じだが、こっちのほうが綺麗だ。

すでに扱ってきたのに、まだ気づいていないその他のファンクタのインスタンスとしては、`(->)`がある。ふむ、今あなたは混乱したと思う。`->`は一体何をするんだっけ? たとえば、`r -> a`という関数の型は、`2 + 3`が`(+) 2 3`と書けるように、`(->) r a`と書きなおすことができる。ところで、`(->) r a`を見た時、少し違った見方をすれば、`Either`のように2つの型パラメータを受け取る型コンストラクタのようにも見えるかもしれない。しかし、思い出してほしい。厳密には、型コンストラクタは1つの型パラメータを受け取る必要がある。このおかげで、ファンクタのインスタンスになれるのだ。これにより、`(->)`はファンクタのインスタンスとすることができない。しかし、部分適用して`(->) r`とすれば何の問題もない。もし、型コンストラクタのシンタックスがセクションを使って部分適用できるとしたら、(たとえば、セクションを使って`+`を部分適用して`(2+)`としたものは、`(+) 2`というのと等しくなるように。)`(->) r`を`(r ->)`として書くことができる。では、関数はどうやってファンクタになるのか? そうだね、では、`Control.Monad.Instances`にある実装がどうなっているかを見てみよう。

通常、何かを受け取って何かを返す関数は、`a -> b`と記す。これは、型変数の部分に違う文字を使っているだけなので、`r -> a`としても同じことになる。

    instance Functor ((->) r) where
        fmap f g = (\x -> f (g x))





WIP



## Applicative functors - 適用可能なファンクタ

WIP



## The newtype keyword - newtypeキーワード

WIP



## Monoids - モノイド

WIP

