---
title: "Functors, Applicative Functors and Monoids - ファンクタと適用可能なファンクタ、そしてモノイド"
layout: chapter
---



Haskellの純粋さ、高階関数、パラメータ化された代数的データ型、そして型クラスの組合せが、ポリモーフィズムを他の言語と比較してもより高度なレベルで実装可能にしてくれる。型が巨大な改装に属しているということを考える必要はないのだ。その代わり、型がどのように振る舞うか、について考える。そして、その型を適切な型クラスに接続する。たとえば、`Int`型は様々なものとして振る舞える。等しさが比較できるもの(`Eq`)、順番を持つもの(`Ord`)、列挙できるもの(`Enum`)などとして振る舞える。

そして、型クラスは開かれている。これは、我々が、独自のデータ型を定義できることを意味する。定義した型がどのように振る舞うのかを考え、振る舞いを定義している型クラスへとその型を接続する。また、コレに加えて、Haskellの素晴らしい型システムにより、型宣言を知るだけで、ある関数がどのような関数であるか、より多くのことを知ることができる。それから、一般的で抽象的な振る舞いについて定義する型クラスについても我々が独自に定義できる。我々は既に、2つのものが等しいとみなせるかを判定する、あるいは2つのものを何らかの順番に基づいて比較するという型クラスを見てきた。これらはかなり抽象的で、振る舞いもエレガントだ。しかし、我々の人生の大半をこれらを扱うことに費やしてきたから、これらが何か特別なものである、とは考えたりしない。また、少し前には、ファンクタについて触れた。基本的に、ファンクタとはマッピングされるもの、のことだ。これは、まだ声質が抽象的なものを型クラスが表現できることを示す、格好の例だ。この章では適用可能なファンクタ(appricative functor)と呼ばれる、ちょっとだけ協力で役に立つファンクタについて詳しく見ていこう。それから、モノイド(monoid)という、靴下のようなものも見ていく。



## Functors redux - ファンクタ、再び

ファンクタについては前の節で少しだけ触れた。もし、まだ読んでいないのであれば、時間のあるときにその節をちら見するくらいはしたほうが良いかもしれない。あるいは、もう読んだことにしてしまおう。

それでは、軽くおさらいしよう。ファンクタとは、リストや`Maybe`、ツリーなど、マッピングされることが可能なもの、のことだ。Haskellでは、これらは`Functor`という型クラスで表現され、`Functor`は、1つの型クラスメソッド、`fmap`のみを持ち、その型は、`fmap :: (a -> b) -> f a -> f b`となる。これは、`a`を受け取り`b`を返す関数と、箱のなかに`a`を1つ(あるいは複数)入れて渡してくれたら、箱のなかに`b`を1つ(あるいは複数)入れて返すよ、というのを意味している。言ってみれば、箱のなかに入った要素に関数を適用するようなものだ。

ここで、アドバイスを一言。箱を使った例えは、直感的な例えとして使われる。ファンクタの働きを説明するのにも使ったこの例えは、後で、適用可能なファンクタやモナドに対しても使う。この例えは、まずファンクタを理解するためのものとしては問題ないといえる、なぜなら。箱に例えるというのは真実を含んでいて、その考えを拡張できるファンクタもあるので、全く字面通りに受け取らなくてよい。ファンクタをより正確な用語で例えるなら、計算の文脈(computational context)、となるだろう。文脈、というのは、ある計算が値を持つか、あるいは失敗する(`Maybe`や`Either`になる、あるいはその他の値(リストなど)になるかもしれない、ということを表す。

もし、`Functor`のインスタンスとなる型コンストラクタを作りたければ、`* -> *`というkindを持たなくてはならない。これは、型パラメータとして、確実に具体的な型を1つ受け取るということを意味する。たとえば、`Maybe`はインスタンスになることができる。なぜなら、1つの型パラメータを受け取って、`Maybe Int`や`Maybe String`などの具体的な型を生成するからだ。もし、型コンストラクタが`Either`のように2つのパラメータを受け取る場合、1つの型パラメータのみを受け取るようになるまで、その型コンストラクタを部分適用しなくてはならない。つまり、`instance Functor Either where`というのはかけないが、`instance Functor (Either a) where`とすることはできる。もし、`fmap`が`Either a`に限定されていたら、`fmap`の方宣言は、`fmap :: (b -> c) -> Either a b -> Either a c`となるだろう。見ての通り、`Either`の部分が固定されている。`Either a`は1つのパラメータしか受け取らないのに対して、`Either`は2つ受け取るから、`fmap :: (b -> c) -> Either b -> Either c`というのは意味を成さない。

我々は、ここまで多くの型について学んできた。そして、`[]`、`Maybe`、`Either a`、我々が作った`Tree a`などの肩コンストラクタは、実際`Functor`のインスタンスとなっている。また、これらに対して関数がどのようにマッピングできるのか、についても見てきた。この節では、ファンクタのインスタンスである`IO`と`(<>)`について見ていく。

たとえば、ある値が、`IO String`という型を持っているとしたら、それは、実行されると実世界へでかけて何らかの文字列を持って帰ってくるというI/Oアクションが結果として生み出されることを意味する。`<-`は、`do`シンタックスの中で、その結果を名前に束縛するのに使う。以前、I/Oアクションは、実世界へでかけて、何らかの値が入った状態で戻ってくる箱のようなものだ、と言った。持ってきてほしいものを思い描いたら、その後は、戻ってくる値を`IO`で包む必要がある。では、この箱に例えることを使って、`IO`がファンクタとして振る舞うことを確認してみよう。

さて、I/Oが`Functor`のインスタンスであるかを確認しよう。I/Oアクションに対して`fmap`をマッピングすると、そのI/Oアクションは同じことをするが、結果の値には関数が適用されていることを期待する。

    instance Functor IO where
        fmap f action = do
            result <- action
            return (f result)

I/Oアクションに対してマッピングして得られた何らかの結果は、I/Oアクションになる。つまり、`do`シンタックスを使って、2つのI/Oアクションを一つにまとめることができる。`fmap`の実装のために。最初に元のI/Oアクションを実行して、その結果に対して関数`result`を呼ぶというI/Oアクションを作る必要がある。つまり、`return (f result)`をする。`return`は、御存知の通り、I/Oアクションを作る関数だ。この関数は何もしないが、その結果を表す。`do`ブロックが生成するアクションは、常に最後に実行されるアクションの結果の値を保持する。実際には何もしない`return`を使ってI/Oアクションを作るのは、`f result`が新しいI/Oアクションの結果を表すからだ。

とりあえず触ってみれば、直感が働くかもしれない。実際、単純で簡単だからだ。以下のコードを見てほしい。

    main = do line <- getLine
              let line' = reverse line
              putStrLn $ "You said " ++ line' ++ " backwards!"
              putStrLn $ "Yes, you really said" ++ line' ++ " backwards!"

ユーザーになにか1行入力するように求めて、入力されたものを反転して表示する。これは、、`fmap`を使って書き直すことができる。

    main = do line <- fmap reverse getLine
              putStrLn $ "You said " ++ line ++ " backwards!"
              putStrLn $ "Yes, you really said" ++ line ++ " backwards!"

WIP



## Applicative functors - 適用可能なファンクタ

WIP



## The newtype keyword - newtypeキーワード

WIP



## Monoids - モノイド

WIP

