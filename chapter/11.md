---
title: "Functors, Applicative Functors and Monoids - ファンクタと適用可能なファンクタ、そしてモノイド"
layout: chapter
---



Haskellの純粋さ、高階関数、パラメータ化された代数的データ型、そして型クラスの組合せが、ポリモーフィズムを他の言語と比較してもより高度なレベルで実装可能にしてくれる。あなたは、型が巨大な改装に属しているということを考える必要はないのだ。その代わり、型がどのように振る舞うか、について考える。そして、その型を適切な型クラスに接続する。たとえば、`Int`型は様々なものとして振る舞える。等しさが比較できるもの(`Eq`)、順番を持つもの(`Ord`)、列挙できるもの(`Enum`)などとして振る舞える。

そして、型クラスは開かれている。これは、我々が、独自のデータ型を定義できることを意味する。定義した型がどのように振る舞うのかを考え、振る舞いを定義している型クラスへとその型を接続する。また、コレに加えて、Haskellの素晴らしい型システムにより、型宣言を知るだけで、ある関数がどのような関数であるか、より多くのことを知ることができる。それから、一般的で抽象的な振る舞いについて定義する型クラスについても我々が独自に定義できる。我々は既に、2つのものが等しいとみなせるかを判定する、あるいは2つのものを何らかの順番に基づいて比較するという型クラスを見てきた。これらはかなり抽象的で、振る舞いもエレガントだ。しかし、我々の人生の大半をこれらを扱うことに費やしてきたから、これらが何か特別なものである、とは考えたりしない。また、少し前には、ファンクタについて触れた。基本的に、ファンクタとはマッピングされるもの、のことだ。これは、まだ声質が抽象的なものを型クラスが表現できることを示す、格好の例だ。この章では適用可能なファンクタ(appricative functor)と呼ばれる、ちょっとだけ協力で役に立つファンクタについて詳しく見ていこう。それから、モノイド(monoid)という、靴下のようなものも見ていく。



## Functors redux - ファンクタ、再び

<img src="//s3.amazonaws.com/lyah/frogtor.png" alt="挿絵 frogs dont even need money" class="img-right">

ファンクタについては前の節で少しだけ触れた。もし、まだ読んでいないのであれば、時間のあるときにその節をちら見するくらいはしたほうが良いかもしれない。あるいは、もう読んだことにしてしまおう。

それでは、軽くおさらいを。ファンクタとは、リストやMaybe、ツリーなど、マッピングされることが可能なもの、のことだ。Haskellでは、これらは`Functor`という型クラスで表現され、ファンクタは、1つの型クラスメソッド、`fmap`のみを持ち、その型は、`fmap :: (a -> b) -> f a -> f b`となる。これは、`a`を受け取り`b`を返す関数と、箱のなかに`a`を1つ(あるいは複数)入れて渡してくれたら、箱のなかに`b`を1つ(あるいは複数)入れて返すよ、というのを意味している。言ってみれば、箱のなかに入った要素に関数を適用するようなものだ。

ここで、アドバイスを一言。箱を使った例えは、直感的な例えとして使われる。ファンクタの働きを説明するのにも使ったこの例えは、後で、適用可能なファンクタやモナドに対しても使う。この例えは、まずファンクタを理解するためのものとしては問題ないといえる、なぜなら。箱に例えるというのは真実を含んでいて、その考えを拡張できるファンクタもあるので、全く字面通りに受け取らなくてよいからだ。ファンクタをより正確な用語で例えるなら、計算の文脈(computational context)、となるだろう。文脈、というのは、ある計算が値を持つか、あるいは失敗する(MaybeやEitherになる、あるいはその他の値(リストなど)になるかもしれない、ということを表す。

もし、`Functor`のインスタンスとなる型コンストラクタを作りたければ、`* -> *`というkindを持たなくてはならない。これは、型パラメータとして、確実に具体的な型を1つ受け取るということを意味する。たとえば、`Maybe`はインスタンスになることができる。なぜなら、1つの型パラメータを受け取って、`Maybe Int`や`Maybe String`などの具体的な型を生成するからだ。もし、型コンストラクタが`Either`のように2つのパラメータを受け取る場合、1つの型パラメータのみを受け取るようになるまで、その型コンストラクタを部分適用しなくてはならない。つまり、`instance Functor Either where`というのはかけないが、`instance Functor (Either a) where`とすることはできる。もし、`fmap`が`Either a`に限定されていたら、`fmap`の方宣言は、`fmap :: (b -> c) -> Either a b -> Either a c`となるだろう。見ての通り、`Either`の部分が固定されている。`Either a`は1つのパラメータしか受け取らないのに対して、`Either`は2つ受け取るから、`fmap :: (b -> c) -> Either b -> Either c`というのは意味を成さない。

、ここまで多くの型について学んできた。たとえば、`[]`や`Maybe`、`Either a`そして、我々が作った`Tree a`などの型コンストラクタは、実際`Functor`のインスタンスとなっている。また、これらに対して関数がどのようにマッピングできるのか、についても見てきた。この節では、ファンクタのインスタンスである`IO`と`(->)`について見ていく。

たとえば、ある値が、`IO String`という型を持っているとしたら、それは、実行されると実世界へでかけて何らかの文字列を持って帰ってくるというI/Oアクションが結果として生み出されることを意味する。`<-`は、`do`シンタックスの中で、その結果を名前に束縛するのに使う。以前、I/Oアクションは、実世界へでかけて、何らかの値が入った状態で戻ってくる箱のようなものだ、と言った。持ってきてほしいものを思い描いたら、その後は、戻ってくる値を`IO`で包む必要がある。では、この箱に例えることを使って、`IO`がファンクタとして振る舞うことを確認してみよう。

では、I/Oが`Functor`のインスタンスであるかを確認する。I/Oアクションに対して`fmap`をマッピングすると、そのI/Oアクションは同じことをするが、結果の値には関数が適用されていることを期待する。

    instance Functor IO where
        fmap f action = do
            result <- action
            return (f result)

I/Oアクションに対してマッピングして得られた何らかの結果は、I/Oアクションになる。つまり、doシンタックスを使って、2つのI/Oアクションを一つにまとめることができる。`fmap`の実装のために。最初に元のI/Oアクションを実行して、その結果に対して関数`return`を呼ぶというI/Oアクションを作る必要がある。つまり、`return (f result)`をする。`return`は、御存知の通り、I/Oアクションを作る関数だ。この関数は何もしないが、その結果を表す。doブロックが生成するアクションは、常に最後に実行されるアクションの結果の値を保持する。実際には何もしない`return`を使ってI/Oアクションを作るのは、`f result`が新しいI/Oアクションの結果を表すからだ。

実際、単純で簡単だから、とりあえず触ってみれば直感が働くかもしれない。以下のコードを見てほしい。

    main = do line <- getLine
              let line' = reverse line
              putStrLn $ "You said " ++ line' ++ " backwards!"
              putStrLn $ "Yes, you really said" ++ line' ++ " backwards!"

ユーザーになにか1行入力するように求めて、入力されたものを反転して表示する。これは、、`fmap`を使って書き直すことができる。

    main = do line <- fmap reverse getLine
              putStrLn $ "You said " ++ line ++ " backwards!"
              putStrLn $ "Yes, you really said" ++ line ++ " backwards!"

<img src="//s3.amazonaws.com/lyah/alien.png" alt="挿絵 w00ooOoooOO" class="img-left">

たとえば、`"halb"`という結果を得るために`"blah"`に対して`reverse`をするように、`getLine`に対しても`fmap reverse`することができる。`getLine`は`IO String`という型を持ち、これに対するマッピングは、現実の世界へでかけて、1行を取得してから、その結果に対して`reverse`を適用するI/Oアクションとなる。Maybeという箱のなかの何かに対して関数を適用できるように、IOという箱のなかにある何かに対しても関数を適用できるのだ。ただし、IOの場合は何かを取得するために現実の世界へ出かける必要がある。そして、その何かを`<-`を使って名前に束縛する。すると、その名前は既に`reverse`が適用された結果を反映している。

`fmap (++"!") getLine`というI/Oアクションは、単なる`getLine`のように振る舞うが、その結果には常に`"!"`が付加されている。

もし、`fmap`の型が`IO`に限定されていたとしたら、`fmap :: (a -> b) -> IO a -> IO bという型になるだろう。`fmap`は、関数とI/Oアクションを受け取り、中味に対して関数が適用されていることを除いて、古いほうと似たような新しいI/Oアクションを結果として返すだろう

もし、I/Oアクションの結果を名前に束縛してから、その結果に対して関数を適用した結果を別の名前に束縛しようとしているのなら、コードが綺麗になるので`fmap`を使うことを考慮に入れてほしい。また、複数の変換をファンクタという箱の中にあるデータに対して適用したいという場合は、ラムダ関数を作るか、あるいは、理想的には関数合成を使ってコード全体から使える独自の関数を定義するのが良い。

    import Data.Char
    import Data.List
    
    main = do line <- fmap (intersperse '-' . reverse . map toUpper) getLine
              putStrLn line

&nbsp;

    $ runhaskell fmapping_io.hs
    hello there
    E-R-E-H-T- -O-L-L-E-H

おそらく理解していると思うが、`intersperse '-' .reverse . map toUpper`は、受け取った文字列に対して`toUpper`をマッピングし、その結果に対して`reverse`を適用してから`intersperse `を適用するという関数だ。これは、`(\xs -> intersperse '-' (reverse (map toUpper xs)))`と書くのと同じだが、こっちのほうが綺麗だ。

すでに扱ってきたのに、まだ気づいていないその他のファンクタのインスタンスとしては、`(->)`がある。ふむ、今あなたは混乱したと思う。`->`は一体何をするんだっけ? たとえば、`r -> a`という関数の型は、`2 + 3`が`(+) 2 3`と書けるように、`(->) r a`と書きなおすことができる。ところで、`(->) r a`を見た時、少し違った見方をすれば、`Either`のように2つの型パラメータを受け取る型コンストラクタのようにも見えるかもしれない。しかし、思い出してほしい。厳密には、型コンストラクタは1つの型パラメータを受け取る必要がある。このおかげで、ファンクタのインスタンスになれるのだ。これにより、`(->)`はファンクタのインスタンスとすることができない。しかし、部分適用して`(->) r`とすれば何の問題もない。もし、型コンストラクタのシンタックスがセクションを使って部分適用できるとしたら、(たとえば、セクションを使って`+`を部分適用して`(2+)`としたものは、`(+) 2`というのと等しくなるように。)`(->) r`を`(r ->)`として書くことができる。では、関数はどうやってファンクタになるのか? そうだね、では、`Control.Monad.Instances`にある実装がどうなっているかを見てみよう。

通常、何かを受け取って何かを返す関数は、`a -> b`と記す。これは、型変数の部分に違う文字を使っているだけなので、`r -> a`としても同じだ。

    instance Functor ((->) r) where
        fmap f g = (\x -> f (g x))

もし、シンタックス的に可能であれば、これは以下のようにも書ける。

    instance Functor (r ->) where
        fmap f g = (\x -> f (g x))

しかし、このような書き方はできないので、前述の正しいシンタックスで書く必要がある。

ひとまず、`fmap`の型について考えてみよう。`fmap :: (a -> b) -> f a -> f b`となっている。では、この`f`というのを`Functor`のインスタンスとして振る舞う`(->) r`で置き換えるということを想像してみよう。特定のインスタンスに対する`fmap`がどのように振る舞うべきなのかを確認するのだ。すると、`fmap :: (a -> b) -> ((->) r a) -> ((->) r b)`となる。さて、`(->) r a`と`(-> r b)`という型は、普通の関数であるかのように、中置記法で`r -> a`と`r -> b`のように書ける。すると、,`fmap`は`fmap :: (a -> b) -> (r -> a) -> (r -> b)`という型になる。

うーん、わかったぞ。`Maybe`に対する関数のマッピングは、`Maybe`を生成し無くてはならないし、リストに対する関数のマッピングも、リストを生成しなければならないように、関数に対する関数のマッピングも、関数を生成しなければならない。では、この例における`fmap :: (a -> b) -> (r -> a) -> (r -> b)`という型が意味するものは何だろう? そうだね、これは`a`を`b`にする関数と、`r`から`a`にする関数を受け取り、`r`から`b`にする関数を返すことを意味する。さて、何か思い出せたかな? そう、関数合成だ! 我々は`r -> a`の出力を`a -> b`の入力へとパイプして、`r -> b`という関数を得る。これは、まさに関数合成が行おうとしていることだ。もう、上記のインスタンスがどのように定義されているかを見れば、これが単なる関数合成だ、と分かるだろう。このインスタンスを書く別の方法は、以下のとおりだ。

    instance Functor ((->) r) where
        fmap = (.)

これは、関数に対して`fmap`を使うことが明らかに関数合成であることを暴露している。インスタンスがそこに定義されているから`:m + Control.Monad.Instances`して、関数に対するマッピングを試してみよう。

    ghci> :t fmap (*3) (+100)
    fmap (*3) (+100) :: (Num a) => a -> a
    ghci> fmap (*3) (+100) 1
    303
    ghci> (*3) `fmap` (+100) $ 1
    303
    ghci> (*3) . (+100) $ 1
    303
    ghci> fmap (show . (*3)) (*100) 1
    "300"

`fmap`関数は、中置記法でも呼び出せるので`.`との類似性がはっきりする。上記の2行目の入力で、`(*3)`を`(+100)`に対してマッピングした結果は、受け取った入力に対して`(+100)`を呼び出して、さらにその結果に対して`(*3)`を呼び出した結果を返す関数となる。そして、その関数に1を与えて呼び出している。

ところで、箱を使ったたとえはどうなるんだろう? ええと、拡大解釈すれば続けられる。たとえば、`fmap (+3)`を`Just 3`に対して使う場合、`Maybe`は箱であり、その箱の中身に対して`(+3)`をマッピングするというのは容易に想像できるだろう。しかし、`fmap (*3) (+100)`する場合はどうだろう? そうだね、`(+100)`という関数は、その関数の最終的な結果を保持する箱である、とかんがえられる。そう、I/Oアクションが現実世界へでかけて何らかの結果を持ち帰ってくる箱である、と想像できるようにね。`(+100)`に対して`fmap (*3)`を使うと、結果を生成する前に`(+100)`の結果に対して`(*3)`を適用するという別の関数が作成される。これで、`fmap`が関数合成の`.`として振る舞うのかが理解できる。

ある関数が今すぐ役に立たないときに使用される`fmap`は、関数合成であるというのは事実だが、それにしても興味深い。これは我々の心を揺さぶり、いかにして計算というよりある種の箱(`IO`や`(->) r`)がファンクタになるのかを示してくれる。つまり、ある計算に対してマッピングされる関数が返す結果は同じ計算となるものの、返された結果は関数によって変更されたものとなる。

<img src="//s3.amazonaws.com/lyah/lifter.png" alt="挿絵 lifting a function is easier than lifting a million pounds" class="img-right">

さて、`fmap`が従うべき規則についての話へ進む前に、`fmap`の型についてもう一度考えてみよう。`fmap :: (a -> b) -> f a -> f b`となっている。これは`(Functor f) =>`という型の制約を忘れている。しかし、ここではファンクタについて話しているから、`f`が何の略なのかは分かっているので型の制約を取り払って完結にしている。はじめてカリー化された関数について学んだとき、実際には、Haskellにおける全ての関数は1つのパラメータのみを受け取る、と説明した。たとえば、`a -> b -> c`という関数は、`a`という型のパラメータを1つだけ受け取り、`b -> c`という関数を返し、その関数も1つだけパラメータを受け取り`c`を返す。これにより、パラメータが足りていない状態で関数を呼び出すことで、(部分適用とも言う)取り去った部分のパラメータを受け取る関数を得ることになる。(そうすると、関数が複数のパラメータを受け取っているように思える。)つまり、`a -> b -> c`を`a -> (b -> c)`と書きなおせば、カリー化されているのが明確になる。

同じ調子で、`fmap :: (a -> b) -> (f a -> f b)`と書いた場合、`fmap`は、1つの関数とファンクタを受け取り、ファンクタを返す関数ではなく、受け取った関数と似たような新しい関数を返す関数とみなせる。ただし、受け取る関数はパラメータとしてファンクタを受け取り、結果としてファンクタを返す。つまり、`fmap`は`a -> b`という関数を受け取り、`f a -> f b`という関数を返す。これは、関数リフティング(lifting a function)と呼ばれる。では、ghciの`:t`コマンドを使って、この概念を試してみよう。

    ghci> :t fmap (*2)
    fmap (*2) :: (Num a, Functor f) => f a -> f a
    ghci> :t fmap (replicate 3)
    fmap (replicate 3) :: (Functor f) => f a -> f [a]

`fmap (*2)`という式は、数値に対するファンクタ`f`を受け取り、数値に対するファンクタを返す関数だ。そのファンクタというのは、リストや`Maybe`、`Either String`など、何にでもなれる。`fmap (replicate 3)`という式は、あらゆる型のファンクタを受け取り、その型のリストを含むファンクタを返す。

数値に対するファンクタと言ったとき、ファンクタの中に数値が入っているのを想像しただろう。前者はやや誇張気味で技術的には正しく、後者は理解しやすい。

これは、部分適用すればより明確になるので、ghciで`fmap (++"!")`というのを名前に束縛してみよう。

`fmap`は、関数とファンクタを受け取り、その関数をファンクタに対してマッピングしたファンクタを返す関数か、あるいは関数を受け取って、その関数をリフティングしてファンクタを操作できるようにする関数だ、と考えられる。どちらの見方もHaskellにおいては正しく、そして等しい。

`fmap (replicate 3) :: (Functor f) => f a -> f [a]`という型は、どんなファンクタに対しても機能する関数であることを意味する。この関数が行うことは、我々が与えるファンクタによって左右される。たとえば、`fmap (replicate 3)`をリストに対して使えば、リストに対する`fmap`の実装が選択され、`fmap`は単に`map`となる。また、`Maybe a`に対して使えば、`Just`の中味に対して`replicate 3`が適用されるか、`Nothing`であれば`Nothing`のままとなる。


    ghci> fmap (replicate 3) [1,2,3,4]
    [[1,1,1],[2,2,2],[3,3,3],[4,4,4]]
    ghci> fmap (replicate 3) (Just 4)
    Just [4,4,4]
    ghci> fmap (replicate 3) (Right "blah")
    Right ["blah","blah","blah"]
    ghci> fmap (replicate 3) Nothing
    Nothing
    ghci> fmap (replicate 3) (Left "foo")
    Left "foo"

次は、ファンクタの法則について見ていこう。なにかをファンクタにするには、いくつかの法則を満たさなくてはならない。すべてのファンクタは、ある特定の、ファンクタっぽいプロパティや振る舞いを示すことが期待される。それらは確実に、マッピングされることが可能であるもの、のように振る舞わなくてはならない。そして、ファンクタに対する`fmap`の呼び出しは、ファンクタに対して関数をマッピングするか、何もしない。この振る舞いは、ファンクタの法則に定義されている。これら2つのものが、ファンクタのインスタンスが順守しなくてはならないものだ。Haskellが自動的にこれらを強制することはないので、法則を満たしているか自分でテストする必要がある。

ファンクタの第一法則は、ファンクタに対して`id`関数をマッピングすると、結果として返されたファンクタが元のファンクタと同じでなくてはならない、ということを述べている。これをより正確に書くとすれば、`fmap id = id`であることを意味する。つまり、`fmap id`をファンクタに対してマッピングすると、ファンクタに対して`id`を呼び出すのと等しくなる。これは不可欠だ。思い出してほしい。`id`は恒等関数(identity function)であり、受け取ったパラメータを変更せず、そのまま返す。これは、`x -> x`とも書き表せる。ファンクタを、マッピングされることができる何か、という視点で見れば、`fmap id = id`という法則は、些細で自明なことのように思える。

この法則がファンクタの値に対して守られるか見てみよう。

    ghci> fmap id (Just 3)
    Just 3
    ghci> id (Just 3)
    Just 3
    ghci> fmap id [1..5]
    [1,2,3,4,5]
    ghci> id [1..5]
    [1,2,3,4,5]
    ghci> fmap id []
    []
    ghci> fmap id Nothing
    Nothing

ファンクタに対する`fmap`の実装、たとえば`Maybe`の場合を見ると、なぜファンクタの第一法則が守られるのかが分かる。

    instance Functor Maybe where
        fmap f (Just x) = Just (f x)
        fmap f Nothing = Nothing

実装の中で、`id`が`f パラメータ`の役割を担うと想像してみよう。`fmap id`を`Just x`に対して行うと、結果は`Just (id x)`となり、`id`は渡されたパラメータをそのまま返すので、`Just (id x)`が`Just x`であると推論できる。つまり、`Maybe`の値コンストラクタ`Just`に対して`id`をマッピングすれば、同じ値が帰ってくるということが分かる。

`Nothing`という値に対する`id`のマッピングを見てみれば、同じ値が帰ってくるのは明らかだろう。つまり、`fmap`の実装におけるこれら2つの方程式から、`fmap id = id`という法則が保たれることが分かる。

<img src="//s3.amazonaws.com/lyah/justice.png" alt="挿絵 justice is blind, but so is my dog" class="img-left">

第二法則は2つの関数を合成した結果の関数をファンクタに対してマッピングすることは、ファンクタに対して2つの関数の内、最初の関数をマッピングしてから、もう一方の関数をマッピングするのと等しい、ということを言っている。正確に書き表すとすれば、これは`fmap (f . g) = fmap f . fmap g`を意味する。別の方法で書き表せば、どんなファンクタ`F`に対しても`fmap (f . g) F = fmap f (fmap g F)`が保たれることを意味する。

もし、これらのファンクタの法則に従う型を示すことができたら、マッピングなどファンクタとしての基本的な振る舞いを持つ型に頼ることができる。我々はその型に対して`fmap`を使ってマッピングをしても他の何かにはならないことを知っている。そして、それはマッピングされることが可能であるもの、たとえばファンクタとして振る舞う。
ある型に対して第二法則がどのように保たれるかを、`fmap`の実装を見ることで理解できる。
そう、`Maybe`が第一法則に従っているかを確認したのと同じ方法を使って。

もしそうしたければ、`Maybe`がファンクタの第二法則に従っているかを確認することができる。どんな関数でも`Nothing`に対して`fmap`を使えば、`Nothing`が返ってくるから、`Nothing`に対して`fmap (f . g)`をすれば、`Nothing`が得られる。たとえば、`fmap f (fmap g Nothing)`をすれば、同じ理由で`Nothing`が得られる。OK、`Maybe`の値が`Nothing`の場合にファンクタの第二法則が保たれるのは実に単純で、些細な事だ。

では、`Just 何らかの値`の場合はどうだろう? そうだね、`fmap (f . g) (Just x)`をすれば、、`Just ((f . g) x)`として実装されているところから分かるようにそれは、もちろん`Just (f (g x))`となる。もし、`fmap f (fmap g (Just x))`すれば、実装から、`fmap g (Just x)`が`Just (g x)`であることが分かるゆえに、`fmap f (fmap g (Just x))`は、`fmap f (Just (g x))`と等しく、また、実装からも、これがJust (f (g x))`と等しいことが分かる。

この証明があなたを混乱させたとしても、心配する必要はない。関数合成がどのように機能するのかをしっかりと理解しよう。ある型が関数や入れ物のように振る舞うので、これらの法則がどのように守られるのかを直感的に理解することができる。そして、それに対して何種類もの異なる型を試して、その型がたしかに法則を満たしていることを確認することができる。

では、ファンクタのインスタンスとなる型コンストラクタの例を見てみよう。しかし、法則を満たしていないので、本物のファンクタにはなれない。以下のような型があるとしよう。

    data CMaybe a = CNothing | CJust Int a deriving (Show)

このCというのはカウンター(Counter)の略だ。このデータ型は`Maybe a`のものとそっくりだ。ただし、`Just`に相当する部分が1つではなく2つのフィールドを持っている。値コンストラクタ`CJust`の最初のフィールドは常に`Int`となり、2つめのフィールドにはカウンターが入る。2つめのフィールドの型は`a`であり、`a`というのは型パラメータで受け取った型だ。`a`にはもちろん、`CMaybe a`に与える具体的な型によって左右される。直感を働かせるために、この新しい型で遊んでみよう。

    ghci> CNothing
    CNothing
    ghci> CJust 0 "haha"
    CJust 0 "haha"
    ghci> :t CNothing
    CNothing :: CMaybe a
    ghci> :t CJust 0 "haha"
    CJust 0 "haha" :: CMaybe [Char]
    ghci> CJust 100 [1,2,3]
    CJust 100 [1,2,3]

値コンストラクタ`CNothing`を使えば、
フィールドが存在しない。
値コンストラクタ`CJust`を使えば、
最初のフィールドは`Int`であり、2つめのフィールドはどんな型でもよい。
では、これをファンクタのインスタンスにしてみよう。
`fmap`はいつも使うからね。
フィールドが1つになっているから、
関数は2つめのフィールドに適用される。

    instance Functor CMaybe where
        fmap f CNothing = CNothing
        fmap f (CJust counter x) = CJust (counter+1) (f x)


(`CJust`という)
値に対する`fmap`が空の箱を表現しないことと、
その中味に対して関数を適用することはせず、
カウンターを1つ増加させることを除けば、
これは`Maybe`の場合におけるインスタンスの実装のようだ。
ここまで、すべてがクールに思える。
実際に試してみるまでは、

    ghci> fmap (++"ha") (CJust 0 "ho")
    CJust 1 "hoha"
    ghci> fmap (++"he") (fmap (++"ha") (CJust 0 "ho"))
    CJust 2 "hohahe"
    ghci> fmap (++"blah") CNothing
    CNothing

これはファンクタの法則に従っているだろうか? 
もし、法則に従っていないことを確認したければ、
判例を1つ見つければよい。

    ghci> fmap id (CJust 0 "haha")
    CJust 1 "haha"
    ghci> id (CJust 0 "haha")
    CJust 0 "haha"

あっ、ファンクタの第一法則は`id`をファンクタにマッピングすると
`id`をファンクタに対して呼び出した結果とおなじになるのだった。
しかし上記の例を見てみると、
`CMaybe`というファンクタはこれが当てはまらない。
型クラス`Functor`に属しているにもかかわらず、
ファンクタの法則に従っていないから、これはファンクタではない。
もし、誰かが我々の`CMaybe`をファンクタとして使おうとすれば、
ファンクタの法則に従うものと期待するだろう。
しかし、`CMaybe`は従っているように見せかけて、実は従っていない。
つまり、これをファンクタとして使えば、コードに血管が生じるだろう。
ファンクタを使うとき、
最初に幾つかの関数を合成して、
それをファンクタに対してマッピングするのは問題にはならないし、
ファンクタに対して次々と関数をマッピングするのも問題無いだろう。
しかし、`CMaybe`は問題がある。
なぜなら、南海マッピングされたかを追跡しているからだ。
クールじゃないね! 
もし、`CMaybe`をファンクタの法則に従わせるとしたら、
`Int`のフィールドを`fmap`を使った時と同じ状態に保たなくてはならない。

まず最初に、
ファンクタの法則は紛らわしくて不必要に思えるかもしれない。
しかし、両方の法則にしたがう型を見れば、
それがどのように振る舞うのかという前提が得られる。
もし、ある型がファンクタの法則に従うなら、
その型の値に対して`fmap`を呼ぶことは、
その値に対して関数をマッピングすることになる。
それだけだ。
これがコードをより抽象的で拡張性の高いものにしてくれる。
この法則を使うことで、
どんなファンクタに対しても、
振る舞いを推測できるようになり、
関数をファンクタに対して操作できるものにしてくれる。

標準ライブラリにあるファンクタのインスタンスは、すべて法則に従っている。
私を信じないなら、自分でそれを確かめることができる。
それから、あなたがファンクタのインスタンスを作るとき
法則に従っているかを少し時間をかけて確かめてほしい、
それが十分なファンクタであると思案したら、
直感的にプロパティやふるまいが正しいかを調べよう。
共通の部分について、直感的にファンクタの法則に従っているかを判定するのは難しくはないはずだ。
しかし、直感が働かなければ、
常にその実装を1行1行眺めて、
法則が守られているか、
あるいは判例を見つける、ということも可能だ。

ファンクタは、あるコンテキストにおいて値を出力するものだ、という見方もできる。
たとえば、`Just 3`は、コンテキストにおいて`3`という値を出力するか、何も値を出力しないかのどちらかとなる。
`[1,2,3]`は値を3つ、1、2、3というのを出力して、
そのコンテキストは、複数の値があるか、あるいは値がないものとなる。。
`(+3)`という関数は、パラメータとして与えられた値によって出力される値が左右される。

ファンクタを何らかの値を出力するものと考えれば、
ファンクタに対するマッピングは、
値を変化させるために
ファンクタの出力の変形に手を加えていることだ、と考えることができる。
たとえば、`fmap (+3) [1,2,3]`するとき、
`(+3)`という変形を
`[1,2,3]`の出力に対して結びつけて、
どんなときもリストが出力する数値を見てから、
`(+3)`が適用される。
関数に対するマッピングの別の例としては、
`fmap (+3) (*3)`がある。
`(+3)`という変形を、最終的な出力である`(*3)`に結びつけている。
この方法を見ることは、我々に直感を与えてくれて、
`fmap`を使うことがなぜ関数合成になるのか
(`fmap (+3) (*3)`は`(+3) . (*3)`と等しく、また、`\x -> ((x*3)+3)`とも等しい)
これは、`(*3)`という関数を受け取り、
その出力に対して、`(+3)`という変形を結びつけているからだ。
結果はまだ関数であり、
数値を与えた時に初めて、
その数値が3倍されて、
それに結び付けられた3を足すという変形へへと数値が進む。
これが、関数合成で起こっていることだ。



## Applicative functors - 適用可能なファンクタ

<img src="//s3.amazonaws.com/lyah/present.png" alt="挿絵 disregard this analogy" class="img-right">

この節では、
適用可能なファンクタ(applicative functor)について見ていく。
これはファンクタを強化したものであり、
Haskellの`Control.Applicative module`にある
適用可能な型クラス(applicative typeclass)によって表現される。

御存知の通り、
Haskellにおける関数は最初からカリー化されている。
ある関数が複数のパラメータを受け取るように見えても、実際には1つのパラメータを受け取ると、
次のパラメータを受け取る関数を返す、ということだ。
たとえば、関数の型が`a -> b -> c`の場合、
普通は、2つのパラメータを受け取り、`c`を返す、と言うだろう。
しかし、実際には`a`を受け取り、`b -> c`という関数を返す。
このため、`f x y`という関数の呼び出しが`(f x) y`となる。
この仕組みが、
部分適用を可能にしてくれる。
関数をパラメータが足りていない状態で呼び出すのだ。
そして、部分適用された結果の関数は、別の関数に渡すことができる。

ここまで、
ファンクタに対して関数をマッピングするときは、
1つのパラメータのみを受け取る関数を使ってきた。
しかし、`*`ような、2つのパラメータを受け取る関数を
ファンクタに対してマッピングすると何が起こるだろう? 
では、具体的な例をいくつか見てみよう。
たとえば，`Just 3`に対して`fmap *`をマッピングすると、
たとえば、`Just 3`があるとして、`fmap (*) (Just 3)`をすると、
何が得られるだろう? 
`Functor`のインスタンスである`Maybe`の実装によると、
`Just 何か`という値であれば、
`Just`の中にある何かに対して関数が適用されることが分かる。
従って、
`fmap (*) (Just 3)`は、
`Just ((*) 3)`という結果になり、
これをセクションを使って書き表せば、
`Just (* 3)`となる。
おもしろい! 
関数を`Just`で包んだものが得られた。

    ghci> :t fmap (++) (Just "hey")
    fmap (++) (Just "hey") :: Maybe ([Char] -> [Char])
    ghci> :t fmap compare (Just 'a')
    fmap compare (Just 'a') :: Maybe (Char -> Ordering)
    ghci> :t fmap compare "A LIST OF CHARS"
    fmap compare "A LIST OF CHARS" :: [Char -> Ordering]
    ghci> :t fmap (\x y z -> x + y / z) [3,4,5,6]
    fmap (\x y z -> x + y / z) [3,4,5,6] :: (Fractional a) => [a -> a -> a]

たとえば、`(Ord a) => a -> a -> Ordering`という型を持つ`compare`を
文字列に対してマッピングすると、
`Char -> Ordering`という型を持つ関数のリストが得られる。
`compare`関数が、リスト内の文字列で部分適用されるからだ。
これは、`(Ord a) => a -> Ordering`という関数のリストではない。
なぜなら、最初の`a`が`Char`で適用されると、
2番目の`a`は`Char`という型に決まるからだ。

複数パラメータの関数をファンクタにマッピングすることで、
ファンクタの中に関数を含むものが得られた。
それで、これを使って何ができるんだろう? 
そうだね、ひとつの例としては、
ファンクタの中にあるものはすべて
マッピングしようとしている関数をパラメータとして受け取るから、
これらの関数をパラメータとして受け取る関数にマッピングすることができる。

    ghci> let a = fmap (*) [1,2,3,4]
    ghci> :t a
    a :: [Integer -> Integer]
    ghci> fmap (\f -> f 9) a
    [9,18,27,36]

しかし、
たとえば`Just (3 *)`と、
`Just 5`という値のファンクタがあるとして、
`Just (3 *)`から関数を抽出して
`Just 5`にマッピングしたい場合、どうするんだろう? 
普通のファンクタを使う? 
いや、我々は運が尽きている。
サポートされているのは、既存のファンクタに対する普通の関数のマッピングのみだ。
関数を保持しているファンクタに対して
`\f -> f 9`をマッピングしたとしても、
普通の関数をマッピングしていることになる。
しかし、　
`fmap`が提供している方法を使って、
ファンクタの中にある関数を他のファンクタに対してマッピングすることはできない。
もちろん、
`Just`コンストラクタに対してパターンマッチングをすることで、
中味の関数を取り出してから、それを`Just 5`に対してマッピングすることはできる。
しかし、我々はファンクタ同士で機能する、抽象的で汎用的な方法を探しているのだ。

では、適用可能な型クラス(applicative typeclass)を紹介しよう。
これは、`Control.Applicative module`にあり、
`pure`と`<*>`という2つのメソッドが定義されている。
これらはどちらもデフォルトの実装が提供されていないので、
なにかを適用可能なファンクタにしたければ、
両方とも自分で定義する必要がある。
この型クラスは、以下のように定義されている。

    class (Functor f) => Applicative f where
        pure :: a -> f a
        (<*>) :: f (a -> b) -> f a -> f b

わずか3行のクラス定義ながら、我々に多くを語ってくれる。
まずは1行目からはじめよう。
適用可能な型クラスの定義からはじまり、クラスの制約を導入している。
これは、適用可能な型クラスに属する型コンストラクタを作りたければ、
まずは、それがファンクタの中にある必要がある、と言っている。
型コンストラクタが適用可能な方クラスの一部であり、
かつファンクタでもあるとき、
`fmap`を使えるのはそのためだ。

最初に定義されているメソッドは、`pure`と呼ばれるものだ。
その方宣言は、`pure :: a -> f a`となっている。
この`f`は、適用可能な方クラスのインスタンスの役割を演じる。
Haskellは素晴らしい型システムを持っていて、
関数ができることと言えば、パラメータを受け取って値を返すことが全てだから、
型宣言に多くの意味を込められる。
これに例外はない。
`pure`はどんな型の値でも受け取り、
適用可能なファンクタの中にその値を入れて返す。
さて、
常にそれが吟味されているとは限らないものの、
箱を使った例えを再び使ってみる。
しかし、`a -> f a`という型宣言はまだまだ説明的だ。
値を受け取って、
適用可能なファンクタでそれを包み、
ファンクタの中にその値を持つ。

`pure`について考える最良の方法は、
値を受け取って、デフォルトの(純粋な)コンテキスト、
つまり、値を生み出す最小のコンテキストに入れると考えることだ。

`<*>`関数は実に興味深い。
型は、
`f (a -> b) -> f a -> f b`となっている。
これで何か思い出せたかな?
そう、
`fmap :: (a -> b) -> f a -> f b`だ。
これは`fmap`の強化版だ。
`fmap`は、関数とファンクタを受け取り、ファンクタの中味に対して関数を適用するのに対して、
`<*>`は、
関数の入ったファンクタと、もう一つ別のファンクタを受け取り、
最初のファンクタから関数を抽出して、
それを2つめのファンクタにマッピングする。
抽出、というのは
シーケンスであっても、
実際にそれを実行して抽出をする、という意味だ。
理由は後ですぐ分かる。

では、`Maybe`における適用可能なインスタンスの実装を見てみよう。

    instance Applicative Maybe where
        pure = Just
        Nothing <*> _ = Nothing
        (Just f) <*> something = fmap f something

再び、
見ての通りクラスの定義から、
`f`が
具体的な型をパラメータとして受け取る
適用可能なファンクタの役割を演じていることが分かる。
ということで、
`instance Applicative (Maybe a) where`の代わりに
`instance Applicative Maybe where`と書ける。

まずは`pure`だ。
以前、
なにかを受け取って、それを適用可能なファンクタで包むことを仮定していると言った。
`pure = Just`と書いているが、
値コンストラクタ`Just`は普通の関数だからだ。
これはもちろん、
`pure x = Just x`と書くこともできる。

次は、
`<*>`の定義についてだ。
`Nothing`から抽出できる関数はない。
その中に関数が入っていないからだ。
つまり、`Nothing`から関数を抽出すると、
`Nothing`という結果が得られるわけだ。
`Applicative`のクラス定義を見れば、
`Functor`の型制約があるのに気づくだろう。
これは、`<*>`の両方のパラメータがファンクタであると仮定することを意味する。
もし、最初のパラメータが`Nothing`ではなく、
関数を含んだ`Just`であれば、
その関数を2つめのパラメータに対してマッピングしたい、ということを意味する。
これは、2つめのパラメータが`Nothing`である場合も注意しなければならない。
`fmap`で`Nothing`に対してどんな関数をマッピングしても、`Nothing`になるからだ。

つまり`Maybe`については、
`<*>`は、
左のパラメータが`Just`であれば、その中身の関数を抽出して、
その関数を右のパラメータに対してマッピングする。
また、パラメータが`Nothing`であれば、
`Nothing`が返される。

いやぁ、最高だね。この世界観に浸ろう。

    ghci> Just (+3) <*> Just 9
    Just 12
    ghci> pure (+3) <*> Just 10
    Just 13
    ghci> pure (+3) <*> Just 9
    Just 12
    ghci> Just (++"hahah") <*> Nothing
    Nothing
    ghci> Nothing <*> Just "woot"
    Nothing

この場合の、
`pure (+3)`というのが
`Just (+3)`と同じであることを確認した。
適用可能なコンテキストで
(`<*>`を使って)
たとえば、`Maybe`の値を扱うときは、
`pure`を使わなければ、
`Just`でハマることになる。
最初の4行は、どのように関数を抽出してマッピングするのかをデモしている。
しかし、この場合においては、
ファンクタに対して単純に中味をとり出す関数をマッピングすれば、目的は達成できる。
最後の行は興味深い。
これはもちろん`Nothing`になる。

普通のファンクタにたいしては、
その結果が部分適用された関数でない限り、
ファンクタに対して関数をマッピングして、
その結果を一般的な方法でとり出すことはできない。
一方、
適用可能なファンクタは、
ひとつの関数でいくつかのファンクタを操作でk理う。
以下のコードを見てほしい。

    ghci> pure (+) <*> Just 3 <*> Just 5
    Just 8
    ghci> pure (+) <*> Just 3 <*> Nothing
    Nothing
    ghci> pure (+) <*> Nothing <*> Just 5
    Nothing

<img src="//s3.amazonaws.com/lyah/whale.png" alt="挿絵 whaale" class="img-right">

ここで何が起きているんだろう?
1行ずつ、確認してみよう。
`<*>`は左結合だ。
これは、
`pure (+) <*> Just 3 <*> Just 5`が、
`pure (+) <*> Just 3) <*> Just 5`と同じであることを
を意味する。
はじめに、
`+`関数がファンクタの中に配置される。
この場合は、`Maybe`の値が関数を保持できる。
つまり、まず最初に
`pure +`を得る。
これは`Just (+)`となる。
次に、
`Just (+) <*> Just 3`が起きる。
これの結果は`Just (3+)`となる。
これは部分適用によるものだ。
`+`関数に`3だけを適用すれば、1つパラメータを受け取り、それに`3`を足すという関数が得られる。
最後に、
`Just (3+) <*> Just 5`が行われて、
結果は`Just 8`となる。

これ、すごくない?!
適用可能なファンクタと
`pure f <*> x <*> y <*> ...`
という適用可能な方法を使うことで、
パラメータとして受け取ることが期待される関数はファンクタに包む必要がなく、
ファンクタのコンテキストの中で幾つかの値を操作することを可能にしてくれる。
関数は望んだ数だけ、いくらでもパラメータを受け取れる。
なぜなら、`<*>`が出現するたびに関数が部分適用されていくからだ。

これは
`pure f <*> x equals fmap f x`
という事実に気がつけば、
よりお手軽かつ明確になる。
これはapplicativeの法則の一つだ。
これについては、後で詳しく見ていく。
しかし、今は
これはそういうものなんだ、と直感で理解しよう。
そう考えると、理にかなっている。
以前、
`pure`は値をデフォルトのコンテキストに配置する、
と言った。
たとえば、関数をデフォルトのコンテキストに配置して、
そこから関数を抽出して、別のファンクタの中味に適用するということは、
関数をapplicativeファンクタにマッピングするのと同じことであり、
`pure f <*> x <*> y <*> ...`
と書く代わりに
`fmap f x <*> y <*> ....`
と書くことができる。
これが、
`Control.Applicative`
が`<$>`という関数を公開している理由であり、
これは、単に`fmap`を中置換数にしたものだ。
どのように定義されているか、確認しよう。

    (<$>) :: (Functor f) => (a -> b) -> f a -> f b
    f <$> x = fmap f x

Yo!
軽くおさらいしよう。
型変数は独立したパラメータの名前、あるいは値の名前だ。
この関数の宣言における`f`は、
クラスの制約を伴う型変数であり、
どんな型コンストラクタであっても
`f`を型クラス`Functor`に交換できなければならない、
と言っている。
関数の本体における`f`は、
`x`に対してマッピングする関数を示している。
なお、
これら両方を表現するために`f`を使っているが、
これらが同じものである、という意味はない。

`<$>`を使うことで、
applicativeな方法が発揮される。
たとえば、
関数`f`を3つのapplicativeファンクタに適用する場合、
`f <$> x <*> y <*> z`と書けるからだ。
もし、パラメータがapplicativeファンクタではなく普通の値だったら、
`f x y z`と書くだろう。

では、これがどのように機能するか詳しく見てみよう。
たとえば、
`Just "johntra"`と
`Just "volta"`という値があり、
`Maybe`ファンクタの中で、これらを1つの文字列に結合したいとき、
このようにする。

    ghci> (++) <$> Just "johntra" <*> Just "volta"
    Just "johntravolta"

上記で何が起きているかを見る前に、以下と比較してみよう。

    ghci> (++) "johntra" "volta"
    "johntravolta"

やばいね!
普通の関数をapplicativeファンクタに対して使っているのに、
`<$>`と`<*>`を使うだけで、
関数がapplicativeを操作して、applicativeを返している。
クール杉じゃない?

ところで、
`(++) <$> Just "johntra" <*> Just "volta"`をするとき、
最初の`(++)`は、
`(++) :: [a] -> [a] -> [a]`という型を持ち、
`Just "johntra"`に対してマッピングされる。
結果の値は、同じく
`Just ("johntra"++)`となり、
型は`Maybe ([Char] -> [Char])`となる。
さて、`(++)`の最初のパラメータが消化されて
、`Char`に変化するのに注目しよう。
すると、
`("johntra"++) <*> Just "volta"`となり、
これは`Just`から関数を取り出し、
`Just "volta"`にマッピングして、
`Just "johntravolta"`という結果になる。
もし、2つの値のどちらかが`Nothing`だったら、
結果も`Nothing`となる。

ここまで、
`Maybe`を使った例しか見てこなかったから、
あなたはapplicativeファンクタが`Maybe`に限られると考えているかも知れない。
しかし、applicativeの例は他にもたくさんある。
では、見てみよう。

リストというか、リストの型コンストラクタ(`[]`)は、
applicativeファンクタだ。
驚愕の事実だ!
以下にapplicativeのインスタンスであることを示そう。

    instance Applicative [] where
        pure x = [x]
        fs <*> xs = [f x | f <- fs, x <- xs]

以前、
`pure`は値を受け取り、それをデフォルトのコンテキストに配置する、
と言った。
言い換えれば、
最小のコンテキストは、まだ値を生み出している、といえる。
リストにおける最小のコンテキストは、
空のリスト`[]`となるだろう。
しかし、空のリストが表現するものは、値が不足している。
つまり、値を保持できないので、`pure`を使うのだ。
`pure`が受け取った値をシングルトンリストに配置するのはそのためだ。
同様に、
`Maybe`applicativeファンクタにおける最小のコンテキストは、`Nothing`となる。
しかし、これが表現するものは値が不足しているので、
`Maybe`については、
そのインスタンスである`Just`として`pure`が実装されている。

    ghci> pure "Hey" :: [String]
    ["Hey"]
    ghci> pure "Hey" :: Maybe String
    Just "Hey"

`<*>`はどうだろう?
もし、`<*>`の型がリストに限定されていたとしたら、
`(<*>) :: [a -> b] -> [a] -> [b]`という型になるだろう。
これはリストcomprehensionで実装されている。
`<*>`は、
左のパラメータから関数を取り出して、
右のパラメータにマッピングする必要がある。
しかし、ここでは左のリストが0個、あるいは1つ、
あるいは複数の関数をリストに保持しているかもしれない。
そして、右側のリストも複数の値を保持しているかもしれない。
リスト内包表記を使っているのは、両方の中味をとり出すためだ。
左側のりすとのすべての関数を取り出し、右側のリスト内のすべての値に適用する。
結果のリストは、
左側のリストにある関数を右側のリスト内にある値へ適用した組合せから構成される。

    ghci> [(*0),(+100),(^2)] <*> [1,2,3]
    [0,0,0,101,102,103,1,4,9]

左のリストには3つの関数があり、右側のリストには3つの値がある。
つまり、結果のリストは、9つの要素を持つ。
左側のリストにある関数はすべて、右側のリストにある値それぞれに適用される。
もし、2つのパラメータを受け取る関数のリストがあるとしたら、
それらの関数を2つのリストにたいして適用できる。

    ghci> [(+),(*)] <*> [1,2] <*> [3,4]
    [4,5,5,6,3,4,6,8]

`<*>`は左結合だから、
`[(+),(*)] <*> [1,2]`が先に起こる。

結果のリストは
`[(1+),(2+),(1*),(2*)]`
とおなじになる。
左側の関数はすべて、右側の値それぞれに適用されるから、
そうすると、
`[(1+),(2+),(1*),(2*)] <*> [3,4]`が起こり、
最終的な結果を生成する。

リストにたいしてapplicativeな方法を使うのは、おもしろい。見てみよう。

    ghci> (++) <$> ["ha","heh","hmm"] <*> ["?","!","."]
    ["ha?","ha!","ha.","heh?","heh!","heh.","hmm?","hmm!","hmm."]

もう一度、
適切なapplicative演算子を挿入することで、
文字列を2つ受け取る通常の関数を
文字列のファンクタに対して使う方法を見てみよう。

リストは、非決定的計算(non-deterministic computations)と、みなせる。
たとえば、`100`や`"what"`などという値は、
1つの結果のみとなる決定的計算(deterministic computation`と、みなせる。
一方
`[1,2,3]`というリストは
それぞれの値がどんな結果を持つか決定できない計算とみなせる。
そこで、可能な結果を列挙するのだ。
ということで、たとえば
`(+) <$> [1,2,3] <*> [4,5,6]`
のようなことをすると、
非決定的計算を`(+)`で結合していると考えることができ、
結果は保証されないものの、別の非決定的計算を生成することになる。

リストにたいしてapplicativeな方法を使うのは、リスト内包表記を使うときの代替手段となる。
次の章では、
`[2,5,10]`と
`[8,10,11]`の層積を求めるとする。
これは以下のようにできる。

    ghci> [ x*y | x <- [2,5,10], y <- [8,10,11]]
    [16,20,22,40,50,55,80,100,110]

これは単純に2つのリストから要素を取り出して、、それらの組合せに関数を適用しているだけだ。
これはもちろんapplicativeな方法を使っても実現できる。

    ghci> (*) <$> [2,5,10] <*> [8,10,11]
    [16,20,22,40,50,55,80,100,110]

これは分かりやすいと思う。
なぜなら、2つの非決定的計算に対して`*`を呼び出しているということがわかるからだ。
たとえば、2つのリストの層積のうち、50より大きなものすべてを求めたければ、
こうすることができる。

    ghci> filter (>50) $ (*) <$> [2,5,10] <*> [8,10,11]
    [55,80,100,110]

リストに対する`pure f <*> xs`が
`fmap f xs`と等しいということが
簡単に理解できる。
`pure f`は、
単に`[f]`であり、

`[f] <*> xs`は
左側のリスト内のすべての関数と右側のリスト内の要素すべてに適用される。
しかし、左側のリストにあるのは1つの関数だから、
マッピングのようになる。

すでに遭遇していて、かつapplicativeのインスタンスとなるのは`IO`だ。
以下のようにインスタンスが実装されている。

    instance Applicative IO where
        pure = return
        a <*> b = do
            f <- a
            x <- b
            return (f x)

<img src="//s3.amazonaws.com/lyah/knight.png" alt="挿絵 ahahahah!" class="img-left">

`pure`は最小のコンテキストに値を配置してその結果を保持するから、
`pure`が単純に`return`となるのは理にかなっている。
I/Oアクションを作って、他には何もしないという、
`return`がするのはまさにそれだからだ。
そして、その結果として何らかの値を生み出すが、
ファイルから読み込むとかターミナルに出力するとか　「
実際のI/Oに関する操作は何も行わない。

もし、`<*>`が`IO`に特化していたら、
`(<*>) :: IO (a -> b) -> IO a -> IO bという型を持つだろう。
これは、結果として関数を生み出すI/Oアクションと
別のI/Oアクションを受け取り、新しいI/Oアクションを作成する。
これが実行されると、
最初に関数を取得するため1つめのI/Oアクションが実行され、
次に2つめが値を得るために実行され、
その値に関数を適用したものが結果として生み出される。
この実装では、doシンタックスを使っている。
思い出してほしい。
doシンタックスは複数のI/Oアクションを受け取り、それらを結合するのだった。
これはまさに行おうとしていることだ。

`Maybe`と`[]`を使って、
`<*>`というのは、単純に左側のパラメータから関数を抜き出して、右側に対してマッピングするものだ、と考えることができるだろう。
`IO`については、
抽出というのはまだゲームの世界にある。
しかし、我々にはシーケンスの概念があるから、
2つのI/Oアクションを受け取り、シーケンスにする、
というか結合して、
1つにまとめる。
我々は最初のI/Oアクションから関数を抽出する必要があり、
しかし、I/Oアクションから関数を抽出するには
それが実行される必要がある。

以下を考えてみよう。

    myAction :: IO String
    myAction = do
        a <- getLine
        b <- getLine
        return $ a ++ b

このI/Oアクションは、
ユーザーから2行を取得して、
それら2行を結合したものを結果として生み出す。
これは、2つの`getLine`を結合して、I/Oアクションを返すことで実現できる。
なぜなら`a ++ b`の結果を保持したままI/Oアクションを結合する方法がほしいからだ。
これを別の方法で書くなら、applicativeを使う方法になるだろう。

    myAction :: IO String
    myAction = (++) <$> getLine <*> getLine

2つのI/Oアクションの結果に対して関数を適用したI/Oアクションを作る前に行っていることとこれは同じことだ。
思い出してほしい。
`getLine`っは、`getLine :: IO String`という型のI/Oアクションだ。
`<*>`を2つのapplicativeファンクタに対しtえ使うとき、
結果はapplicativeファンクタとなる。
ということで、すべて理にかなっている。

箱を使った例えに戻るなら、
`getLine`は現実の世界に出掛けて、文字列を持ち帰ってくる箱であると想像できる。
そして、
`(++) <$> getLine <*> getLine`は新しい箱、
2つの箱を送り出して、入力された内容をターミナルへ持って帰ってきて、
その結果として2行を結合したものを表現する巨大な箱をつくる。

`(++) <$> getLine <*> getLine`という式の型は、
`IO String`となる。
これが意味するのは、これが完全に他のI/Oアクションと同じである、ということだ。
これは、他のI/Oアクションと同様に
結果の値を保持する。
そのため、以下の様なことができる。

    main = do
        a <- (++) <$> getLine <*> getLine
        putStrLn $ "The two lines concatenated turn out to be: " ++ a

幾つかのI/Oアクションを名前に束縛して、
それらにたいして関数を呼び出したものを
`return`を使って結果としているのを自覚したら、
applicativeな方法を使うことを考慮しよう。
なぜなら、
そのほうが間違いなくより完結になるからだ。

その他のapplicativeな例といえば、
`(->) r`という関数だ
これはコードゴルフ大会以外でも使える便利なapplicativeだ。
そして、applicativeとしても興味深い。
では、関数がインスタンスとしてどのように実装されているか見てみよう　

もし、`(->) r`が意味するものについて混乱したなら、
前の節の`(->) r`がファンクタであると説明しているところを確認しよう。

    instance Applicative ((->) r) where
        pure x = (\_ -> x)
        f <*> g = \x -> f x (g x)

pure`を使って、値をapplicativeファンクタで包むと
それが生み出す結果は常にその値となる。
まだ、最小のデフォルトコンテキストは、その値を結果として生み出す。
これが、関数というインスタンスにおける実装では、
`pure`が値を受け取り、
パラメータを無視して、常にその値を返す関数を作成する理由だ。
もし、`pure`の型を見た時、
それが
`(->) r`のインスタンスに限定されていたら、
その型は`pure :: a -> (r -> a)`となるだろう。

    ghci> (pure 3) "blah"
    3

カリー化により、
関数適用は左結合になるので、
かっこを省略することができる。

    ghci> pure 3 "blah"
    3

`<*>`に対するインスタンスの実装はやや謎めいている。
ということで、適用可能な方法で、普通の関数を適用可能なファンクタとして使う方法を見てみよう。

    ghci> :t (+) <$> (+3) <*> (*100)
    (+) <$> (+3) <*> (*100) :: (Num a) => a -> a
    ghci> (+) <$> (+3) <*> (*100) $ 5
    508

2つの適用可能なファンクタを使って`<*>`を呼び出すと、結果は適用可能なファンクタとなる。
つまり、2つの関数を使う場合、
関数が帰ってくる。
では、ここでは何が起きてるんだろう?
`(+) <$> (+3) <*> (*100)`するとき、
`(+3)`と`(*100)`の結果に対して`+`を使う関数を作り、それを返す。
実際の例をデモするために、
`(+) <$> (+3) <*> (*100) $ 5`をすると、
最初に`5`が`(+3)`と`(*100)`に適用されて、
`8`と`500`という結果になる。
それから
そして、`+`が`8`と`500`に対して呼び出され、
`508`という結果になる。

    ghci> (\x y z -> [x,y,z]) <$> (+3) <*> (*2) <*> (/2) $ 5
    [8.0,10.0,2.5]

<img src="//s3.amazonaws.com/lyah/jazzb.png" alt="挿絵 SLAP" class="img-right">

ここでも同じく、
`\x y z -> [x,y,z]`という関数を呼び出す関数を作り、
最終的な結果は`(+3)`となり、
`(*2)`と`(/2)`となる。
そして、
`5`がそれぞれの関数に与えられて、
`\x y z -> [x, y, z]`
それぞれの結果に対して呼び出される。

関数は、最終的な結果を保持する箱であると考えられる。
つまり、
`k <$> f <*> g`とすると、
`f`と`g`の最終的な結果を使って`k`を呼び出す関数が作られる。
たとえば
`(+) <$> Just 3 <*> Just 5`をすると、
ある値、もしくは値にならないものに対して`+`を使うことになり、
その結果もある値となるか、ならないものとなる。
`(+) <$> (+10) <*> (+5)をするとき、
`+`は`(+10)`と`(+5)`が返す将来の結果のために使い、
パラメータを与えて呼び出した時に生成される値が結果となる。

関数を適用可能なものとして使うことはそう多くはないが、
これは興味深いことに変わりない。
`Applicative`の`(->) r`というインスタンスがどのように機能するかについて理解するというのはそれほど重要ではない。
だから、これを今すぐ理解できなくて落胆する必要はない。
関数を適用可能な豊富おで使ってみて、
適用可能なものとしての関数、についての直感を養おう。

まだ遭遇していない適用可能なもの、といえば`ZipList`だ。
これは`Control.Applicative`にある。

これは、リストをより適用可能なファンクタへと変化させてくれる。
一つの方法は、すでに説明したものだ。
それは、`<*>`を関数のリストに対して呼び出すことで、
左側のリストにある関数を右側の値のリストに対して適用した組合せのすべてを
保持するリストが結果として得られる。
もし、
`[(+3),(*2)] <*> [1,2]`をすれば、
`(+3)`は、`1`と`2`の両方に適用され、
`(*2)`も`1`と`2`の両方に適用され、
結果のリストは要素が4つとなり、
`[4,5,2,4]`となる。

しかし、
`[(+3),(*2)] <*> [1,2]`
左側のリストの先頭にある関数が右側のリストの先頭の値に適用される、
という方法でも機能する。
2番目の関数は2番目の値に適用され、という具合に、だ。
すると、
`[4,4]`という
結果は2つの値を持つリストになる。
これは
`[1 + 3, 2 * 2]`とみなせる。

1つの型が、同じ2つの型クラスのインスタンスを持つことはできないから、
`ZipList`型が導入された。
`ZipList`の肩コンストラクタは1つのフィールドのみを持ち、
そのフィールドはリストとなる。
以下はインスタンス宣言だ。

    instance Applicative ZipList where
            pure x = ZipList (repeat x)
            ZipList fs <*> ZipList xs = ZipList (zipWith (\f x -> f x) fs xs)

`<*>`がしていることは、
最初の関数を最初の値に適用して、
2番目の関数を2番目の値に適用して、
ということをする。
これは
`zipWith (\f x -> f x) fs xs`で行われる。

`zipWith`の働きにより、
結果のリストは2つのリストよりも短くなる。

`pure`もまた興味深い。
値を受け取り、それを無限に繰り返すリストに入れる。
`pure "haha"`は、
`ZipList (["haha","haha","haha"...`という結果になる。
これは
`pure`は値を受け取り、その値を生み出す最小のコンテキストに配置する、といったから、
ちょっと紛らわしい。
あなたは、無限リストが最小のコンテキストではないのでは、と考えるかもしれない。
しかし、これは理にかなっている。
すべての位置に値を生成する必要がある体。
また、これは
`pure f <*> xs`
は
`fmap f xs`
と等しい、という法則も満たす。
もし、
`pure 3`
が
`ZipList [3]`
を返すとしたら、

`pure (*2) <*> ZipList [1,5,10]`
は
`ZipList [2]`
という結果になるだろう。
なぜなら、ジップされた2つのリストは元のリストの長さより短くなるからだ。
しかし、最終的な結果のリストが無限リストであれば、
結果のリストは常に有限のリストの長さと等しくなる。

では、適用可能な方法では、`ZipList`はどのように機能するんだろう?
見てみよう。
おっと、
`ZipList`は`Show`のインスタンスではなかった。
ということで、
`getZipList`関数を使って、
生のリストを抽出する必要がある。

    ghci> getZipList $ (+) <$> ZipList [1,2,3] <*> ZipList [100,100,100]
    [101,102,103]
    ghci> getZipList $ (+) <$> ZipList [1,2,3] <*> ZipList [100,100..]
    [101,102,103]
    ghci> getZipList $ max <$> ZipList [1,2,3,4,5,3] <*> ZipList [5,3,1,2]
    [5,3,3,4]
    ghci> getZipList $ (,,) <$> ZipList "dog" <*> ZipList "cat" <*> ZipList "rat"
    [('d','c','r'),('o','a','a'),('g','t','t')]

`(,,)`関数は
`\x y z -> (x,y,z)`
と等しい。
また、
`(,)`関数は
`\x y -> (x,y)`
とも等しい。

`zipWith`の余談になるが、
標準ライブラリには
`zipWith3`
や
`zipWith4`
という関数が7段階まで用意されている。
`zipWith`は関数と2つのパラメータを受け取り、その関数で2つのリストを圧縮する。
`zipWith3`は、関数と3つのパラメータを受け取り、その関数で3つのリストを圧縮する。
などなど。
適用可能な方法でリストを圧縮することで、
圧縮したいリストの数に応じて　
`zipWith`関数をそれぞれ分割する必要はない。
任意のリストの数に応じて、適用可能な方法を使ってそれらのリストを関数で圧縮する。
実にクールだね。

`Control.Applicative`は、
`liftA2`と呼ばれる関数を定義している。
関数の型は、
`liftA2 :: (Applicative f) => (a -> b -> c) -> f a -> f b -> f c `となっている
そして、こう、定義されている。

    liftA2 :: (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
    liftA2 f a b = f <$> a <*> b

なんてことはない、
関数を2つの適用可能なものに適用しているだけだ。
すると、適用可能なものに親しみが持てる。
これを見せたのは
普通のファンクタより適用可能なファンクタのほうが強力であることを示すにはうってつけだからだ。
普通のファンクタを使うと、
関数をマッピングできるのは1つのファンクタに対してのみだ。
しかし、適用可能なファンクタを使えば、
いくつかのファンクタに対して関数をマッピングできる。
また、この関数の型を見てみると、
`(a -> b -> c) -> (f a -> f b -> f c)`
となっているのも興味部下い。
これを見た時、
`liftA2`関数は、
普通のバイナリ関数を受け取って、
それを2つのファンクタに対して操作できるように格上げする、と読み取れる。

これは面白いコンセプトだ。
2つの適用可能なファンクタを受け取り、それを
2つの適用可能なファンクタの結果をリストにまとめた
1つの適用可能なファンクタに結合している。
たとえば、
`Just 3`と`Just 4`があるとして、
目的を簡単に達成できるので、
2番目の中味がシングルトンリストの中にあると仮定する。

    ghci> fmap (\x -> [x]) (Just 4)
    Just [4]

いいね。
では、`Just 3`と`Just [4]`があるとしよう。
`Just [3,4]`を取得するのは簡単だ。

    ghci> liftA2 (:) (Just 3) (Just [4])
    Just [3,4]
    ghci> (:) <$> Just 3 <*> Just [4]
    Just [3,4]

思い出してほしい。
`:`は要素とリストを受け取り、その要素をリストの先頭に結合した新しいリストを返す関数だ。
そして、`Just [3,4]`が得られた。
では、それと`Just 2`を結合して、
`Just [2,3,4]`を得られるだろうか?
もちろんだ。
これは、適用可能なものをいくらでも
それらの適用可能なものの中にある結果をまとめたリストを持つ
1つの適用可能なものへと結合してくれるように見える。
では、
適用可能なもののリストを受け取り、
それらの結果のリストを持つ適用可能なものを返す
関数を実装してみよう。
これを
`sequenceA`
と呼ぶことに仕様。

    sequenceA :: (Applicative f) => [f a] -> f [a]
    sequenceA [] = pure []
    sequenceA (x:xs) = (:) <$> x <*> sequenceA xs

あ、再帰だ!
まずは型を見てみよう。
これは適用可能なもののリストを、適用可能なものに変形させている。
ここから、
境界条件の下地を整える。
たとえば、空のリストを結果のリストを含む適用可能なものに変換したければ、
デフォルトのコンテキストに空のリストを入れるだけでよい。
次は再帰だ。
リストの先頭と残りがある場合、
(`x`が適用可能なもので、`xs`が適用可能なもののリストだ)
残りに対して`sequenceA`を呼び出すと
結果はリストを含んだ適用可能なものとなる。
それから、
適用可能なものの中にある`x`という値を適用可能なものの中にあるリストの先頭に結合する。
これがすべてだ。

つまり、
`sequenceA [Just 1, Just 2]`をすると、
`(:) <$> Just 1 <*> sequenceA [Just 2]`となる。
これは、
`(:) <$> Just 1 <*> ((:) <$> Just 2 <*> sequenceA [])`
と等しい。
ああ、そうか!
`sequenceA []`
が最終的に
`Just []`
になるから、
この指揮は
`(:) <$> Just 1 <*> ((:) <$> Just 2 <*> Just [])`になる。
それから、
`(:) <$> Just 1 <*> Just [2]`
になって、
最後に　
`Just [1,2]`
になる!

`sequenceA`を実装する別の方法としては、foldを使う方法がある。
思い出してほしい。
どんな関数でも、
リストの要素1つ1つを取り出して、
その結果をどんどん蓄積していくのは
foldを使うことで実装できる。

    sequenceA :: (Applicative f) => [f a] -> f [a]
    sequenceA = foldr (liftA2 (:)) (pure [])

ここでは、リストの右側からはじめるアプローチを採用し、
アキュムレータの値を
`pure []`
から始めている。
アキュムレータとリストの最後の要素に対して
`liftA2 (:)`をして、
適用可能なものの中にシングルトンを持つものが結果となる。
それから、
`liftA2 (:)`を
現在の最後の要素と現在のアキュムレータに対して、行っていく。
アキュムレータが残っている間は、
すべての適用可能なものの結果のリストを保持する。


では、この関数にいくつか適用可能なものを与えてみよう。

    ghci> sequenceA [Just 3, Just 2, Just 1]
    Just [3,2,1]
    ghci> sequenceA [Just 3, Nothing, Just 1]
    Nothing
    ghci> sequenceA [(+3),(+2),(+1)] 3
    [6,5,4]
    ghci> sequenceA [[1,2,3],[4,5,6]]
    [[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
    ghci> sequenceA [[1,2,3],[4,5,6],[3,4,4],[]]

素晴らしいね。    []
`Maybe`の値を使う場合は、
`sequenceA`は、
すべての結果をリストとして`Maybe`の中に保持する値を作る。
もし、どれか1つが`Nothing`だったら、
結果も`Nothing`となる。
もし、`Maybe`の値のリストがあり、
その中に`Nothing`が一切含まれない場合のみに関心がある場合、
これはかなり便利だ。

これを関数に対して使うと
`sequenceA`は
関数のリストを受け取り、
リストを返す関数を返す。
我々の例では、
数値をパラメータとして受け取る関数を作り、
リストにあるそれぞれの関数に適用して、
結果のリストを得る。

`sequenceA [(+3),(+2),(+1)] 3`は、
`3`に対して
`(+3)`を呼び出すことになり、
`(+2)`は`3`に対して呼び出し、
`(+1)`も`3`に対して呼び出すことになり、
これらの結果がリストに現れる。

`(+) <$> (+3) <*> (*2)`とすると、
パラメータを受け取る関数が作られ、
`(+3)`と`(*2)`の両方にそれを食わせ、
それら2つの結果に`+`を呼び出すことになる。
同じ調子で、
`sequenceA [(+3),(*2)]`が
パラメータを受け取る関数を作り、
リスト内にあるすべての関数にそれを食わせる
というのも理にかなっている。
結果の関数に`+`を呼び出す代わりに
`:`と`pure []`の組合せがそれらの結果をリストに詰め込むのに使われる。
それが関数の結果となる。

関数のリストに対して、
同じ入力をそれぞれの関数に食わせて、
それぞれの結果のリストがほしいとき、
`sequenceA`は便利に使える。
たとえば
数値があり、リスト内のどれがpredicateを満たすか気になる場合、
それをする方法の一つが、これだ。

    ghci> map (\f -> f 7) [(>4),(<10),odd]
    [True,True,True]
    ghci> and $ map (\f -> f 7) [(>4),(<10),odd]
    True

思い出そう。
`and`は真偽値のリストを受け取り、
その中味がすべて`True`のとき、`True`を返すのだった。
これを`sequenceA:`を使った別の方法で実現すると、こうなる。

    ghci> sequenceA [(>4),(<10),odd] 7
    [True,True,True]
    ghci> and $ sequenceA [(>4),(<10),odd] 7
    True

`sequenceA [(>4),(<10),odd]`は、
数値を受け取り、それを
[(>4),(<10),odd] and`
にあるすべてのpredicateに食わせ、
真偽値のリストを返す関数を作る。
これは、
`(Num a) => [a -> Bool]`という型のリストを
`(Num a) => a -> [Bool]`という型の関数に変換する。
マジめっちゃ綺麗じゃね?

リストは均質だから、
もちろん、
リスト内にある関数はすべて同じ型の関数である必要がある。
たとえば、
[ord, (+3)]`というリストは作れない。
`ord`は、文字を受けとrその数値を返すのに対して、
`(+3)`は、
数値を受け取って数値を返すからだ。

`[]`を使う場合、
`sequenceA`は、
リストのリストを受け取り、リストのリストを返す。
うーん
おもしろい。
実際には、要素の組み合わせとして可能なものをすべてリストに詰め込む。
説明のために、
上記を
`sequenceA`を使ってから、
リスト内包表記をうのをやってみよう。

    ghci> sequenceA [[1,2,3],[4,5,6]]
    [[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
    ghci> [[x,y] | x <- [1,2,3], y <- [4,5,6]]
    [[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
    ghci> sequenceA [[1,2],[3,4]]
    [[1,3],[1,4],[2,3],[2,4]]
    ghci> [[x,y] | x <- [1,2], y <- [3,4]]
    [[1,3],[1,4],[2,3],[2,4]]
    ghci> sequenceA [[1,2],[3,4],[5,6]]
    [[1,3,5],[1,3,6],[1,4,5],[1,4,6],[2,3,5],[2,3,6],[2,4,5],[2,4,6]]
    ghci> [[x,y,z] | x <- [1,2], y <- [3,4], z <- [5,6]]
    [[1,3,5],[1,3,6],[1,4,5],[1,4,6],[2,3,5],[2,3,6],[2,4,5],[2,4,6]]

これは、ちょっと理解しづらいかもしれない。
でも、いくらか試してみれば、
どのように機能しているか理解できると思う。
では、
`sequenceA [[1,2],[3,4]]`を追跡してみよう。
何が起きているか理解するために
`sequenceA (x:xs) = (:) <$> x <*> sequenceA xs`
という`sequenceA`の定義と、
`sequenceA [] = pure []`
という境界条件を
使ってみよう。
あなたは、以下の評価に従う必要はないが、
リストに対する`sequenceA`がどのように機能するか想像する手助けになるかもしれない。
ひょっとしたら、ショッキングなないようかもしれないから。

1. まずは`sequenceA [[1,2],[3,4]]`からはじめる。
1. 評価されて、`(:) <$> [1,2] <*> sequenceA [[3,4]]`となる。
1. 内側の`sequenceA`が先に評価されて、`(:) <$> [1,2] <*> ((:) <$> [3,4] <*> sequenceA [])`となる。
1. 境界条件に達して、これは`(:) <$> [1,2] <*> ((:) <$> [3,4] <*> [[]])`となる。
    そして、
    `(:) <$> [3,4] <*> [[]] part,`を評価して、
    (`3`と`4`という)
    左側のリストにある可能な値全てに対して
    右側のリストにある可能な値全てに
    `:`が使われる。
    (可能な値は`[]`のみ)
    `[3:[], 4:[]],`となり、
    `[[3],[4]]`となる。　
    `(:) <$> [1,2] <*> [[3],[4]]`が得られる。
1. すると、`:`は
    左側のリストにある可能な値全て
    (ここでは`1`と`2`)
    と、
    右側のリストにある可能な値すべて
    (ここでは、`[3]`と`[4]`)
    に対して使われ、
    これは、
    `[1:[3], 1:[4], 2:[3], 2:[4]]`という結果になり、
    `[[1,3],[1,4],[2,3],[2,4]`となる。

`(+) <$> [1,2] <*> [4,5,6]`
することは、
結果として`x + y`という非決定的計算となり、
`x`は
`[1,2]`
から可能な値をすべて受け取り、
`y`は
`[4,5,6]`
からすべての値を受け取る。
そして、
可能な結果をすべて保持する
リストとして表現する。
同様に、
`sequence [[1,2],[3,4],[5,6],[7,8]]`するとき、
結果は`[x,y,z,w]`という非決定的な計算となり、
`x`は、`[1,2]`ｋら可能な値をすべて受け取り、
`y`は、`[3,4]`から可能な値をすべて受け取る。
この結果を非決定的計算で表現するために、
リスト内の要素がそれぞれ、可能なリストとなる
リストを作る。
結果がリストのリストとなるのはそのためだ。

I/Oアクションを使うときは
`sequenceA`は順番に行うこととおなじになる!
これはI/Oアクションのリストを受け取り、
それぞれのI/Oアクションを実行する
I/Oアクションを返す。
それらのI/Oアクションを実行した結果のリストが結果となる。
`[IO a]`という値が
`IO [a]`という値に変換されるのはそのためだ。
実行された結果のリストを生み出す
I/Oアクションを作るには、
それらのI/Oアクションが順番になる必要があるので、
他の評価がされてから、順番にひとつひとつ実行される。
それらのI/Oアクションを実行することなく結果を得ることはできない。

    ghci> sequenceA [getLine, getLine, getLine]
    heyh
    ho
    woo
    ["heyh","ho","woo"]

普通のファンクタのように、
適用可能なファンクタもちょっとだけ法則がある。
一番重要なものの一つは、すでに言及したものであり、
`pure f <*> x = fmap f x`
が保たれる、というものだ。
では、エクササイズとして、
この章で言及したその他の適用可能なファンクタについて、
それぞれこの法則を満たすか証明してみおう。

* pure id <*> v = v
* pure (.) <*> u <*> v <*> w = u <*> (v <*> w)
* pure f <*> pure x = pure (f x)
* u <*> pure y = pure ($ y) <*> u

ここでは、それぞれの詳細については触れない。
説明はつまらないくせに、大量のページを割かなくてはならないからだ。
しかし、もしやる気があるのなら、
これらを詳しく見て、インスタンスとして法則ぉ満たしているか確認できる。

まとめとして、
適用可能なファンクタは単に面白いだけでなく、
I/Oなどの計算のように
失敗するかもしれない
非決定的計算など。に対して
適用可能な方法を使うことで
異なる計算を組み合わせることを可能にしてくれるから、
役立つものでもある。
``<$>`と`<*>`を使うことで、
普通の関数を使って、
適用可能なファンクタをいくつでも操作できるし、
それぞれのセマンティクスの恩恵が得られる。



## The newtype keyword - newtypeキーワード

WIP



## Monoids - モノイド

WIP

