---
title: "Functors, Applicative Functors and Monoids - ファンクタと適用可能なファンクタ、そしてモノイド"
layout: chapter
---



Haskellの純粋さ、高階関数、パラメータ化された代数的データ型、そして型クラスの組合せが、ポリモーフィズムを他の言語と比較してもより高度なレベルで実装可能にしてくれる。あなたは、型が巨大な改装に属しているということを考える必要はないのだ。その代わり、型がどのように振る舞うか、について考える。そして、その型を適切な型クラスに接続する。たとえば、`Int`型は様々なものとして振る舞える。等しさが比較できるもの(`Eq`)、順番を持つもの(`Ord`)、列挙できるもの(`Enum`)などとして振る舞える。

そして、型クラスは開かれている。これは、我々が、独自のデータ型を定義できることを意味する。定義した型がどのように振る舞うのかを考え、振る舞いを定義している型クラスへとその型を接続する。また、コレに加えて、Haskellの素晴らしい型システムにより、型宣言を知るだけで、ある関数がどのような関数であるか、より多くのことを知ることができる。それから、一般的で抽象的な振る舞いについて定義する型クラスについても我々が独自に定義できる。我々は既に、2つのものが等しいとみなせるかを判定する、あるいは2つのものを何らかの順番に基づいて比較するという型クラスを見てきた。これらはかなり抽象的で、振る舞いもエレガントだ。しかし、我々の人生の大半をこれらを扱うことに費やしてきたから、これらが何か特別なものである、とは考えたりしない。また、少し前には、ファンクタについて触れた。基本的に、ファンクタとはマッピングされるもの、のことだ。これは、まだ声質が抽象的なものを型クラスが表現できることを示す、格好の例だ。この章では適用可能なファンクタ(appricative functor)と呼ばれる、ちょっとだけ協力で役に立つファンクタについて詳しく見ていこう。それから、モノイド(monoid)という、靴下のようなものも見ていく。



## Functors redux - ファンクタ、再び

<img src="//s3.amazonaws.com/lyah/frogtor.png" alt="挿絵 frogs dont even need money" class="img-right">

ファンクタについては前の節で少しだけ触れた。もし、まだ読んでいないのであれば、時間のあるときにその節をちら見するくらいはしたほうが良いかもしれない。あるいは、もう読んだことにしてしまおう。

それでは、軽くおさらいを。ファンクタとは、リストやMaybe、ツリーなど、マッピングされることが可能なもの、のことだ。Haskellでは、これらは`Functor`という型クラスで表現され、ファンクタは、1つの型クラスメソッド、`fmap`のみを持ち、その型は、`fmap :: (a -> b) -> f a -> f b`となる。これは、`a`を受け取り`b`を返す関数と、箱のなかに`a`を1つ(あるいは複数)入れて渡してくれたら、箱のなかに`b`を1つ(あるいは複数)入れて返すよ、というのを意味している。言ってみれば、箱のなかに入った要素に関数を適用するようなものだ。

ここで、アドバイスを一言。箱を使った例えは、直感的な例えとして使われる。ファンクタの働きを説明するのにも使ったこの例えは、後で、適用可能なファンクタやモナドに対しても使う。この例えは、まずファンクタを理解するためのものとしては問題ないといえる、なぜなら。箱に例えるというのは真実を含んでいて、その考えを拡張できるファンクタもあるので、全く字面通りに受け取らなくてよいからだ。ファンクタをより正確な用語で例えるなら、計算の文脈(computational context)、となるだろう。文脈、というのは、ある計算が値を持つか、あるいは失敗する(MaybeやEitherになる、あるいはその他の値(リストなど)になるかもしれない、ということを表す。

もし、`Functor`のインスタンスとなる型コンストラクタを作りたければ、`* -> *`というkindを持たなくてはならない。これは、型パラメータとして、確実に具体的な型を1つ受け取るということを意味する。たとえば、`Maybe`はインスタンスになることができる。なぜなら、1つの型パラメータを受け取って、`Maybe Int`や`Maybe String`などの具体的な型を生成するからだ。もし、型コンストラクタが`Either`のように2つのパラメータを受け取る場合、1つの型パラメータのみを受け取るようになるまで、その型コンストラクタを部分適用しなくてはならない。つまり、`instance Functor Either where`というのはかけないが、`instance Functor (Either a) where`とすることはできる。もし、`fmap`が`Either a`に限定されていたら、`fmap`の方宣言は、`fmap :: (b -> c) -> Either a b -> Either a c`となるだろう。見ての通り、`Either`の部分が固定されている。`Either a`は1つのパラメータしか受け取らないのに対して、`Either`は2つ受け取るから、`fmap :: (b -> c) -> Either b -> Either c`というのは意味を成さない。

、ここまで多くの型について学んできた。たとえば、`[]`や`Maybe`、`Either a`そして、我々が作った`Tree a`などの型コンストラクタは、実際`Functor`のインスタンスとなっている。また、これらに対して関数がどのようにマッピングできるのか、についても見てきた。この節では、ファンクタのインスタンスである`IO`と`(->)`について見ていく。

たとえば、ある値が、`IO String`という型を持っているとしたら、それは、実行されると実世界へでかけて何らかの文字列を持って帰ってくるというI/Oアクションが結果として生み出されることを意味する。`<-`は、`do`シンタックスの中で、その結果を名前に束縛するのに使う。以前、I/Oアクションは、実世界へでかけて、何らかの値が入った状態で戻ってくる箱のようなものだ、と言った。持ってきてほしいものを思い描いたら、その後は、戻ってくる値を`IO`で包む必要がある。では、この箱に例えることを使って、`IO`がファンクタとして振る舞うことを確認してみよう。

では、I/Oが`Functor`のインスタンスであるかを確認する。I/Oアクションに対して`fmap`をマッピングすると、そのI/Oアクションは同じことをするが、結果の値には関数が適用されていることを期待する。

    instance Functor IO where
        fmap f action = do
            result <- action
            return (f result)

I/Oアクションに対してマッピングして得られた何らかの結果は、I/Oアクションになる。つまり、doシンタックスを使って、2つのI/Oアクションを一つにまとめることができる。`fmap`の実装のために。最初に元のI/Oアクションを実行して、その結果に対して関数`return`を呼ぶというI/Oアクションを作る必要がある。つまり、`return (f result)`をする。`return`は、御存知の通り、I/Oアクションを作る関数だ。この関数は何もしないが、その結果を表す。doブロックが生成するアクションは、常に最後に実行されるアクションの結果の値を保持する。実際には何もしない`return`を使ってI/Oアクションを作るのは、`f result`が新しいI/Oアクションの結果を表すからだ。

実際、単純で簡単だから、とりあえず触ってみれば直感が働くかもしれない。以下のコードを見てほしい。

    main = do line <- getLine
              let line' = reverse line
              putStrLn $ "You said " ++ line' ++ " backwards!"
              putStrLn $ "Yes, you really said" ++ line' ++ " backwards!"

ユーザーになにか1行入力するように求めて、入力されたものを反転して表示する。これは、、`fmap`を使って書き直すことができる。

    main = do line <- fmap reverse getLine
              putStrLn $ "You said " ++ line ++ " backwards!"
              putStrLn $ "Yes, you really said" ++ line ++ " backwards!"

<img src="//s3.amazonaws.com/lyah/alien.png" alt="挿絵 w00ooOoooOO" class="img-left">

たとえば、`"halb"`という結果を得るために`"blah"`に対して`reverse`をするように、`getLine`に対しても`fmap reverse`することができる。`getLine`は`IO String`という型を持ち、これに対するマッピングは、現実の世界へでかけて、1行を取得してから、その結果に対して`reverse`を適用するI/Oアクションとなる。Maybeという箱のなかの何かに対して関数を適用できるように、IOという箱のなかにある何かに対しても関数を適用できるのだ。ただし、IOの場合は何かを取得するために現実の世界へ出かける必要がある。そして、その何かを`<-`を使って名前に束縛する。すると、その名前は既に`reverse`が適用された結果を反映している。

`fmap (++"!") getLine`というI/Oアクションは、単なる`getLine`のように振る舞うが、その結果には常に`"!"`が付加されている。

もし、`fmap`の型が`IO`に限定されていたとしたら、`fmap :: (a -> b) -> IO a -> IO bという型になるだろう。`fmap`は、関数とI/Oアクションを受け取り、中味に対して関数が適用されていることを除いて、古いほうと似たような新しいI/Oアクションを結果として返すだろう

もし、I/Oアクションの結果を名前に束縛してから、その結果に対して関数を適用した結果を別の名前に束縛しようとしているのなら、コードが綺麗になるので`fmap`を使うことを考慮に入れてほしい。また、複数の変換をファンクタという箱の中にあるデータに対して適用したいという場合は、ラムダ関数を作るか、あるいは、理想的には関数合成を使ってコード全体から使える独自の関数を定義するのが良い。

    import Data.Char
    import Data.List
    
    main = do line <- fmap (intersperse '-' . reverse . map toUpper) getLine
              putStrLn line

&nbsp;

    $ runhaskell fmapping_io.hs
    hello there
    E-R-E-H-T- -O-L-L-E-H

おそらく理解していると思うが、`intersperse '-' .reverse . map toUpper`は、受け取った文字列に対して`toUpper`をマッピングし、その結果に対して`reverse`を適用してから`intersperse `を適用するという関数だ。これは、`(\xs -> intersperse '-' (reverse (map toUpper xs)))`と書くのと同じだが、こっちのほうが綺麗だ。

すでに扱ってきたのに、まだ気づいていないその他のファンクタのインスタンスとしては、`(->)`がある。ふむ、今あなたは混乱したと思う。`->`は一体何をするんだっけ? たとえば、`r -> a`という関数の型は、`2 + 3`が`(+) 2 3`と書けるように、`(->) r a`と書きなおすことができる。ところで、`(->) r a`を見た時、少し違った見方をすれば、`Either`のように2つの型パラメータを受け取る型コンストラクタのようにも見えるかもしれない。しかし、思い出してほしい。厳密には、型コンストラクタは1つの型パラメータを受け取る必要がある。このおかげで、ファンクタのインスタンスになれるのだ。これにより、`(->)`はファンクタのインスタンスとすることができない。しかし、部分適用して`(->) r`とすれば何の問題もない。もし、型コンストラクタのシンタックスがセクションを使って部分適用できるとしたら、(たとえば、セクションを使って`+`を部分適用して`(2+)`としたものは、`(+) 2`というのと等しくなるように。)`(->) r`を`(r ->)`として書くことができる。では、関数はどうやってファンクタになるのか? そうだね、では、`Control.Monad.Instances`にある実装がどうなっているかを見てみよう。

通常、何かを受け取って何かを返す関数は、`a -> b`と記す。これは、型変数の部分に違う文字を使っているだけなので、`r -> a`としても同じだ。

    instance Functor ((->) r) where
        fmap f g = (\x -> f (g x))

もし、シンタックス的に可能であれば、これは以下のようにも書ける。

    instance Functor (r ->) where
        fmap f g = (\x -> f (g x))

しかし、このような書き方はできないので、前述の正しいシンタックスで書く必要がある。

ひとまず、`fmap`の型について考えてみよう。`fmap :: (a -> b) -> f a -> f b`となっている。では、この`f`というのを`Functor`のインスタンスとして振る舞う`(->) r`で置き換えるということを想像してみよう。特定のインスタンスに対する`fmap`がどのように振る舞うべきなのかを確認するのだ。すると、`fmap :: (a -> b) -> ((->) r a) -> ((->) r b)`となる。さて、`(->) r a`と`(-> r b)`という型は、普通の関数であるかのように、中置記法で`r -> a`と`r -> b`のように書ける。すると、,`fmap`は`fmap :: (a -> b) -> (r -> a) -> (r -> b)`という型になる。

うーん、わかったぞ。`Maybe`に対する関数のマッピングは、`Maybe`を生成し無くてはならないし、リストに対する関数のマッピングも、リストを生成しなければならないように、関数に対する関数のマッピングも、関数を生成しなければならない。では、この例における`fmap :: (a -> b) -> (r -> a) -> (r -> b)`という型が意味するものは何だろう? そうだね、これは`a`を`b`にする関数と、`r`から`a`にする関数を受け取り、`r`から`b`にする関数を返すことを意味する。さて、何か思い出せたかな? そう、関数合成だ! 我々は`r -> a`の出力を`a -> b`の入力へとパイプして、`r -> b`という関数を得る。これは、まさに関数合成が行おうとしていることだ。もう、上記のインスタンスがどのように定義されているかを見れば、これが単なる関数合成だ、と分かるだろう。このインスタンスを書く別の方法は、以下のとおりだ。

    instance Functor ((->) r) where
        fmap = (.)

これは、関数に対して`fmap`を使うことが明らかに関数合成であることを暴露している。インスタンスがそこに定義されているから`:m + Control.Monad.Instances`して、関数に対するマッピングを試してみよう。

    ghci> :t fmap (*3) (+100)
    fmap (*3) (+100) :: (Num a) => a -> a
    ghci> fmap (*3) (+100) 1
    303
    ghci> (*3) `fmap` (+100) $ 1
    303
    ghci> (*3) . (+100) $ 1
    303
    ghci> fmap (show . (*3)) (*100) 1
    "300"

`fmap`関数は、中置記法でも呼び出せるので`.`との類似性がはっきりする。上記の2行目の入力で、`(*3)`を`(+100)`に対してマッピングした結果は、受け取った入力に対して`(+100)`を呼び出して、さらにその結果に対して`(*3)`を呼び出した結果を返す関数となる。そして、その関数に1を与えて呼び出している。

ところで、箱を使ったたとえはどうなるんだろう? ええと、拡大解釈すれば続けられる。たとえば、`fmap (+3)`を`Just 3`に対して使う場合、`Maybe`は箱であり、その箱の中身に対して`(+3)`をマッピングするというのは容易に想像できるだろう。しかし、`fmap (*3) (+100)`する場合はどうだろう? そうだね、`(+100)`という関数は、その関数の最終的な結果を保持する箱である、とかんがえられる。そう、I/Oアクションが現実世界へでかけて何らかの結果を持ち帰ってくる箱である、と想像できるようにね。`(+100)`に対して`fmap (*3)`を使うと、結果を生成する前に`(+100)`の結果に対して`(*3)`を適用するという別の関数が作成される。これで、`fmap`が関数合成の`.`として振る舞うのかが理解できる。

ある関数が今すぐ役に立たないときに使用される`fmap`は、関数合成であるというのは事実だが、それにしても興味深い。これは我々の心を揺さぶり、いかにして計算というよりある種の箱(`IO`や`(->) r`)がファンクタになるのかを示してくれる。つまり、ある計算に対してマッピングされる関数が返す結果は同じ計算となるものの、返された結果は関数によって変更されたものとなる。

<img src="//s3.amazonaws.com/lyah/lifter.png" alt="挿絵 lifting a function is easier than lifting a million pounds" class="img-right">

さて、`fmap`が従うべき規則についての話へ進む前に、`fmap`の型についてもう一度考えてみよう。`fmap :: (a -> b) -> f a -> f b`となっている。これは`(Functor f) =>`という型の制約を忘れている。しかし、ここではファンクタについて話しているから、`f`が何の略なのかは分かっているので型の制約を取り払って完結にしている。はじめてカリー化された関数について学んだとき、実際には、Haskellにおける全ての関数は1つのパラメータのみを受け取る、と説明した。たとえば、`a -> b -> c`という関数は、`a`という型のパラメータを1つだけ受け取り、`b -> c`という関数を返し、その関数も1つだけパラメータを受け取り`c`を返す。これにより、パラメータが足りていない状態で関数を呼び出すことで、(部分適用とも言う)取り去った部分のパラメータを受け取る関数を得ることになる。(そうすると、関数が複数のパラメータを受け取っているように思える。)つまり、`a -> b -> c`を`a -> (b -> c)`と書きなおせば、カリー化されているのが明確になる。

同じ調子で、`fmap :: (a -> b) -> (f a -> f b)`と書いた場合、`fmap`は、1つの関数とファンクタを受け取り、ファンクタを返す関数ではなく、受け取った関数と似たような新しい関数を返す関数とみなせる。ただし、受け取る関数はパラメータとしてファンクタを受け取り、結果としてファンクタを返す。つまり、`fmap`は`a -> b`という関数を受け取り、`f a -> f b`という関数を返す。これは、関数リフティング(lifting a function)と呼ばれる。では、ghciの`:t`コマンドを使って、この概念を試してみよう。

    ghci> :t fmap (*2)
    fmap (*2) :: (Num a, Functor f) => f a -> f a
    ghci> :t fmap (replicate 3)
    fmap (replicate 3) :: (Functor f) => f a -> f [a]

`fmap (*2)`という式は、数値に対するファンクタ`f`を受け取り、数値に対するファンクタを返す関数だ。そのファンクタというのは、リストや`Maybe`、`Either String`など、何にでもなれる。`fmap (replicate 3)`という式は、あらゆる型のファンクタを受け取り、その型のリストを含むファンクタを返す。

数値に対するファンクタと言ったとき、ファンクタの中に数値が入っているのを想像しただろう。前者はやや誇張気味で技術的には正しく、後者は理解しやすい。

これは、部分適用すればより明確になるので、ghciで`fmap (++"!")`というのを名前に束縛してみよう。

`fmap`は、関数とファンクタを受け取り、その関数をファンクタに対してマッピングしたファンクタを返す関数か、あるいは関数を受け取って、その関数をリフティングしてファンクタを操作できるようにする関数だ、と考えられる。どちらの見方もHaskellにおいては正しく、そして等しい。

`fmap (replicate 3) :: (Functor f) => f a -> f [a]`という型は、どんなファンクタに対しても機能する関数であることを意味する。この関数が行うことは、我々が与えるファンクタによって左右される。たとえば、`fmap (replicate 3)`をリストに対して使えば、リストに対する`fmap`の実装が選択され、`fmap`は単に`map`となる。また、`Maybe a`に対して使えば、`Just`の中味に対して`replicate 3`が適用されるか、`Nothing`であれば`Nothing`のままとなる。


    ghci> fmap (replicate 3) [1,2,3,4]
    [[1,1,1],[2,2,2],[3,3,3],[4,4,4]]
    ghci> fmap (replicate 3) (Just 4)
    Just [4,4,4]
    ghci> fmap (replicate 3) (Right "blah")
    Right ["blah","blah","blah"]
    ghci> fmap (replicate 3) Nothing
    Nothing
    ghci> fmap (replicate 3) (Left "foo")
    Left "foo"

次は、ファンクタの法則について見ていこう。なにかをファンクタにするには、いくつかの法則を満たさなくてはならない。すべてのファンクタは、ある特定の、ファンクタっぽいプロパティや振る舞いを示すことが期待される。それらは確実に、マッピングされることが可能であるもの、のように振る舞わなくてはならない。そして、ファンクタに対する`fmap`の呼び出しは、ファンクタに対して関数をマッピングするか、何もしない。この振る舞いは、ファンクタの法則に定義されている。これら2つのものが、ファンクタのインスタンスが順守しなくてはならないものだ。Haskellが自動的にこれらを強制することはないので、法則を満たしているか自分でテストする必要がある。

ファンクタの第一法則は、ファンクタに対して`id`関数をマッピングすると、結果として返されたファンクタが元のファンクタと同じでなくてはならない、ということを述べている。これをより正確に書くとすれば、`fmap id = id`であることを意味する。つまり、`fmap id`をファンクタに対してマッピングすると、ファンクタに対して`id`を呼び出すのと等しくなる。これは不可欠だ。思い出してほしい。`id`は恒等関数(identity function)であり、受け取ったパラメータを変更せず、そのまま返す。これは、`x -> x`とも書き表せる。ファンクタを、マッピングされることができる何か、という視点で見れば、`fmap id = id`という法則は、些細で自明なことのように思える。

この法則がファンクタの値に対して守られるか見てみよう。

    ghci> fmap id (Just 3)
    Just 3
    ghci> id (Just 3)
    Just 3
    ghci> fmap id [1..5]
    [1,2,3,4,5]
    ghci> id [1..5]
    [1,2,3,4,5]
    ghci> fmap id []
    []
    ghci> fmap id Nothing
    Nothing

ファンクタに対する`fmap`の実装、たとえば`Maybe`の場合を見ると、なぜファンクタの第一法則が守られるのかが分かる。

    instance Functor Maybe where
        fmap f (Just x) = Just (f x)
        fmap f Nothing = Nothing

実装の中で、`id`が`f パラメータ`の役割を担うと想像してみよう。`fmap id`を`Just x`に対して行うと、結果は`Just (id x)`となり、`id`は渡されたパラメータをそのまま返すので、`Just (id x)`が`Just x`であると推論できる。つまり、`Maybe`の値コンストラクタ`Just`に対して`id`をマッピングすれば、同じ値が帰ってくるということが分かる。

`Nothing`という値に対する`id`のマッピングを見てみれば、同じ値が帰ってくるのは明らかだろう。つまり、`fmap`の実装におけるこれら2つの方程式から、`fmap id = id`という法則が保たれることが分かる。

<img src="//s3.amazonaws.com/lyah/justice.png" alt="挿絵 justice is blind, but so is my dog" class="img-left">

第二法則は2つの関数を合成した結果の関数をファンクタに対してマッピングすることは、ファンクタに対して2つの関数の内、最初の関数をマッピングしてから、もう一方の関数をマッピングするのと等しい、ということを言っている。正確に書き表すとすれば、これは`fmap (f . g) = fmap f . fmap g`を意味する。別の方法で書き表せば、どんなファンクタ`F`に対しても`fmap (f . g) F = fmap f (fmap g F)`が保たれることを意味する。

もし、これらのファンクタの法則に従う型を示すことができたら、マッピングなどファンクタとしての基本的な振る舞いを持つ型に頼ることができる。我々はその型に対して`fmap`を使ってマッピングをしても他の何かにはならないことを知っている。そして、それはマッピングされることが可能であるもの、たとえばファンクタとして振る舞う。
ある型に対して第二法則がどのように保たれるかを、`fmap`の実装を見ることで理解できる。
そう、`Maybe`が第一法則に従っているかを確認したのと同じ方法を使って。

もしそうしたければ、`Maybe`がファンクタの第二法則に従っているかを確認することができる。どんな関数でも`Nothing`に対して`fmap`を使えば、`Nothing`が返ってくるから、`Nothing`に対して`fmap (f . g)`をすれば、`Nothing`が得られる。たとえば、`fmap f (fmap g Nothing)`をすれば、同じ理由で`Nothing`が得られる。OK、`Maybe`の値が`Nothing`の場合にファンクタの第二法則が保たれるのは実に単純で、些細な事だ。

では、`Just 何らかの値`の場合はどうだろう? そうだね、`fmap (f . g) (Just x)`をすれば、、`Just ((f . g) x)`として実装されているところから分かるようにそれは、もちろん`Just (f (g x))`となる。もし、`fmap f (fmap g (Just x))`すれば、実装から、`fmap g (Just x)`が`Just (g x)`であることが分かるゆえに、`fmap f (fmap g (Just x))`は、`fmap f (Just (g x))`と等しく、また、実装からも、これがJust (f (g x))`と等しいことが分かる。

この証明があなたを混乱させたとしても、心配する必要はない。関数合成がどのように機能するのかをしっかりと理解しよう。ある型が関数や入れ物のように振る舞うので、これらの法則がどのように守られるのかを直感的に理解することができる。そして、それに対して何種類もの異なる型を試して、その型がたしかに法則を満たしていることを確認することができる。

では、ファンクタのインスタンスとなる型コンストラクタの例を見てみよう。しかし、法則を満たしていないので、本物のファンクタにはなれない。以下のような型があるとしよう。

    data CMaybe a = CNothing | CJust Int a deriving (Show)

このCというのはカウンター(Counter)の略だ。このデータ型は`Maybe a`のものとそっくりだ。ただし、`Just`に相当する部分が1つではなく2つのフィールドを持っている。値コンストラクタ`CJust`の最初のフィールドは常に`Int`となり、2つめのフィールドにはカウンターが入る。2つめのフィールドの型は`a`であり、`a`というのは型パラメータで受け取った型だ。`a`にはもちろん、`CMaybe a`に与える具体的な型によって左右される。直感を働かせるために、この新しい型で遊んでみよう。

    ghci> CNothing
    CNothing
    ghci> CJust 0 "haha"
    CJust 0 "haha"
    ghci> :t CNothing
    CNothing :: CMaybe a
    ghci> :t CJust 0 "haha"
    CJust 0 "haha" :: CMaybe [Char]
    ghci> CJust 100 [1,2,3]
    CJust 100 [1,2,3]

値コンストラクタ`CNothing`を使えば、
フィールドが存在しない。
値コンストラクタ`CJust`を使えば、
最初のフィールドは`Int`であり、2つめのフィールドはどんな型でもよい。
では、これをファンクタのインスタンスにしてみよう。
`fmap`はいつも使うからね。
フィールドが1つになっているから、
関数は2つめのフィールドに適用される。

    instance Functor CMaybe where
        fmap f CNothing = CNothing
        fmap f (CJust counter x) = CJust (counter+1) (f x)


(`CJust`という)
値に対する`fmap`が空の箱を表現しないことと、
その中味に対して関数を適用することはせず、
カウンターを1つ増加させることを除けば、
これは`Maybe`の場合におけるインスタンスの実装のようだ。
ここまで、すべてがクールに思える。
実際に試してみるまでは、

    ghci> fmap (++"ha") (CJust 0 "ho")
    CJust 1 "hoha"
    ghci> fmap (++"he") (fmap (++"ha") (CJust 0 "ho"))
    CJust 2 "hohahe"
    ghci> fmap (++"blah") CNothing
    CNothing

これはファンクタの法則に従っているだろうか? 
もし、法則に従っていないことを確認したければ、
判例を1つ見つければよい。

    ghci> fmap id (CJust 0 "haha")
    CJust 1 "haha"
    ghci> id (CJust 0 "haha")
    CJust 0 "haha"

あっ、ファンクタの第一法則は`id`をファンクタにマッピングすると
`id`をファンクタに対して呼び出した結果とおなじになるのだった。
しかし上記の例を見てみると、
`CMaybe`というファンクタはこれが当てはまらない。
型クラス`Functor`に属しているにもかかわらず、
ファンクタの法則に従っていないから、これはファンクタではない。
もし、誰かが我々の`CMaybe`をファンクタとして使おうとすれば、
ファンクタの法則に従うものと期待するだろう。
しかし、`CMaybe`は従っているように見せかけて、実は従っていない。
つまり、これをファンクタとして使えば、コードに血管が生じるだろう。
ファンクタを使うとき、
最初に幾つかの関数を合成して、
それをファンクタに対してマッピングするのは問題にはならないし、
ファンクタに対して次々と関数をマッピングするのも問題無いだろう。
しかし、`CMaybe`は問題がある。
なぜなら、南海マッピングされたかを追跡しているからだ。
クールじゃないね! 
もし、`CMaybe`をファンクタの法則に従わせるとしたら、
`Int`のフィールドを`fmap`を使った時と同じ状態に保たなくてはならない。

まず最初に、
ファンクタの法則は紛らわしくて不必要に思えるかもしれない。
しかし、両方の法則にしたがう型を見れば、
それがどのように振る舞うのかという前提が得られる。
もし、ある型がファンクタの法則に従うなら、
その型の値に対して`fmap`を呼ぶことは、
その値に対して関数をマッピングすることになる。
それだけだ。
これがコードをより抽象的で拡張性の高いものにしてくれる。
この法則を使うことで、
どんなファンクタに対しても、
振る舞いを推測できるようになり、
関数をファンクタに対して操作できるものにしてくれる。

標準ライブラリにあるファンクタのインスタンスは、すべて法則に従っている。
私を信じないなら、自分でそれを確かめることができる。
それから、あなたがファンクタのインスタンスを作るとき
法則に従っているかを少し時間をかけて確かめてほしい、
それが十分なファンクタであると思案したら、
直感的にプロパティやふるまいが正しいかを調べよう。
共通の部分について、直感的にファンクタの法則に従っているかを判定するのは難しくはないはずだ。
しかし、直感が働かなければ、
常にその実装を1行1行眺めて、
法則が守られているか、
あるいは判例を見つける、ということも可能だ。

ファンクタは、あるコンテキストにおいて値を出力するものだ、という見方もできる。
たとえば、`Just 3`は、コンテキストにおいて`3`という値を出力するか、何も値を出力しないかのどちらかとなる。
`[1,2,3]`は値を3つ、1、2、3というのを出力して、
そのコンテキストは、複数の値があるか、あるいは値がないものとなる。。
`(+3)`という関数は、パラメータとして与えられた値によって出力される値が左右される。

ファンクタを何らかの値を出力するものと考えれば、
ファンクタに対するマッピングは、
値を変化させるために
ファンクタの出力の変形に手を加えていることだ、と考えることができる。
たとえば、`fmap (+3) [1,2,3]`するとき、
`(+3)`という変形を
`[1,2,3]`の出力に対して結びつけて、
どんなときもリストが出力する数値を見てから、
`(+3)`が適用される。
関数に対するマッピングの別の例としては、
`fmap (+3) (*3)`がある。
`(+3)`という変形を、最終的な出力である`(*3)`に結びつけている。
この方法を見ることは、我々に直感を与えてくれて、
`fmap`を使うことがなぜ関数合成になるのか
(`fmap (+3) (*3)`は`(+3) . (*3)`と等しく、また、`\x -> ((x*3)+3)`とも等しい)
これは、`(*3)`という関数を受け取り、
その出力に対して、`(+3)`という変形を結びつけているからだ。
結果はまだ関数であり、
数値を与えた時に初めて、
その数値が3倍されて、
それに結び付けられた3を足すという変形へへと数値が進む。
これが、関数合成で起こっていることだ。



## The newtype keyword - newtypeキーワード

WIP



## Monoids - モノイド

WIP

