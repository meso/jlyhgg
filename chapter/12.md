---
title: "A Fistful of Monads - ひと掴みのモナド"
layout: chapter
---



はじめてファンクタについて語った時、
マッピングできる値にとって、
便利な概念であるということを見てきた。
それから、
その概念をさらに一歩進めて、適用可能なファンクタを導入した。
これは、ある値に
ある種のコンテキストを伴うデータ型の値
という視点を与えてくれた。
そして、それらの値に普通の関数を使っても、
そのコンテキストは保存される。

この節では、
モナドについて学ぶ。
これは、適用可能なファンクタの強化版だ。
適用可能なファンクタがファンクタの強化版であるように、ね。

<img src="//s3.amazonaws.com/lyah/smugpig.png" alt="挿絵 more cool than u" class="img-right">

ファンクタについて学び始めた時
いろいろなデータ型に対して関数をマッピングできることを確認した。
この目的のために、
型クラス`Functor`が導入された。
そして、このような質問を我々に投げかけた。
`a -> b`という型の関数と、`f a`というデータ型の値があり、
`f b`というデータ型の結果を得るには
どのように関数をマッピングするのだろう?
我々は
`[a]`というリストや
`IO`
`Maybe a`などになにかをマッピングする方法を見てきた。
また、`r -> a`という型を持つ関数に対してさえも、
`a -> b`という型の関数をマッピングして、
`r -> b`という型の関数を得る方法を見てきた。
あるデータ型に対して関数をマッピングするには、という質問に応えるには、
`fmap`の型を見る、というのが答えだ。

    fmap :: (Functor f) => (a -> b) -> f a -> f b

適切な`Functor`型クラスを書くことで、
それから、それを我々のデータ型に対して機能するようにさせる。

それから、
おい、
最初から関数`a -> b`をファンクタの値で包んでおいたらどうだ?
という発送をすることで、ファンクタをより良くする方法を見た。
たとえば、`Just (*3)`があるとして、
これを`Just 5`に適用するにはどうするんだろう?
また、`Nothing`ではないときにそれを`Just 5`に適用したくないとしたら、どうするんだろう?
あるいは、
`[(*2),(+4)]`
があるとして、
それを`[1,2,3]`に適用するにはどうするんだろう?
このために適用可能なファンクタの型クラスが導入された。
これは、以下の型がほしい、というものに応えるものだ。

    (<*>) :: (Applicative f) => f (a -> b) -> f a -> f b

また、普通の値を受け取り、データ型で包むことができるというのも確認した。
たとえば、
たとえば、`1`を受け取ってから包むことで、`Just 1`になる。
あるいは、`[1]`にすることもできる。
あるいは、`1`を生み出すだけの何もしないI/Oアクションにすることもできる。
これおを行う関数は`pure`と呼ばれる。

説明したとおり、
この素敵な値は、
技術的な用語にすると、
適用可能な値というのは、コンテキストが追加された値と言える。
たとえば、
`'a'`という文字は、普通の文字であるのに大して、
`Just 'a'`はコンテキストが追加されている。
`Char`の代わりに`Maybe Char`となり、
これは、その値が文字かもしれない、ということを示す。
あるいは、文字は存在しないかもしれない。

普通の関数をコンテキストを持つ値に対して使い、
その値のコンテキストが保持されるのを
型クラス`Applicative`が可能にしてくれることを見てみよう。

    ghci> (*) <$> Just 2 <*> Just 8
    Just 16
    ghci> (++) <$> Just "klingon" <*> Nothing
    Nothing
    ghci> (-) <$> [3,4] <*> [1,2,3]
    [2,1,0,3,2,1]

なんてクールなんだ。
これで、適用可能な値として扱える。
たとえば、`Maybe a`という値は失敗するかもしれない計算を表現する。
また、`[a]`という値はいくつかの結果(非決定的計算)を表現する。
そして、`IO a`という値は副作用を持つ値を表現する。

モナドは以下の様なことを考える場合、適用可能なファンクタの自然な拡張となる。
たとえば、`m a`というコンテキストを持つ値があるとして、
これに普通の`a`を受け取る関数を適用して、コンテキストを保ったままの値を返すにはどうしたらいいんだろう?
つまり、
`a -> m b`という型の関数を`m a`という型の値に適用するにはどうするんだろう?
本質的には、
こういう関数がほしいのだ。

    (>>=) :: (Monad m) => m a -> (a -> m b) -> m b

たとえば、素敵な値と
普通の値を受け取って素敵な値を返す関数があるとしよう。
さて、どうやって素敵な値を関数に食わせよう?
これは、モナドを扱う際に考慮する主要なことの一つだ。
`f a`ではなく`m a`と書くのは、`m`が`Monad`の頭文字だからだ。
しかし、モナドは`>>=`をサポートする適用可能なファンクただ。
`>>=`関数は、束縛を意味する。

たとえば、普通の`a`という型の値と普通の`a -> b`という型の関数があるとして、
その値を関数に食わせるのは簡単だ。
普通に関数をその値に適用する、それだけだ。
しかし、あるコンテキストを伴う値を扱うときは、
これらの素敵な値がどのようにして関数に食われるのか、
そしてその振る舞いについて、
少し考慮しなければならない。
しかし、1から3までが簡単であるとすぐに分かるだろう。



## Getting our feet wet with Maybe - Maybeを思い出そう

WIP



## The Monad type class - モナド型クラス

WIP



## Walk the line - 綱渡り

WIP



## do notation - do注釈

WIP



## The list monad - リストもなど

WIP



## Monad laws - モナドの法則

WIP

