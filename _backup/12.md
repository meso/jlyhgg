---
title: "A Fistful of Monads - ひと掴みのモナド"
layout: chapter
---



はじめてファンクタについて語った時、
マッピングできる値にとって、
便利な概念であるということを見てきた。
それから、
その概念をさらに一歩進めて、適用可能なファンクタを導入した。
これは、ある値に
ある種のコンテキストを伴うデータ型の値
という視点を与えてくれた。
そして、それらの値に普通の関数を使っても、
そのコンテキストは保存される。

この節では、
モナドについて学ぶ。
これは、適用可能なファンクタの強化版だ。
適用可能なファンクタがファンクタの強化版であるように、ね。

<img src="//s3.amazonaws.com/lyah/smugpig.png" alt="挿絵 more cool than u" class="img-right">

ファンクタについて学び始めた時
いろいろなデータ型に対して関数をマッピングできることを確認した。
この目的のために、
型クラス`Functor`が導入された。
そして、このような質問を我々に投げかけた。
`a -> b`という型の関数と、`f a`というデータ型の値があり、
`f b`というデータ型の結果を得るには
どのように関数をマッピングするのだろう?
我々は
`[a]`というリストや
`IO`
`Maybe a`などになにかをマッピングする方法を見てきた。
また、`r -> a`という型を持つ関数に対してさえも、
`a -> b`という型の関数をマッピングして、
`r -> b`という型の関数を得る方法を見てきた。
あるデータ型に対して関数をマッピングするには、という質問に応えるには、
`fmap`の型を見る、というのが答えだ。

    fmap :: (Functor f) => (a -> b) -> f a -> f b

適切な`Functor`型クラスを書くことで、
それから、それを我々のデータ型に対して機能するようにさせる。

それから、
おい、
最初から関数`a -> b`をファンクタの値で包んでおいたらどうだ?
という発送をすることで、ファンクタをより良くする方法を見た。
たとえば、`Just (*3)`があるとして、
これを`Just 5`に適用するにはどうするんだろう?
また、`Nothing`ではないときにそれを`Just 5`に適用したくないとしたら、どうするんだろう?
あるいは、
`[(*2),(+4)]`
があるとして、
それを`[1,2,3]`に適用するにはどうするんだろう?
このために適用可能なファンクタの型クラスが導入された。
これは、以下の型がほしい、というものに応えるものだ。

    (<*>) :: (Applicative f) => f (a -> b) -> f a -> f b

また、普通の値を受け取り、データ型で包むことができるというのも確認した。
たとえば、
たとえば、`1`を受け取ってから包むことで、`Just 1`になる。
あるいは、`[1]`にすることもできる。
あるいは、`1`を生み出すだけの何もしないI/Oアクションにすることもできる。
これおを行う関数は`pure`と呼ばれる。

説明したとおり、
この素敵な値は、
技術的な用語にすると、
適用可能な値というのは、コンテキストが追加された値と言える。
たとえば、
`'a'`という文字は、普通の文字であるのに大して、
`Just 'a'`はコンテキストが追加されている。
`Char`の代わりに`Maybe Char`となり、
これは、その値が文字かもしれない、ということを示す。
あるいは、文字は存在しないかもしれない。

普通の関数をコンテキストを持つ値に対して使い、
その値のコンテキストが保持されるのを
型クラス`Applicative`が可能にしてくれることを見てみよう。

    ghci> (*) <$> Just 2 <*> Just 8
    Just 16
    ghci> (++) <$> Just "klingon" <*> Nothing
    Nothing
    ghci> (-) <$> [3,4] <*> [1,2,3]
    [2,1,0,3,2,1]

なんてクールなんだ。
これで、適用可能な値として扱える。
たとえば、`Maybe a`という値は失敗するかもしれない計算を表現する。
また、`[a]`という値はいくつかの結果(非決定的計算)を表現する。
そして、`IO a`という値は副作用を持つ値を表現する。

モナドは以下の様なことを考える場合、適用可能なファンクタの自然な拡張となる。
たとえば、`m a`というコンテキストを持つ値があるとして、
これに普通の`a`を受け取る関数を適用して、コンテキストを保ったままの値を返すにはどうしたらいいんだろう?
つまり、
`a -> m b`という型の関数を`m a`という型の値に適用するにはどうするんだろう?
本質的には、
こういう関数がほしいのだ。

    (>>=) :: (Monad m) => m a -> (a -> m b) -> m b

たとえば、素敵な値と
普通の値を受け取って素敵な値を返す関数があるとしよう。
さて、どうやって素敵な値を関数に食わせよう?
これは、モナドを扱う際に考慮する主要なことの一つだ。
`f a`ではなく`m a`と書くのは、`m`が`Monad`の頭文字だからだ。
しかし、モナドは`>>=`をサポートする適用可能なファンクただ。
`>>=`関数は、束縛を意味する。

たとえば、普通の`a`という型の値と普通の`a -> b`という型の関数があるとして、
その値を関数に食わせるのは簡単だ。
普通に関数をその値に適用する、それだけだ。
しかし、あるコンテキストを伴う値を扱うときは、
これらの素敵な値がどのようにして関数に食われるのか、
そしてその振る舞いについて、
少し考慮しなければならない。
しかし、1から3までが簡単であるとすぐに分かるだろう。



## Getting our feet wet with Maybe - Maybeを思い出そう

<img src="//s3.amazonaws.com/lyah/buddha.png" alt="挿絵 monads, grasshoppa" class="img-left">

さて、モナドについて漠然とした概念が得られたから、
ちょっとだけ曖昧さをなくしてみよう。

何も驚くべきことはない、
`Maybe`はモナドだ。
モナドについて知っていることを組み合わせてもう少し探検してみよう。

ここでは、適用可能なファンクタについて理解しているのを前提とする。
いろいろな適用可能なもののインスタンスがどのようにきのうするか
そして、それが表現する計算が何なのかを理解しているとよい。
モナドは既存の適用可能なものについての知識をアップグレードしたものにほかならないからだ。

`Maybe a`という型の値は、失敗するかもしれないというコンテキストを伴う型の値を表現する。
たとえば、`Just "dharma"`という値は、
文字列`"dharma"`がそこにあることを意味し、
一方、`Nothing`は、そこにないことを意味する。
あるいは、文字列が計算の結果であるとみなすなら、
`Nothing`は計算が失敗したことを意味する。

`Maybe`をファンクタとみなすとき
それに対して関数を`fmap`したいとすると、
それが`Just`な値であれば、その中身に対してマッピングをして、
`Nothing`の場合は、マッピングするものがないから、`Nothing`のままとなる。

こんなぐあいにだ。

    ghci> fmap (++"!") (Just "wisdom")
    Just "wisdom!"
    ghci> fmap (++"!") Nothing
    Nothing

適用可能なファンクタについても、
これは同様に機能する。
しかし、
適用可能なものは関数を包んでいる。
`Maybe`もそういう意味では適用可能なファンクタであり、
`Maybe`の中にある値に対して関数を適用する場合には`<*>`を使う。
結果が`Just`という値になるものに対しては`Just`となる必要があるし、
そうでなければ結果は`Nothing`になる。
これは理にかなっていて、
関数あるいは適用したいものが足りていない場合に、
なかみを空気の薄い世界へとり出すことはできないので、
失敗をでんぱする必要がある。

    ghci> Just (+3) <*> Just 3
    Just 6
    ghci> Nothing <*> Just "greed"
    Nothing
    ghci> Just ord <*> Nothing
    Nothing

適用可能な方法を`Maybe`な値に対して機能する普通の関数に使う場合も、
同じようになる。
すべての値が`Just`な値になる必要があるのだ。
そうでなければ、結果はすべて`Nothing`になってしまう!

    ghci> max <$> Just 3 <*> Just 6
    Just 6
    ghci> max <$> Just 3 <*> Nothing
    Nothing

では、
`Maybe`に対する`>>=`について考えてみよう。
先に述べたとおり、
`>>=`はモナドっぽい値と、
普通の値を受け取りモナドっぽい値を返す関数を受け取り、
その関数にモナドっぽい値を適用させる。
さて、どのように普通の値を受け取る関数で、それを実現するんだろう?
 そうだね、
これをするには
モナドっぽい値のコンテキストを考慮する必要がある。

この場合、
`>>=`は、`Maybe a`という値と、
`a -> Maybe b`という型の関数を受け取り、
何らかの方法で関数を`Maybe a`に適用する。
これがどう行われるかを理解するため、
`Maybe`が適用可能なファンクタになったときのように、直感を働かせよう。
では、
`\x -> Just (x+1)`
という関数があるとしよう。
これは数値を受け取り、
それに`1`を足してから`Just`で包む。

    ghci> (\x -> Just (x+1)) 1
    Just 2
    ghci> (\x -> Just (x+1)) 100
    Just 101

`1`を与えれば、
`Just 2`と評価される。
`100`という数値を与えれば、
結果は`Just 101`になる。
とても直感的だね。
では、本題にはいろう。
この関数に`Maybe`な値を与えるにはどうするんだろう?
`Maybe`が適用可能なファンクタとして機能すると考えるなら、
コレに応えるのは簡単だ。
たとえば、`Just`な値を与えると、
`Just`の中味を受け取って、関数をそれに適用する。
`Nothing`が与えられれば、うーむ、
そうだね、
関数を取り去って、`Nothing`には何も適用しない。
この場合、
では、結果が`Nothing`になる場合、なにをどうするのか見てみよう。

では、`>>=`を呼び出す代わりに、
`applyMaybe`を呼び出してみよう。
これは`Maybe a`と`Maybe b`を返す関数を受け取り、
その関数に`Maybe a`を適用させる。
これがそのコードだ。

    applyMaybe :: Maybe a -> (a -> Maybe b) -> Maybe b
    applyMaybe Nothing f  = Nothing
    applyMaybe (Just x) f = f x

いいね。
では、これをちょっと試してみよう。
この関数は中置記法で使うので、
`Maybe`な値が左側に、関数が右側に配置する。

    ghci> Just 3 `applyMaybe` \x -> Just (x+1)
    Just 4
    ghci> Just "smile" `applyMaybe` \x -> Just (x ++ " :)")
    Just "smile :)"
    ghci> Nothing `applyMaybe` \x -> Just (x+1)
    Nothing
    ghci> Nothing `applyMaybe` \x -> Just (x ++ " :)")
    Nothing

上記の例では、
`applyMaybe`を`Maybe`な値と関数に対して使用するとき、
関数は単純に`Just`の中味の値に対して適用する。
また、`Nothing`を使おうとした場合は、
全体の結果が`Nothing`となる。
では、もし関数が何も返さなかったとしたら?
見てみよう。

    ghci> Just 3 `applyMaybe` \x -> if x > 2 then Just x else Nothing
    Just 3
    ghci> Just 1 `applyMaybe` \x -> if x > 2 then Just x else Nothing
    Nothing

想像通りだ。
左側のモナドっぽい値が`Nothing`だったら、
すべてが`Nothing`になり、
右側の関数が`Nothing`を返す。
すると、結果も`Nothing`となる。
これは`Maybe`を適用可能なものとして使う場合に、
その中身のどれかが`Nothing`であれば、
結果も`Nothing`になるのと非常に似ている。

`Maybe`について、
我々は、素敵な値を受け取り、
それを普通の値を受け取り素敵な値を返す関数、に与える方法については既に解決した。
`Maybe`な値は失敗するかもしれない計算を表現する、
ということを考慮しながら行った。

あなたは、
これの何が便利なんだ?
と、自問自答するかもしれない。
モナドより適用可能なファンクタのほうが便利そうに思えるかもしれない。
適用可能なファンクタは、
普通の関数を受け取り、それをコンテキストを持つ値に対して操作できるようにしてくれるからだ。
これから、適用可能なファンクタのアップグレード版であるモナドもそれが可能であることを見ていく。
それから、適用可能なファンクタにはできないクールなことが、モナドにはできる、ということも見ていく。

すぐに`Maybe`の話に戻ってくるが、
まずは
モナドに属する型クラスについて確認するとしよう。



## The Monad type class - モナド型クラス

WIP



## Walk the line - 綱渡り

WIP



## do notation - do注釈

WIP



## The list monad - リストもなど

WIP



## Monad laws - モナドの法則

WIP

